<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradingView Pro Trading - Advanced Alert-Based Trading</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Dark Theme Colors */
            --bg-primary: #0a0e1a;
            --bg-secondary: #141824;
            --bg-tertiary: #1c2131;
            --bg-card: #252940;
            --bg-hover: #2d3348;
            
            /* Accent Colors */
            --accent-blue: #00d4ff;
            --accent-green: #00ff88;
            --accent-red: #ff3366;
            --accent-purple: #9945ff;
            --accent-orange: #ff9500;
            --accent-yellow: #ffd700;
            
            /* Text Colors */
            --text-primary: #ffffff;
            --text-secondary: #a0aec0;
            --text-muted: #6b7280;
            
            /* Gradients */
            --gradient-blue: linear-gradient(135deg, #667eea 0%, #00d4ff 100%);
            --gradient-green: linear-gradient(135deg, #00ff88 0%, #00d4aa 100%);
            --gradient-red: linear-gradient(135deg, #ff3366 0%, #ff6b6b 100%);
            --gradient-purple: linear-gradient(135deg, #9945ff 0%, #c770ff 100%);
            
            /* Glass Effect */
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            
            /* Shadows */
            --shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
            padding-top: 10px; /* Add top padding to prevent header cutoff */
        }

        /* Animated Background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(153, 69, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(0, 255, 136, 0.1) 0%, transparent 50%);
            z-index: -1;
            animation: backgroundShift 30s ease-in-out infinite;
        }

        @keyframes backgroundShift {
            0%, 100% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
        }

        /* Header */
        .header {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative; /* Changed from sticky to relative to avoid iframe issues */
            z-index: 100;
            box-shadow: var(--shadow-lg);
            margin: 10px 10px 20px 10px; /* Add proper margins */
            border-radius: 12px; /* Round corners for better look */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 15px;
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo {
            width: 40px;
            height: 40px;
            background: var(--gradient-purple);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        h1 {
            font-size: 24px;
            font-weight: 700;
            background: var(--gradient-blue);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-stats {
            display: flex;
            gap: 30px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            margin-top: 5px;
        }

        .stat-value.positive { color: var(--accent-green); }
        .stat-value.negative { color: var(--accent-red); }

        /* Connection Status */
        .connection-status {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent-green);
            border-radius: 20px;
        }

        .status-indicator.disconnected {
            background: rgba(255, 51, 102, 0.1);
            border-color: var(--accent-red);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--accent-green);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-indicator.disconnected .status-dot {
            background: var(--accent-red);
            animation: none;
        }

        /* Custom Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.2s ease;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 0;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease;
            overflow: hidden;
        }
        
        .modal-header {
            padding: 24px;
            background: linear-gradient(135deg, var(--accent-red), #e74c3c);
            color: white;
        }
        
        .modal-header h3 {
            margin: 0;
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .modal-body {
            padding: 24px;
            color: var(--text-primary);
        }
        
        .modal-warning {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid rgba(231, 76, 60, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
        }
        
        .modal-warning-title {
            color: var(--accent-red);
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .modal-info {
            background: var(--bg-primary);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
        }
        
        .modal-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .modal-info-row:last-child {
            margin-bottom: 0;
        }
        
        .modal-info-label {
            color: var(--text-muted);
            font-size: 14px;
        }
        
        .modal-info-value {
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .modal-footer {
            padding: 20px 24px;
            background: var(--bg-primary);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }
        
        .modal-btn {
            padding: 10px 24px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .modal-btn-cancel {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .modal-btn-cancel:hover {
            background: var(--bg-tertiary);
        }
        
        .modal-btn-confirm {
            background: var(--accent-red);
            color: white;
        }
        
        .modal-btn-confirm:hover {
            background: #e74c3c;
            transform: translateY(-1px);
        }
        
        .modal-btn-confirm.danger {
            background: var(--accent-red);
        }
        
        .modal-btn-confirm.success {
            background: var(--accent-green);
        }
        
        .modal-btn-confirm.success:hover {
            background: #27ae60;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideUp {
            from { 
                transform: translateY(20px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 136, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0); }
        }

        /* Main Container */
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            padding-top: 30px; /* Extra padding to ensure header is visible */
        }

        /* Grid Layout */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 900px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Glass Card */
        .glass-card {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }

        .glass-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--gradient-blue);
            opacity: 0.5;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--glass-border);
        }

        .card-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title i {
            color: var(--accent-blue);
        }

        /* Form Controls */
        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .form-control {
            width: 100%;
            padding: 10px 15px;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
        }

        select.form-control {
            cursor: pointer;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-secondary);
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--accent-green);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--gradient-blue);
            color: white;
        }

        .btn-success {
            background: var(--gradient-green);
            color: white;
        }

        .btn-danger {
            background: var(--gradient-red);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ff9500 0%, #ffb347 100%);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Webhook Configuration */
        .webhook-url-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .webhook-url {
            flex: 1;
            padding: 15px;
            background: var(--bg-secondary);
            border: 2px dashed var(--glass-border);
            border-radius: 8px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            color: var(--accent-yellow);
        }

        .copy-btn {
            padding: 15px;
            background: var(--gradient-purple);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            transform: scale(1.05);
        }

        /* Signal Cards */
        .signals-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(4, auto);
            gap: 8px;
            margin-top: 15px;
            overflow: visible;
        }
        
        @media (max-width: 1600px) {
            .signals-grid {
                grid-template-columns: repeat(3, 1fr);
                grid-template-rows: repeat(3, auto);
            }
        }
        
        @media (max-width: 1200px) {
            .signals-grid {
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: repeat(4, auto);
            }
        }

        .signal-card {
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 8px;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
            font-size: 11px;
        }

        .signal-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-color: var(--accent-blue);
        }

        .signal-card.active {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.05);
        }

        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .signal-name {
            font-weight: 600;
            font-size: 14px;
        }

        .signal-type {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 12px;
            background: var(--bg-tertiary);
        }

        .signal-type.bullish {
            color: var(--accent-green);
            background: rgba(0, 255, 136, 0.1);
        }

        .signal-type.bearish {
            color: var(--accent-red);
            background: rgba(255, 51, 102, 0.1);
        }

        .signal-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid var(--glass-border);
            font-size: 10px;
        }

        .signal-stat {
            text-align: center;
        }

        .signal-stat-value {
            font-weight: 600;
            color: var(--text-primary);
        }

        .signal-stat-label {
            color: var(--text-muted);
            margin-top: 2px;
        }

        /* Position Configuration */
        .config-section {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .config-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        /* Hedge Configuration */
        .hedge-method {
            padding: 15px;
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .hedge-method:hover {
            border-color: var(--accent-blue);
        }

        .hedge-method.selected {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.05);
        }

        .hedge-method input[type="radio"] {
            margin-right: 8px;
        }

        .hedge-preview {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border-left: 3px solid var(--accent-blue);
        }

        .hedge-calculation {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 13px;
        }

        .hedge-calculation span:first-child {
            color: var(--text-muted);
        }

        .hedge-calculation span:last-child {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Breakeven Monitor */
        .breakeven-display {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
            margin-top: 15px;
        }

        .breakeven-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--accent-yellow);
            margin: 10px 0;
        }

        .position-legs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .leg-card {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid var(--accent-blue);
        }

        .leg-card.hedge {
            border-left-color: var(--accent-purple);
        }

        .leg-title {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .leg-details {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 13px;
        }

        /* Stop Loss Management */
        .sl-level {
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 3px solid var(--accent-orange);
        }

        .sl-level-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .sl-level-title {
            font-weight: 600;
            font-size: 13px;
        }

        .sl-level-trigger {
            font-size: 12px;
            color: var(--text-muted);
        }

        .sl-progress {
            height: 4px;
            background: var(--bg-secondary);
            border-radius: 2px;
            overflow: hidden;
        }

        .sl-progress-bar {
            height: 100%;
            background: var(--gradient-green);
            transition: width 0.3s ease;
        }

        /* Active Orders Table */
        .orders-table {
            width: 100%;
            margin-top: 10px;
            border-collapse: collapse;
        }

        .orders-table thead {
            background: var(--bg-secondary);
        }

        .orders-table th {
            padding: 10px 8px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--glass-border);
        }

        .orders-table td {
            padding: 10px 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 12px;
            color: var(--text-secondary);
        }

        .orders-table tbody tr:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        /* Order Status Badges */
        .status-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-block;
        }

        .status-open {
            background: var(--accent-blue);
            color: white;
        }

        .status-complete {
            background: var(--accent-green);
            color: white;
        }

        .status-rejected {
            background: var(--accent-red);
            color: white;
        }

        .status-cancelled {
            background: #757575;
            color: white;
        }

        .status-trigger-pending {
            background: var(--accent-yellow);
            color: black;
        }

        .status-open-pending,
        .status-validation-pending {
            background: var(--accent-orange);
            color: white;
        }

        .status-modify-pending {
            background: var(--accent-purple);
            color: white;
        }

        /* Live Positions Table */
        .positions-table {
            width: 100%;
            margin-top: 20px;
        }

        .positions-table thead {
            background: var(--bg-secondary);
        }

        .positions-table th {
            padding: 12px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .positions-table td {
            padding: 12px;
            border-top: 1px solid var(--glass-border);
            font-size: 13px;
        }

        .positions-table tbody tr:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .position-symbol {
            font-weight: 600;
            color: var(--text-primary);
        }

        .position-pnl {
            font-weight: 600;
        }

        .position-pnl.positive {
            color: var(--accent-green);
        }

        .position-pnl.negative {
            color: var(--accent-red);
        }

        .position-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            padding: 5px 10px;
            font-size: 11px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .action-btn.modify {
            background: var(--accent-blue);
            color: white;
        }

        .action-btn.exit {
            background: var(--accent-red);
            color: white;
        }

        /* Alert Stream */
        .alert-stream {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .alert-item {
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            transition: all 0.3s ease;
            position: relative;
            overflow: visible;
        }

        .alert-item:hover {
            border-color: var(--accent-blue);
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .alert-item.executed {
            background: rgba(34, 197, 94, 0.05);
        }
        
        .alert-item.cancelled {
            opacity: 0.5;
        }
        
        .alert-actions-container {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .alert-actions {
            display: flex;
            gap: 8px;
        }

        .btn-alert-action {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .btn-execute {
            background: var(--accent-green);
            color: white;
        }

        .btn-execute:hover {
            background: #00cc70;
            transform: translateY(-1px);
        }

        .btn-modify {
            background: var(--accent-blue);
            color: white;
        }

        .btn-modify:hover {
            background: #00a8cc;
            transform: translateY(-1px);
        }

        .btn-cancel {
            background: var(--accent-red);
            color: white;
        }

        .btn-cancel:hover {
            background: #cc0033;
            transform: translateY(-1px);
        }
        
        .btn-alert-action:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .btn-alert-action:disabled:hover {
            transform: none !important;
        }

        .alert-item.executed {
            opacity: 0.6;
            border-color: var(--accent-green);
        }

        .alert-item.cancelled {
            opacity: 0.4;
            text-decoration: line-through;
        }

        .alert-content {
            flex: 1;
        }
        
        /* Modal Styles for Modify Dialog */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 24px;
            min-width: 400px;
            max-width: 500px;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .alert-signal {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 5px;
        }

        .alert-details {
            font-size: 12px;
            color: var(--text-muted);
        }

        .alert-time {
            font-size: 11px;
            color: var(--text-muted);
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--accent-blue);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            padding: 15pen 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification.success {
            border-left: 3px solid var(--accent-green);
        }

        .notification.error {
            border-left: 3px solid var(--accent-red);
        }

        .notification.warning {
            border-left: 3px solid var(--accent-orange);
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-hover);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-blue);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
            }

            .header-stats {
                width: 100%;
                justify-content: space-around;
            }

            .main-grid {
                grid-template-columns: 1fr;
            }

            .config-grid {
                grid-template-columns: 1fr;
            }

            .position-legs {
                grid-template-columns: 1fr;
            }
        }

        /* Master Control Panel */
        .master-controls {
            background: var(--bg-secondary);
            border: 2px solid var(--glass-border);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 20px;
        }

        .auto-trade-toggle {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .big-toggle {
            width: 80px;
            height: 40px;
        }

        .big-toggle .toggle-slider:before {
            height: 32px;
            width: 32px;
            left: 4px;
            bottom: 4px;
        }

        .big-toggle input:checked + .toggle-slider:before {
            transform: translateX(40px);
        }

        .panic-btn {
            padding: 15px 30px;
            background: var(--gradient-red);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .panic-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(255, 51, 102, 0.4);
        }

        .panic-btn:active {
            transform: scale(0.95);
        }

        .trading-mode-selector {
            display: flex;
            gap: 10px;
        }

        /* Mode button styles removed - Live trading only */

        /* Time-based SL Timeline */
        .timeline-container {
            position: relative;
            padding: 20px 0;
        }

        .timeline {
            display: flex;
            justify-content: space-between;
            position: relative;
            padding: 0 20px;
        }

        .timeline::before {
            content: '';
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            height: 2px;
            background: var(--glass-border);
        }

        .timeline-item {
            position: relative;
            text-align: center;
            z-index: 1;
        }

        .timeline-dot {
            width: 12px;
            height: 12px;
            background: var(--bg-secondary);
            border: 2px solid var(--accent-blue);
            border-radius: 50%;
            margin: 0 auto 10px;
        }

        .timeline-item.active .timeline-dot {
            background: var(--accent-green);
            border-color: var(--accent-green);
        }

        .timeline-label {
            font-size: 12px;
            color: var(--text-muted);
        }

        .timeline-value {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 5px;
        }
    </style>
    <script>
        // Define critical functions globally immediately on page load
        window.setTradingMode = function(mode) {
            console.log(`[MODE] Switching to ${mode} mode`);
            
            // Update global mode variable
            window.currentTradingMode = mode;
            
            // Wait for DOM if not ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    updateModeUI(mode);
                });
            } else {
                updateModeUI(mode);
            }
            
            // Store mode in server database and localStorage
            saveSettingToServer('trading_mode', mode);
            console.log(`[MODE] Saving to database: ${mode}`);
            
            return true;
        }
        
        function updateModeUI(mode) {
            // Update UI - remove active state from all buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.classList.remove('btn-primary');
            });
            
            // Find and activate the correct button
            document.querySelectorAll('.mode-btn').forEach(btn => {
                if (btn.textContent.includes(mode)) {
                    btn.classList.add('active');
                    btn.classList.add('btn-primary');
                }
            });
        }
        
        // Live Trading Only Mode
        window.currentTradingMode = 'LIVE';
        console.log('[INIT] Live trading mode active');
        
        // MODE-SPECIFIC TRADE EXECUTION
        window.executeTrade = async function(signal, strike, type, action = 'ENTRY') {
            const mode = 'LIVE'; // Live trading only
            console.log(`[TRADE] Executing in ${mode} mode: ${signal} ${strike}${type}`);
            
            // GET ACTUAL SETTINGS
            const numLots = parseInt(document.getElementById('numLots').value) || 10;
            const entryTiming = document.getElementById('entryTiming').value || 'immediate';
            const totalQuantity = numLots * 75; // NIFTY lot size = 75
            
            // GET STOP LOSS SETTINGS
            const profitLockEnabled = document.getElementById('profitLockEnabled')?.checked || false;
            const profitTarget = profitLockEnabled ? parseFloat(document.getElementById('profitTarget')?.value || 10) : null;
            const profitLock = profitLockEnabled ? parseFloat(document.getElementById('profitLock')?.value || 5) : null;
            
            const trailingStopEnabled = document.getElementById('trailingStopEnabled')?.checked || false;
            const trailPercent = trailingStopEnabled ? parseFloat(document.getElementById('trailPercent')?.value || 1) : null;
            
            console.log(`[SETTINGS] Lots: ${numLots}, Quantity: ${totalQuantity}, Entry: ${entryTiming}`);
            console.log(`[STOP LOSS] ProfitLock: ${profitLockEnabled} (${profitTarget}%/${profitLock}%), Trailing: ${trailingStopEnabled} (${trailPercent}%)`);
            
            // Handle entry timing
            if (entryTiming === 'next_candle' && action === 'ENTRY') {
                console.log('[TIMING] Waiting for next candle...');
                // You can add delay logic here if needed
            }
            
            // Live trading only - simplified
            const endpoint = '/live/execute-signal';
            const payload = {
                signal: signal,
                action: action,
                strike: strike,
                option_type: type,
                spot_price: 25000,
                quantity: numLots,  // Send number of lots
                entry_timing: entryTiming,
                // Stop loss parameters
                profit_lock_enabled: profitLockEnabled,
                profit_target: profitTarget,
                profit_lock: profitLock,
                trailing_stop_enabled: trailingStopEnabled,
                trail_percent: trailPercent
            };
            
            // Confirmation for live trades
            if (!confirm(`LIVE TRADE: Execute ${signal} ${strike}${type}?\n\nLots: ${numLots} (${totalQuantity} qty)\nThis will use REAL money!`)) {
                return false;
            }
            
            try {
                const response = await fetch(getApiUrl(endpoint), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log(`[TRADE] Success:`, result);
                    if (window.showNotification) {
                        window.showNotification(`${mode} trade executed: ${signal}`, 'success');
                    }
                    return true;
                } else {
                    const error = await response.text();
                    console.error(`[TRADE] Failed:`, error);
                    if (window.showNotification) {
                        window.showNotification(`Trade failed in ${mode} mode`, 'error');
                    }
                    return false;
                }
            } catch (error) {
                console.error(`[TRADE] Error:`, error);
                return false;
            }
        }
        
        // LIVE DATA LOADING ONLY
        window.loadModeSpecificData = function() {
            console.log('[DATA] Loading live trading data');
            
            // Load live trading data only
            if (typeof loadLivePositions === 'function') loadLivePositions();
            if (typeof loadLivePnL === 'function') loadLivePnL();
        }
        
        // Initialize stop loss handlers
        window.initializeStopLossHandlers = function() {
            // Profit Lock checkbox handler
            const profitLockCheckbox = document.getElementById('profitLockEnabled');
            const profitLockConfig = document.getElementById('profitLockConfig');
            const profitLockStatusDisplay = document.getElementById('profitLockStatusDisplay');
            
            if (profitLockCheckbox) {
                profitLockCheckbox.addEventListener('change', function() {
                    if (this.checked) {
                        profitLockConfig.style.display = 'block';
                        profitLockStatusDisplay.style.display = 'block';
                        
                        // Update display values
                        const targetValue = document.getElementById('profitTarget').value;
                        const lockValue = document.getElementById('profitLock').value;
                        document.getElementById('profitTargetShow').textContent = targetValue;
                        document.getElementById('profitLockShow').textContent = lockValue;
                    } else {
                        profitLockConfig.style.display = 'none';
                        profitLockStatusDisplay.style.display = 'none';
                    }
                });
            }
            
            // Trailing Stop checkbox handler
            const trailingStopCheckbox = document.getElementById('trailingStopEnabled');
            const trailingStopConfig = document.getElementById('trailingStopConfig');
            const trailingStopStatusDisplay = document.getElementById('trailingStopStatusDisplay');
            
            if (trailingStopCheckbox) {
                trailingStopCheckbox.addEventListener('change', function() {
                    if (this.checked) {
                        trailingStopConfig.style.display = 'block';
                        trailingStopStatusDisplay.style.display = 'block';
                        
                        // Update display values
                        const trailValue = document.getElementById('trailPercent').value;
                        document.getElementById('trailPercentShow').textContent = trailValue;
                    } else {
                        trailingStopConfig.style.display = 'none';
                        trailingStopStatusDisplay.style.display = 'none';
                    }
                });
            }
            
            // Update display when values change
            ['profitTarget', 'profitLock', 'trailPercent'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', function() {
                        const showId = id === 'profitTarget' ? 'profitTargetShow' : 
                                       id === 'profitLock' ? 'profitLockShow' : 
                                       'trailPercentShow';
                        const showElement = document.getElementById(showId);
                        if (showElement) {
                            showElement.textContent = this.value;
                        }
                    });
                }
            });
        }
        
        // Initialize on DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeStopLossHandlers);
        } else {
            initializeStopLossHandlers();
        }
    </script>
    <script>
        // Detect if page is loaded in an iframe
        if (window.self !== window.top) {
            document.documentElement.classList.add('in-iframe');
        }
    </script>
    <style>
        /* Keep header visible even in iframe */
        /* Removed the hiding of header in iframe */
        
        /* Adjust container when header is hidden */
        .in-iframe .container {
            margin-top: 20px;
        }
        
        /* Keep master controls visible but compact */
        .in-iframe .master-controls {
            position: sticky;
            top: 0;
            background: var(--bg-primary);
            z-index: 100;
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-title">
            <div class="logo">
                <i class="fas fa-chart-line"></i>
            </div>
            <h1>TradingView Pro Trading</h1>
        </div>

        <div class="connection-status">
            <div class="status-indicator" id="apiStatus">
                <span class="status-dot"></span>
                <span>API Server</span>
                <span id="apiLatency">45ms</span>
            </div>
            <div class="status-indicator" id="tvWebhookStatus">
                <span class="status-dot"></span>
                <span>TradingView</span>
                <span id="tvWebhookTime">Never</span>
            </div>
            <div class="status-indicator" id="brokerStatus">
                <span class="status-dot"></span>
                <span>Broker</span>
            </div>
        </div>

        <!-- Broker Status Indicators -->
        <div style="display: flex; gap: 15px; align-items: center;">
            <div class="broker-status" id="breezeStatusIndicator" style="display: flex; align-items: center; gap: 5px; padding: 5px 10px; background: var(--bg-secondary); border-radius: 8px;">
                <span class="status-dot" id="breezeStatusDot" style="width: 8px; height: 8px; border-radius: 50%; background: #6b7280;"></span>
                <span style="font-size: 12px; color: var(--text-secondary);">Breeze</span>
            </div>
            <div class="broker-status" id="kiteStatusIndicator" style="display: flex; align-items: center; gap: 5px; padding: 5px 10px; background: var(--bg-secondary); border-radius: 8px;">
                <span class="status-dot" id="kiteStatusDot" style="width: 8px; height: 8px; border-radius: 50%; background: #6b7280;"></span>
                <span style="font-size: 12px; color: var(--text-secondary);">Kite</span>
            </div>
            <div class="broker-status" id="tvStatusIndicator" style="display: flex; align-items: center; gap: 5px; padding: 5px 10px; background: var(--bg-secondary); border-radius: 8px;">
                <span class="status-dot" id="tvStatusDot" style="width: 8px; height: 8px; border-radius: 50%; background: #6b7280;"></span>
                <span style="font-size: 12px; color: var(--text-secondary);">TradingView</span>
            </div>
        </div>

        <div class="header-stats">
            <div class="stat-item">
                <div class="stat-label">NIFTY Spot</div>
                <div class="stat-value" id="niftySpot">No data</div>
                <div class="stat-timestamp" id="niftySpotTime" style="font-size: 10px; color: var(--text-muted);">--:--:--</div>
                <div class="stat-age" id="niftySpotAge" style="font-size: 9px; color: var(--accent-yellow);">No data</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Today's P&L</div>
                <div class="stat-value" id="todayPnL">â‚¹0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Open Positions</div>
                <div class="stat-value" id="openPositions">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Win Rate</div>
                <div class="stat-value positive" id="winRate">0%</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Active Signals</div>
                <div class="stat-value" id="activeSignals">0</div>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Master Controls -->
        <div class="master-controls">
            <!-- Trading Mode Status (Dynamic) -->
            <div id="tradingModeStatus" style="padding: 8px 16px; background: var(--bg-tertiary); border-radius: 8px; display: inline-flex; align-items: center; gap: 8px;">
                <i class="fas fa-circle" id="tradingModeIcon" style="font-size: 8px;"></i>
                <span id="tradingModeText" style="font-weight: 600; color: var(--text-secondary);">MANUAL MODE</span>
            </div>

            <!-- Kill Switch Controls -->
            <div id="killSwitchContainer" style="display: inline-flex; align-items: center; gap: 15px; padding: 8px 16px; background: var(--glass-bg); border: 2px solid var(--glass-border); border-radius: 8px;">
                <div id="killSwitchStatus" style="display: inline-flex; align-items: center; gap: 8px;">
                    <i class="fas fa-shield-alt" style="color: var(--accent-green);"></i>
                    <span style="font-weight: 600;">KILL SWITCH: <span id="killSwitchState" style="color: var(--accent-green);">READY</span></span>
                </div>
                <button id="killSwitchBtn" class="btn btn-danger" onclick="triggerKillSwitch()" style="padding: 8px 16px; background: linear-gradient(135deg, #ff3366, #ff0044); border: none; border-radius: 6px; color: white; font-weight: 600; cursor: pointer;">
                    <i class="fas fa-power-off"></i> TRIGGER
                </button>
            </div>

            <button class="panic-btn" onclick="emergencyCloseAll()">
                <i class="fas fa-exclamation-triangle"></i> PANIC CLOSE ALL
            </button>
        </div>

        <!-- Main Grid -->
        <div class="main-grid">
            <!-- Webhook Configuration -->
            <div class="glass-card">
                <div class="card-header">
                    <div class="card-title">
                        <i class="fas fa-webhook"></i>
                        Webhook Configuration
                    </div>
                    <button class="btn btn-primary btn-sm" onclick="(async function() {
                        try {
                            // Find textarea by multiple methods
                            let textarea = document.getElementById('webhookPayload') || 
                                          document.querySelector('#webhookPayload') ||
                                          document.querySelector('textarea[id=webhookPayload]') ||
                                          document.querySelector('.form-control[rows=\'7\']') ||
                                          Array.from(document.querySelectorAll('textarea')).find(t => t.value && t.value.includes('tradingview-webhook-secret-key-2025'));
                            
                            if (!textarea) {
                                alert('Cannot find webhook payload textarea. Please refresh the page completely (Ctrl+Shift+R)');
                                return;
                            }
                            
                            let payload;
                            try {
                                payload = JSON.parse(textarea.value);
                            } catch (e) {
                                alert('Invalid JSON in textarea. Please check the format.');
                                return;
                            }
                            
                            if (typeof payload.strike === 'string' && payload.strike.includes('{{')) {
                                alert('Please replace {{plot_0}} with an actual strike price like 25000');
                                return;
                            }
                            
                            const response = await fetch(getApiUrl('/webhook/entry'), {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify(payload)
                            });
                            
                            const result = await response.json();
                            
                            if (response.ok && result.status === 'success') {
                                showNotification('âœ… Webhook test successful! Check Active Orders.', 'success');
                                if (typeof loadActiveOrders === 'function') loadActiveOrders();
                            } else {
                                showNotification(result.message || 'Webhook test failed', 'error');
                            }
                        } catch (error) {
                            console.error('Error:', error);
                            alert('Error: ' + error.message);
                        }
                    })()">
                        <i class="fas fa-vial"></i> Test
                    </button>
                </div>

                <div class="webhook-url-container">
                    <div class="webhook-url" id="webhookUrl">http://localhost:8000/webhook/tradingview</div>
                    <button class="copy-btn" onclick="copyWebhookUrl()">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>

                <div class="form-group">
                    <label class="form-label">Alert Message (Edit for testing)</label>
                    <textarea class="form-control" id="webhookPayload" rows="7" style="font-family: monospace; font-size: 12px;">{
  "secret": "tradingview-webhook-secret-key-2025",
  "strike": 25000,
  "type": "PE",
  "signal": "S1",
  "action": "Entry"
}</textarea>
                    <small class="text-muted">For testing: Replace {{plot_0}} with actual strike price (e.g., 25000)</small>
                </div>

                <button class="btn btn-success" onclick="showSetupWizard()">
                    <i class="fas fa-magic"></i> Setup Wizard
                </button>
            </div>

            <!-- Active Signals section removed - now in Configuration Panel -->
            <!-- Signals moved to Configuration Panel -->
            <!--
                <div class="signals-grid">
                    <div class="signal-card active" id="signalS1" data-signal="S1">
                        <div class="signal-header">
                            <span class="signal-name">S1</span>
                            <input type="checkbox" id="toggleS1" class="signal-toggle" data-signal="S1" value="S1" checked onclick="event.stopPropagation()" onchange="toggleSignal('S1')">
                            <span class="signal-type bullish">BULLISH</span>
                        </div>
                        <div style="font-size: 12px; color: var(--text-muted); margin: 5px 0;">Bear Trap</div>
                        <div class="signal-stats">
                            <div class="signal-stat">
                                <div class="signal-stat-value">12</div>
                                <div class="signal-stat-label">Trades</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">75%</div>
                                <div class="signal-stat-label">Win</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">+8.5K</div>
                                <div class="signal-stat-label">P&L</div>
                            </div>
                        </div>
                    </div>

                    <div class="signal-card active" id="signalS2" data-signal="S2">
                        <div class="signal-header">
                            <span class="signal-name">S2</span>
                            <input type="checkbox" id="toggleS2" class="signal-toggle" data-signal="S2" value="S2" checked onclick="event.stopPropagation()" onchange="toggleSignal('S2')">
                            <span class="signal-type bullish">BULLISH</span>
                        </div>
                        <div style="font-size: 12px; color: var(--text-muted); margin: 5px 0;">Support Hold</div>
                        <div class="signal-stats">
                            <div class="signal-stat">
                                <div class="signal-stat-value">8</div>
                                <div class="signal-stat-label">Trades</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">62%</div>
                                <div class="signal-stat-label">Win</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">+3.2K</div>
                                <div class="signal-stat-label">P&L</div>
                            </div>
                        </div>
                    </div>

                    <div class="signal-card active" id="signalS3" data-signal="S3">
                        <div class="signal-header">
                            <span class="signal-name">S3</span>
                            <input type="checkbox" id="toggleS3" class="signal-toggle" data-signal="S3" value="S3" checked onclick="event.stopPropagation()" onchange="toggleSignal('S3')">
                            <span class="signal-type bearish">BEARISH</span>
                        </div>
                        <div style="font-size: 12px; color: var(--text-muted); margin: 5px 0;">Resistance Hold</div>
                        <div class="signal-stats">
                            <div class="signal-stat">
                                <div class="signal-stat-value">15</div>
                                <div class="signal-stat-label">Trades</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">80%</div>
                                <div class="signal-stat-label">Win</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">+12K</div>
                                <div class="signal-stat-label">P&L</div>
                            </div>
                        </div>
                    </div>

                    <div class="signal-card active" id="signalS4" data-signal="S4">
                        <div class="signal-header">
                            <span class="signal-name">S4</span>
                            <input type="checkbox" id="toggleS4" class="signal-toggle" data-signal="S4" value="S4" checked onclick="event.stopPropagation()" onchange="toggleSignal('S4')">
                            <span class="signal-type bullish">BULLISH</span>
                        </div>
                        <div style="font-size: 12px; color: var(--text-muted); margin: 5px 0;">Bias Failure Bull</div>
                        <div class="signal-stats">
                            <div class="signal-stat">
                                <div class="signal-stat-value">6</div>
                                <div class="signal-stat-label">Trades</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">50%</div>
                                <div class="signal-stat-label">Win</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">-1.5K</div>
                                <div class="signal-stat-label">P&L</div>
                            </div>
                        </div>
                    </div>

                    <div class="signal-card active" id="signalS5" data-signal="S5">
                        <div class="signal-header">
                            <span class="signal-name">S5</span>
                            <input type="checkbox" id="toggleS5" class="signal-toggle" data-signal="S5" value="S5" checked onclick="event.stopPropagation()" onchange="toggleSignal('S5')">
                            <span class="signal-type bearish">BEARISH</span>
                        </div>
                        <div style="font-size: 12px; color: var(--text-muted); margin: 5px 0;">Bias Failure Bear</div>
                        <div class="signal-stats">
                            <div class="signal-stat">
                                <div class="signal-stat-value">10</div>
                                <div class="signal-stat-label">Trades</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">70%</div>
                                <div class="signal-stat-label">Win</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">+5.8K</div>
                                <div class="signal-stat-label">P&L</div>
                            </div>
                        </div>
                    </div>

                    <div class="signal-card active" id="signalS6" data-signal="S6">
                        <div class="signal-header">
                            <span class="signal-name">S6</span>
                            <input type="checkbox" id="toggleS6" class="signal-toggle" data-signal="S6" value="S6" checked onclick="event.stopPropagation()" onchange="toggleSignal('S6')">
                            <span class="signal-type bearish">BEARISH</span>
                        </div>
                        <div style="font-size: 12px; color: var(--text-muted); margin: 5px 0;">Weakness Confirmed</div>
                        <div class="signal-stats">
                            <div class="signal-stat">
                                <div class="signal-stat-value">9</div>
                                <div class="signal-stat-label">Trades</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">66%</div>
                                <div class="signal-stat-label">Win</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">+4.2K</div>
                                <div class="signal-stat-label">P&L</div>
                            </div>
                        </div>
                    </div>

                    <div class="signal-card active" id="signalS7" data-signal="S7">
                        <div class="signal-header">
                            <span class="signal-name">S7</span>
                            <input type="checkbox" id="toggleS7" class="signal-toggle" data-signal="S7" value="S7" checked onclick="event.stopPropagation()" onchange="toggleSignal('S7')">
                            <span class="signal-type bullish">BULLISH</span>
                        </div>
                        <div style="font-size: 12px; color: var(--text-muted); margin: 5px 0;">Breakout Confirmed</div>
                        <div class="signal-stats">
                            <div class="signal-stat">
                                <div class="signal-stat-value">14</div>
                                <div class="signal-stat-label">Trades</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">78%</div>
                                <div class="signal-stat-label">Win</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">+9.5K</div>
                                <div class="signal-stat-label">P&L</div>
                            </div>
                        </div>
                    </div>

                    <div class="signal-card active" id="signalS8" data-signal="S8">
                        <div class="signal-header">
                            <span class="signal-name">S8</span>
                            <input type="checkbox" id="toggleS8" class="signal-toggle" data-signal="S8" value="S8" checked onclick="event.stopPropagation()" onchange="toggleSignal('S8')">
                            <span class="signal-type bearish">BEARISH</span>
                        </div>
                        <div style="font-size: 12px; color: var(--text-muted); margin: 5px 0;">Breakdown Confirmed</div>
                        <div class="signal-stats">
                            <div class="signal-stat">
                                <div class="signal-stat-value">11</div>
                                <div class="signal-stat-label">Trades</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">72%</div>
                                <div class="signal-stat-label">Win</div>
                            </div>
                            <div class="signal-stat">
                                <div class="signal-stat-value">+6.3K</div>
                                <div class="signal-stat-label">P&L</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            -->

            <!-- Active Orders -->
            <div class="glass-card" id="orders">
                <div class="card-header">
                    <div class="card-title">
                        <i class="fas fa-clock"></i>
                        Active Orders
                    </div>
                    <div class="order-stats">
                        <span class="badge" id="pendingCount" style="background: var(--accent-orange);">0 Pending</span>
                        <span class="badge" id="openCount" style="background: var(--accent-blue); margin-left: 8px;">0 Open</span>
                        <button onclick="cancelAllOrders()" class="btn-action" style="margin-left: 12px; padding: 6px 12px; font-size: 11px; background: var(--accent-red); color: white; border: none; border-radius: 4px; cursor: pointer;">
                            <i class="fas fa-times-circle"></i> Cancel All
                        </button>
                    </div>
                </div>
                <div id="ordersTable" style="overflow-x: auto;">
                    <table class="orders-table" style="width: 100%; font-size: 12px;">
                        <thead>
                            <tr>
                                <th style="text-align: left; padding: 8px;">Order ID</th>
                                <th style="text-align: left; padding: 8px;">Symbol</th>
                                <th style="text-align: center; padding: 8px;">Type</th>
                                <th style="text-align: center; padding: 8px;">Qty</th>
                                <th style="text-align: right; padding: 8px;">Price</th>
                                <th style="text-align: center; padding: 8px;">Status</th>
                                <th style="text-align: center; padding: 8px;">Time</th>
                                <th style="text-align: center; padding: 8px;">Action</th>
                            </tr>
                        </thead>
                        <tbody id="ordersTableBody">
                            <tr>
                                <td colspan="8" style="text-align: center; padding: 20px; color: var(--text-muted);">
                                    No active orders
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Option Chain -->
            <div class="glass-card" id="option-chain">
                <div class="card-header">
                    <div class="card-title">
                        <i class="fas fa-table"></i>
                        Option Chain
                    </div>
                </div>
                <div id="optionChainTable">
                    <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                        Loading option chain...
                    </div>
                </div>
            </div>

            <!-- Alert Stream -->
            <div class="glass-card">
                <div class="card-header">
                    <div class="card-title">
                        <i class="fas fa-stream"></i>
                        Alert Stream
                    </div>
                    <button class="btn btn-sm btn-secondary" onclick="generateTestAlert()" style="margin-left: auto; margin-right: 10px;">
                        <i class="fas fa-flask"></i> Test Alert
                    </button>
                    <span class="loading" id="alertLoader"></span>
                </div>

                <div class="alert-stream" id="alertStream">
                    <!-- Alerts will appear here dynamically -->
                    <!-- Use the Test Alert button below to simulate alerts -->
                </div>
            </div>
        </div>

        <!-- Position Configuration -->
        <div class="glass-card" style="margin-top: 20px;">
            <div class="card-header">
                <div class="card-title">
                    <i class="fas fa-cog"></i>
                    Position & Trade Configuration
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="btn btn-sm" onclick="saveTradeConfig()" style="background: var(--accent-green); padding: 6px 12px; font-size: 12px;">
                        <i class="fas fa-save"></i> Save Config
                    </button>
                    <button class="btn btn-sm" onclick="resetTradeConfig()" style="background: var(--accent-orange); padding: 6px 12px; font-size: 12px;">
                        <i class="fas fa-undo"></i> Reset to Defaults
                    </button>
                </div>
            </div>

            <div class="config-grid">
                <!-- Basic Settings -->
                <div class="config-section">
                    <div class="config-header">
                        <span class="config-title">Position Settings</span>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Number of Lots <span style="color: red;">*</span></label>
                        <select class="form-control" id="numLots" required>
                            <option value="1">1 lot</option>
                            <option value="5">5 lots</option>
                            <option value="10">10 lots</option>
                            <option value="15">15 lots</option>
                            <option value="20">20 lots</option>
                            <option value="25">25 lots</option>
                            <option value="30">30 lots</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Entry Timing</label>
                        <select class="form-control" id="entryTiming">
                            <option value="immediate">Immediate</option>
                            <option value="next_candle">Next Candle (11:15)</option>
                            <option value="custom">Custom Delay</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label" style="display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" id="amoEnabled" style="width: auto; margin: 0;">
                            <span>Enable AMO Orders</span>
                        </label>
                        <small style="color: var(--text-muted); display: block; margin-top: 5px; margin-left: 25px;">
                            Place After Market Orders when market is closed
                        </small>
                    </div>

                    <!-- Auto Trade Toggle -->
                    <div class="form-group">
                        <label class="form-label" style="display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" id="autoTradeToggle" style="width: auto; margin: 0;">
                            <span>Auto Trade Mode</span>
                        </label>
                        <small style="color: var(--text-muted); display: block; margin-top: 5px; margin-left: 25px;">
                            When enabled, trades execute automatically. When disabled, trades require manual approval.
                        </small>
                    </div>

                    <!-- Active Signals Selection -->
                    <div class="form-group">
                        <label class="form-label">Active Signals</label>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 10px;">
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;">
                                <input type="checkbox" class="signal-toggle" data-signal="S1" style="width: auto; margin: 0;">
                                <span>S1</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;">
                                <input type="checkbox" class="signal-toggle" data-signal="S2" style="width: auto; margin: 0;">
                                <span>S2</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;">
                                <input type="checkbox" class="signal-toggle" data-signal="S3" style="width: auto; margin: 0;">
                                <span>S3</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;">
                                <input type="checkbox" class="signal-toggle" data-signal="S4" style="width: auto; margin: 0;">
                                <span>S4</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;">
                                <input type="checkbox" class="signal-toggle" data-signal="S5" style="width: auto; margin: 0;">
                                <span>S5</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;">
                                <input type="checkbox" class="signal-toggle" data-signal="S6" style="width: auto; margin: 0;">
                                <span>S6</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;">
                                <input type="checkbox" class="signal-toggle" data-signal="S7" style="width: auto; margin: 0;">
                                <span>S7</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;">
                                <input type="checkbox" class="signal-toggle" data-signal="S8" style="width: auto; margin: 0;">
                                <span>S8</span>
                            </label>
                        </div>
                        <small style="color: var(--text-muted); display: block; margin-top: 5px;">
                            Select which signals to act on when received from TradingView
                        </small>
                    </div>
                </div>

                <!-- Expiry Selection -->
                <div class="config-section" style="grid-column: span 2;">
                    <div class="config-header">
                        <span class="config-title">ðŸ“… Expiry Selection Per Weekday</span>
                    </div>
                    <div style="padding: 10px; background: var(--bg-tertiary); border-radius: 8px; margin-bottom: 15px;">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 5px;">
                            ðŸ’¡ Configure which expiry to use when signals arrive on each day
                        </div>
                        <div style="font-size: 11px; color: var(--accent-yellow);">
                            NIFTY expires every Tuesday | Current week expiry only available on Monday & Tuesday
                        </div>
                    </div>
                    
                    <div id="expirySelectionContainer">
                        <!-- Monday -->
                        <div class="expiry-day-row" data-day="monday" style="display: flex; align-items: center; gap: 15px; padding: 12px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 8px;">
                            <div style="flex: 0 0 120px; font-weight: 600; font-size: 13px;">Monday</div>
                            <select id="expiryMonday" class="form-control" style="flex: 1;">
                                <option value="current">Current Week (This Tuesday)</option>
                                <option value="next">Next Week Tuesday</option>
                                <option value="month_end">Month End Tuesday</option>
                            </select>
                            <div id="mondayExpiryDate" style="flex: 0 0 150px; font-size: 11px; color: var(--text-secondary);"></div>
                        </div>
                        
                        <!-- Tuesday -->
                        <div class="expiry-day-row" data-day="tuesday" style="display: flex; align-items: center; gap: 15px; padding: 12px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 8px; border: 2px solid var(--accent-yellow);">
                            <div style="flex: 0 0 120px; font-weight: 600; font-size: 13px;">
                                Tuesday <span style="font-size: 10px; color: var(--accent-yellow);">ðŸ“…</span>
                            </div>
                            <select id="expiryTuesday" class="form-control" style="flex: 1;">
                                <option value="current">Current Week (Today)</option>
                                <option value="next">Next Week Tuesday</option>
                                <option value="month_end">Month End Tuesday</option>
                            </select>
                            <div id="tuesdayExpiryDate" style="flex: 0 0 150px; font-size: 11px; color: var(--text-secondary);"></div>
                        </div>
                        
                        <!-- Wednesday -->
                        <div class="expiry-day-row" data-day="wednesday" style="display: flex; align-items: center; gap: 15px; padding: 12px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 8px;">
                            <div style="flex: 0 0 120px; font-weight: 600; font-size: 13px;">Wednesday</div>
                            <select id="expiryWednesday" class="form-control" style="flex: 1;">
                                <option value="next">Next Week Tuesday</option>
                                <option value="month_end">Month End Tuesday</option>
                            </select>
                            <div id="wednesdayExpiryDate" style="flex: 0 0 150px; font-size: 11px; color: var(--text-secondary);"></div>
                        </div>
                        
                        <!-- Thursday -->
                        <div class="expiry-day-row" data-day="thursday" style="display: flex; align-items: center; gap: 15px; padding: 12px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 8px;">
                            <div style="flex: 0 0 120px; font-weight: 600; font-size: 13px;">Thursday</div>
                            <select id="expiryThursday" class="form-control" style="flex: 1;">
                                <option value="next">Next Week Tuesday</option>
                                <option value="month_end">Month End Tuesday</option>
                            </select>
                            <div id="thursdayExpiryDate" style="flex: 0 0 150px; font-size: 11px; color: var(--text-secondary);"></div>
                        </div>
                        
                        <!-- Friday -->
                        <div class="expiry-day-row" data-day="friday" style="display: flex; align-items: center; gap: 15px; padding: 12px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 8px;">
                            <div style="flex: 0 0 120px; font-weight: 600; font-size: 13px;">Friday</div>
                            <select id="expiryFriday" class="form-control" style="flex: 1;">
                                <option value="next">Next Week Tuesday</option>
                                <option value="month_end">Month End Tuesday</option>
                            </select>
                            <div id="fridayExpiryDate" style="flex: 0 0 150px; font-size: 11px; color: var(--text-secondary);"></div>
                        </div>
                        
                        <!-- Immediate Load Script for Weekday Expiry Settings -->
                        <script>
                            (function() {
                                console.log('[IMMEDIATE LOAD] Loading weekday expiry settings...');
                                const saved = localStorage.getItem('weekdayExpiryConfig');
                                if (saved) {
                                    try {
                                        const config = JSON.parse(saved);
                                        console.log('[IMMEDIATE LOAD] Found saved config:', config);
                                        
                                        const weekdays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
                                        weekdays.forEach(day => {
                                            const select = document.getElementById('expiry' + day.charAt(0).toUpperCase() + day.slice(1));
                                            if (select && config[day]) {
                                                console.log(`[IMMEDIATE LOAD] Setting ${day} to ${config[day]}`);
                                                select.value = config[day];
                                            }
                                        });
                                    } catch (e) {
                                        console.error('[IMMEDIATE LOAD] Error loading weekday config:', e);
                                    }
                                } else {
                                    console.log('[IMMEDIATE LOAD] No saved weekday config found');
                                }
                            })();
                        </script>
                        
                        <!-- Current Status -->
                        <div id="currentExpiryStatus" style="margin-top: 15px; padding: 12px; background: var(--bg-primary); border-radius: 6px; border-left: 3px solid var(--accent-blue);">
                            <div style="font-size: 12px; font-weight: 600; color: var(--text-primary); margin-bottom: 5px;">
                                Today's Configuration
                            </div>
                            <div id="todayExpiryInfo" style="font-size: 13px; color: var(--text-secondary);">
                                <!-- Will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Exit Timing Configuration -->
                <div class="config-section" style="grid-column: span 2;">
                    <div class="config-header">
                        <span class="config-title">â° Exit Timing Configuration</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="autoSquareOffEnabled" checked onchange="saveExitTiming(); document.getElementById('exitTimingConfig').style.display = this.checked ? 'flex' : 'none';">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div id="exitTimingConfig" style="display: flex; gap: 20px;">
                        <div style="flex: 1;">
                            <label class="form-label">Exit Day (T+N)</label>
                            <select class="form-control" id="exitDayOffset" onchange="updateExitPreview(); saveExitTiming();">
                                <option value="0">Expiry Day</option>
                                <option value="1">T+1 (Next trading day)</option>
                                <option value="2">T+2 (2 trading days)</option>
                                <option value="3">T+3 (3 trading days)</option>
                                <option value="4">T+4 (4 trading days)</option>
                                <option value="5">T+5 (5 trading days)</option>
                                <option value="6">T+6 (6 trading days)</option>
                                <option value="7">T+7 (7 trading days)</option>
                            </select>
                        </div>
                        <div style="flex: 1;">
                            <label class="form-label">Exit Time</label>
                            <select class="form-control" id="exitTime" onchange="updateExitPreview(); saveExitTiming();">
                                <option value="09:30">9:30 AM</option>
                                <option value="10:15">10:15 AM</option>
                                <option value="12:15">12:15 PM</option>
                                <option value="14:15">2:15 PM</option>
                                <option value="15:15">3:15 PM</option>
                            </select>
                        </div>
                    </div>
                    <div id="exitPreview" style="margin-top: 15px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; border-left: 3px solid var(--accent-blue);">
                        <!-- Exit preview will be shown here -->
                    </div>
                </div>

                <!-- Hedge Configuration -->
                <div class="config-section">
                    <div class="config-header">
                        <span class="config-title">Hedge Configuration</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="enableHedge" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="hedge-method selected" onclick="selectHedgeMethod('percentage')">
                        <label>
                            <input type="radio" name="hedgeMethod" value="percentage" checked>
                            <strong>Percentage Based</strong>
                            <div style="margin-top: 5px; font-size: 12px; color: var(--text-muted);">
                                Hedge at 30% of main leg price
                            </div>
                        </label>
                        <input type="number" class="form-control" style="margin-top: 10px;" value="30" id="hedgePercent">
                    </div>

                    <div class="hedge-method" onclick="selectHedgeMethod('fixed')">
                        <label>
                            <input type="radio" name="hedgeMethod" value="fixed">
                            <strong>Fixed Offset</strong>
                            <div style="margin-top: 5px; font-size: 12px; color: var(--text-muted);">
                                Fixed points from main strike
                            </div>
                        </label>
                        <input type="number" class="form-control" style="margin-top: 10px;" value="" id="hedgeOffset" placeholder="Enter hedge offset" disabled>
                    </div>

                    <div class="hedge-preview">
                        <div style="font-weight: 600; margin-bottom: 10px;">Hedge Preview</div>
                        <div class="hedge-calculation">
                            <span>Main Position:</span>
                            <span id="hedgePreviewMain">--</span>
                        </div>
                        <div class="hedge-calculation">
                            <span>Target Hedge Price:</span>
                            <span id="hedgePreviewTarget">-- (30%)</span>
                        </div>
                        <div class="hedge-calculation">
                            <span>Selected Hedge:</span>
                            <span id="hedgePreviewSelected">--</span>
                        </div>
                        <div class="hedge-calculation">
                            <span>Max Risk:</span>
                            <span id="hedgePreviewRisk">--</span>
                        </div>
                    </div>
                </div>

                <!-- Stop Loss Management -->
                <div class="config-section">
                    <div class="config-header">
                        <span class="config-title">Stop Loss Management</span>
                    </div>
                    
                    <!-- Mandatory Strike-Based Stop Loss -->
                    <div class="form-group" style="background: rgba(255, 107, 0, 0.1); padding: 10px; border-radius: 5px; border: 1px solid var(--accent-orange);">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="color: var(--accent-orange); font-size: 14px;">âš ï¸</span>
                            <strong style="color: var(--accent-orange);">MANDATORY DEFAULT</strong>
                        </div>
                        <div style="margin-top: 8px; font-size: 13px;">
                            <strong>Strike-Based Stop Loss (Always Active)</strong>
                            <ul style="margin: 8px 0 0 20px; font-size: 12px; color: var(--text-muted);">
                                <li>PUT: Exit if 1H candle closes BELOW strike price</li>
                                <li>CALL: Exit if 1H candle closes ABOVE strike price</li>
                                <li>No buffer - Exact strike price as trigger</li>
                            </ul>
                        </div>
                    </div>
                    
                    <!-- Profit Lock Configuration -->
                    <div style="margin-top: 15px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" id="profitLockEnabled">
                                <strong>Profit Lock</strong>
                            </label>
                        </div>
                        <div id="profitLockConfig" style="display: none; margin-left: 24px;">
                            <div class="form-group">
                                <label style="font-size: 12px;">Target Profit %</label>
                                <input type="number" id="profitTarget" value="10" min="1" max="50" style="width: 60px;">
                                <small style="color: var(--text-muted); margin-left: 8px;">Activate when profit reaches this %</small>
                            </div>
                            <div class="form-group">
                                <label style="font-size: 12px;">Lock Profit %</label>
                                <input type="number" id="profitLock" value="5" min="0" max="50" style="width: 60px;">
                                <small style="color: var(--text-muted); margin-left: 8px;">Exit if profit falls below this %</small>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Trailing Stop Configuration -->
                    <div style="margin-top: 10px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                        <div class="form-group" style="margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" id="trailingStopEnabled">
                                <strong>Trailing Stop</strong>
                            </label>
                        </div>
                        <div id="trailingStopConfig" style="display: none; margin-left: 24px;">
                            <div class="form-group">
                                <label style="font-size: 12px;">Trail %</label>
                                <input type="number" id="trailPercent" value="1" min="0.5" max="10" step="0.5" style="width: 60px;">
                                <small style="color: var(--text-muted); margin-left: 8px;">Exit if profit drops by this % from peak</small>
                            </div>
                            <div style="font-size: 11px; color: var(--accent-blue); margin-top: 5px;">
                                <i class="fas fa-info-circle"></i> Includes hedge in NET profit calculation
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Alert Notifications -->
                <div class="config-section">
                    <div class="config-header">
                        <span class="config-title">Alert Notifications</span>
                        <span id="alertStatus" style="padding: 2px 8px; border-radius: 4px; background: var(--bg-tertiary); color: var(--text-muted); font-size: 11px;">OFF</span>
                    </div>
                    
                    <!-- Telegram Configuration -->
                    <div style="margin: 15px 0;">
                        <label style="display: flex; align-items: center; margin-bottom: 10px;">
                            <input type="checkbox" id="telegramEnabled" style="margin-right: 8px;">
                            <span style="font-size: 13px;">Enable Telegram Alerts</span>
                        </label>
                        <div id="telegramConfig" style="display: none;">
                            <input type="text" id="telegramBotToken" placeholder="Bot Token" class="form-control" style="height: 32px; margin-bottom: 8px;" readonly>
                            <input type="text" id="telegramChatId" placeholder="Chat ID" class="form-control" style="height: 32px;" readonly>
                            <div style="background: rgba(76, 175, 80, 0.1); border-radius: 4px; padding: 8px; margin: 8px 0; border-left: 3px solid var(--accent-green);">
                                <div style="font-size: 12px; color: var(--accent-green); font-weight: 600;">âœ… Configured for Naveen</div>
                                <div style="font-size: 11px; color: var(--text-secondary);">Chat ID: Not configured | Bot: @Alphaone_alertbot</div>
                            </div>
                            <button class="btn btn-sm btn-secondary" onclick="testTelegram()" style="margin-top: 8px;">Test Telegram</button>
                        </div>
                    </div>

                    <!-- Email Configuration -->
                    <div style="margin: 15px 0;">
                        <label style="display: flex; align-items: center; margin-bottom: 10px;">
                            <input type="checkbox" id="emailEnabled" style="margin-right: 8px;">
                            <span style="font-size: 13px;">Enable Email Alerts</span>
                        </label>
                        <div id="emailConfig" style="display: none;">
                            <input type="email" id="emailFrom" placeholder="From Email" class="form-control" style="height: 32px; margin-bottom: 8px;">
                            <input type="password" id="emailPassword" placeholder="App Password" class="form-control" style="height: 32px; margin-bottom: 8px;">
                            <input type="email" id="emailTo" placeholder="To Email(s) - comma separated" class="form-control" style="height: 32px;">
                            <button class="btn btn-sm btn-secondary" onclick="testEmail()" style="margin-top: 8px;">Test Email</button>
                        </div>
                    </div>

                    <!-- Alert Types -->
                    <div style="margin: 15px 0;">
                        <h6 style="font-size: 13px; margin-bottom: 10px;">Alert Types</h6>
                        <label style="display: block; font-size: 12px; margin-bottom: 5px;">
                            <input type="checkbox" id="alertTradeEntry" checked> Trade Entry
                        </label>
                        <label style="display: block; font-size: 12px; margin-bottom: 5px;">
                            <input type="checkbox" id="alertTradeExit" checked> Trade Exit
                        </label>
                        <label style="display: block; font-size: 12px; margin-bottom: 5px;">
                            <input type="checkbox" id="alertStopLoss" checked> Stop Loss
                        </label>
                        <label style="display: block; font-size: 12px; margin-bottom: 5px;">
                            <input type="checkbox" id="alertRiskWarning" checked> Risk Warnings
                        </label>
                        <label style="display: block; font-size: 12px; margin-bottom: 5px;">
                            <input type="checkbox" id="alertDailySummary" checked> Daily Summary
                        </label>
                    </div>

                    <button class="btn btn-sm btn-primary" onclick="saveAlertConfig()" style="width: 100%;">Save Alert Settings</button>
                    
                    <!-- Recent Alerts -->
                    <div style="margin-top: 15px;">
                        <h6 style="font-size: 13px; margin-bottom: 10px;">Recent Alerts</h6>
                        <div id="recentAlerts" style="max-height: 150px; overflow-y: auto; font-size: 11px;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Paper Trading Dashboard Removed - Live Trading Only -->

        <!-- Breakeven Monitor -->
        <div class="glass-card" style="margin-top: 20px;">
            <div class="card-header">
                <div class="card-title">
                    <i class="fas fa-balance-scale"></i>
                    Live Breakeven Monitor
                </div>
                <span style="font-size: 12px; color: var(--text-muted);">Updates every 60 seconds</span>
            </div>

            <div class="breakeven-display">
                <div style="font-size: 14px; color: var(--text-muted);">Current Breakeven Point</div>
                <div class="breakeven-value">--</div>
                <div style="font-size: 13px; color: var(--text-secondary);">Net P&L: <span style="color: var(--text-muted);">â‚¹0</span></div>
            </div>

            <div class="position-legs" id="positionLegsDisplay">
                <!-- Position legs will be dynamically populated -->
                <div class="no-positions" style="text-align: center; padding: 20px; color: var(--text-muted);">
                    No active positions. Add a position to see live breakeven monitoring.
                </div>
            </div>
        </div>

        <!-- Stop Loss Status Display -->
        <div class="main-grid" style="margin-top: 20px;">
            <div class="glass-card">
                <div class="card-header">
                    <div class="card-title">
                        <i class="fas fa-shield-alt"></i>
                        Active Stop Loss Status
                    </div>
                </div>
                
                <!-- Strike-Based (Always Active) -->
                <div class="sl-level" style="border-left-color: var(--accent-orange);">
                    <div class="sl-level-header">
                        <span class="sl-level-title">Strike-Based (MANDATORY)</span>
                        <span class="badge" style="background: var(--accent-orange); padding: 2px 8px; border-radius: 4px; font-size: 10px;">ACTIVE</span>
                    </div>
                    <div style="font-size: 12px; margin: 5px 0; color: var(--text-muted);">
                        Monitoring hourly candle closes vs strike price
                    </div>
                </div>

                <!-- Profit Lock Status (Dynamic) -->
                <div class="sl-level" id="profitLockStatusDisplay" style="display: none; border-left-color: var(--accent-green);">
                    <div class="sl-level-header">
                        <span class="sl-level-title">Profit Lock</span>
                        <span class="badge" style="background: var(--accent-green); padding: 2px 8px; border-radius: 4px; font-size: 10px;">ACTIVE</span>
                    </div>
                    <div style="font-size: 12px; margin: 5px 0;">
                        Target: <span id="profitTargetShow">10</span>% | Lock: <span id="profitLockShow">5</span>%
                    </div>
                    <div class="sl-progress">
                        <div class="sl-progress-bar" id="profitProgress" style="width: 0%;"></div>
                    </div>
                </div>

                <!-- Trailing Stop Status (Dynamic) -->
                <div class="sl-level" id="trailingStopStatusDisplay" style="display: none; border-left-color: var(--accent-blue);">
                    <div class="sl-level-header">
                        <span class="sl-level-title">Trailing Stop</span>
                        <span class="badge" style="background: var(--accent-blue); padding: 2px 8px; border-radius: 4px; font-size: 10px;">ACTIVE</span>
                    </div>
                    <div style="font-size: 12px; margin: 5px 0;">
                        Trail: <span id="trailPercentShow">1</span>% from peak
                    </div>
                    <div style="font-size: 11px; color: var(--text-muted);">
                        Peak: â‚¹<span id="peakPnlShow">0</span> | Current: â‚¹<span id="currentPnlShow">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Live Positions -->
        <div class="glass-card" style="margin-top: 20px;">
            <div class="card-header">
                <div class="card-title">
                    <i class="fas fa-list"></i>
                    Live Positions
                </div>
                <button class="btn btn-danger btn-sm" onclick="squareOffAll()">
                    Square Off All
                </button>
            </div>

            <table class="positions-table">
                <thead>
                    <tr>
                        <th>Signal</th>
                        <th>Symbol</th>
                        <th>Type</th>
                        <th>Entry</th>
                        <th>Current</th>
                        <th>P&L</th>
                        <th>% Change</th>
                        <th>Time</th>
                        <th>SL</th>
                        <th>Target</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="positionsTableBody">
                    <!-- Positions will be dynamically populated here -->
                </tbody>
            </table>
        </div>

        <!-- NIFTY 1H Monitor -->
        <div class="glass-card" style="margin-top: 20px;">
            <div class="card-header">
                <div class="card-title">
                    <i class="fas fa-chart-bar"></i>
                    NIFTY 1H Candle Monitor
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 2px;">
                    <span id="candlePeriod" style="font-size: 11px; color: var(--accent-blue); font-weight: 600;">XX:15 - XX:15</span>
                    <span id="nextCandle" style="font-size: 12px; color: var(--text-muted);">Next close: 14:00:00</span>
                    <span id="candleDataAge" style="font-size: 10px; color: var(--accent-yellow);">Age: --</span>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                <div style="padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                    <div style="font-size: 12px; color: var(--text-muted);">Entry Strike</div>
                    <div id="candleEntryStrike" style="font-size: 20px; font-weight: 600; margin-top: 5px;">--</div>
                </div>
                <div style="padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                    <div style="font-size: 12px; color: var(--text-muted);">Current NIFTY</div>
                    <div id="candleCurrentNifty" style="font-size: 20px; font-weight: 600; margin-top: 5px;">--</div>
                    <div id="candleCurrentNiftyTime" style="font-size: 10px; color: var(--text-muted); margin-top: 3px;">Updated: --:--:--</div>
                    <div id="candleCurrentNiftyStatus" style="font-size: 9px; margin-top: 2px;">
                        <span id="dataSourceIndicator" style="padding: 2px 5px; border-radius: 3px; background: rgba(255,255,255,0.1);">--</span>
                    </div>
                </div>
                <div style="padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                    <div style="font-size: 12px; color: var(--text-muted);">Last 1H Close</div>
                    <div id="candleLastClose" style="font-size: 20px; font-weight: 600; margin-top: 5px;">--</div>
                    <div id="candleLastCloseTime" style="font-size: 10px; color: var(--text-muted); margin-top: 3px;">Updated: --:--:--</div>
                    <div id="candleLastCloseAge" style="font-size: 9px; color: var(--accent-yellow); margin-top: 2px;">Age: --</div>
                </div>
                <div style="padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                    <div style="font-size: 12px; color: var(--text-muted);">Distance to SL</div>
                    <div id="candleDistanceToSL" style="font-size: 20px; font-weight: 600; margin-top: 5px;">--</div>
                </div>
            </div>

            <div style="margin-top: 20px; padding: 15px; background: var(--bg-secondary); border-radius: 8px; border-left: 3px solid var(--accent-green);">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div id="candleStatusIndicator" style="font-size: 14px; font-weight: 600; color: var(--accent-green);">--</div>
                        <div id="candleStatusMessage" style="font-size: 12px; color: var(--text-muted); margin-top: 5px;">Checking...</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 12px; color: var(--text-muted);">Time to next candle</div>
                        <div id="candleTimeToNext" style="font-size: 16px; font-weight: 600;">--:--</div>
                    </div>
                </div>
            </div>

        </div>
        
        <!-- Market Data Status Panel -->
        <div class="glass-card" style="margin-top: 20px;">
            <div class="card-header">
                <div class="card-title">
                    <i class="fas fa-info-circle"></i>
                    Market Data Validation Status
                </div>
                <div id="overallDataStatus" style="font-size: 12px; padding: 4px 12px; border-radius: 20px; background: var(--accent-green); color: white; font-weight: 600;">
                    ALL SYSTEMS GO
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; padding: 15px;">
                <!-- NIFTY Spot Status -->
                <div class="data-status-card" style="padding: 12px; background: var(--bg-secondary); border-radius: 8px; border-left: 3px solid var(--accent-green);">
                    <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">NIFTY Spot</div>
                    <div style="font-size: 18px; font-weight: 600; margin: 5px 0;" id="statusSpotPrice">--</div>
                    <div style="font-size: 10px; color: var(--text-muted);">
                        <div>Last: <span id="statusSpotTime">--:--:--</span></div>
                        <div>Age: <span id="statusSpotAge" style="color: var(--accent-green);">--</span></div>
                        <div>Source: <span id="statusSpotSource">--</span></div>
                        <div style="margin-top: 3px;">
                            <span id="statusSpotValidation" style="padding: 2px 6px; border-radius: 10px; font-size: 9px; background: rgba(0,255,136,0.2); color: var(--accent-green);">âœ“ Can Trade</span>
                        </div>
                    </div>
                </div>
                
                <!-- 1H Candle Status -->
                <div class="data-status-card" style="padding: 12px; background: var(--bg-secondary); border-radius: 8px; border-left: 3px solid var(--accent-blue);">
                    <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">1H Candle</div>
                    <div style="font-size: 18px; font-weight: 600; margin: 5px 0;" id="status1HCandle">--</div>
                    <div style="font-size: 10px; color: var(--text-muted);">
                        <div>Period: <span id="status1HPeriod">XX:15 - XX:15</span></div>
                        <div>Closed: <span id="status1HTime">--:--:--</span></div>
                        <div>Age: <span id="status1HAge" style="color: var(--accent-blue);">--</span></div>
                        <div style="margin-top: 3px;">
                            <span id="status1HValidation" style="padding: 2px 6px; border-radius: 10px; font-size: 9px; background: rgba(0,212,255,0.2); color: var(--accent-blue);">âœ“ Valid</span>
                        </div>
                    </div>
                </div>
                
                <!-- 5M Candle Status -->
                <div class="data-status-card" style="padding: 12px; background: var(--bg-secondary); border-radius: 8px; border-left: 3px solid var(--accent-purple);">
                    <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">5M Candle</div>
                    <div style="font-size: 18px; font-weight: 600; margin: 5px 0;" id="status5MCandle">--</div>
                    <div style="font-size: 10px; color: var(--text-muted);">
                        <div>Period: <span id="status5MPeriod">XX:X0 - XX:X5</span></div>
                        <div>Closed: <span id="status5MTime">--:--:--</span></div>
                        <div>Age: <span id="status5MAge" style="color: var(--accent-purple);">--</span></div>
                        <div style="margin-top: 3px;">
                            <span id="status5MValidation" style="padding: 2px 6px; border-radius: 10px; font-size: 9px; background: rgba(153,69,255,0.2); color: var(--accent-purple);">âœ“ Fresh</span>
                        </div>
                    </div>
                </div>
                
                <!-- Option Chain Status -->
                <div class="data-status-card" style="padding: 12px; background: var(--bg-secondary); border-radius: 8px; border-left: 3px solid var(--accent-orange);">
                    <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">Option Chain</div>
                    <div style="font-size: 18px; font-weight: 600; margin: 5px 0;" id="statusOptionChain">--</div>
                    <div style="font-size: 10px; color: var(--text-muted);">
                        <div>Expiry: <span id="statusOptionExpiry">--</span></div>
                        <div>Updated: <span id="statusOptionTime">--:--:--</span></div>
                        <div>Age: <span id="statusOptionAge" style="color: var(--accent-orange);">--</span></div>
                        <div style="margin-top: 3px;">
                            <span id="statusOptionValidation" style="padding: 2px 6px; border-radius: 10px; font-size: 9px; background: rgba(255,149,0,0.2); color: var(--accent-orange);">âœ“ Current</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- System Status Summary -->
            <div style="padding: 15px; background: var(--bg-secondary); margin: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">System Check</div>
                    <div style="font-size: 14px; margin-top: 3px;">
                        Last Validation: <span id="lastValidationTime" style="font-weight: 600;">--:--:--</span>
                        | Next: <span id="nextValidationTime">--:--:--</span>
                    </div>
                </div>
                <div id="tradingPermission" style="padding: 8px 16px; border-radius: 20px; background: var(--gradient-green); color: white; font-weight: 600;">
                    TRADING ENABLED
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script>
        // Global variables
        let autoTradeEnabled = false;
        let currentMode = 'LIVE';
        let webhookConnected = false;
        let positions = [];
        let breakevenUpdateInterval;
        let hourCandleMonitor;
        
        // Helper function to get current expiry (next Tuesday)
        function getCurrentExpiry() {
            const today = new Date();
            const daysUntilTuesday = (2 - today.getDay() + 7) % 7 || 7;
            const nextTuesday = new Date(today);
            nextTuesday.setDate(today.getDate() + daysUntilTuesday);
            return nextTuesday.toISOString().split('T')[0];
        }
        
        // Helper function to get API base URL
        function getApiUrl(endpoint) {
            // Always use full URL to ensure API calls work
            const baseUrl = window.location.protocol === 'file:' 
                ? 'http://localhost:8000' 
                : window.location.origin;
            return baseUrl + endpoint;
        }
        
        // Robust fetch with retry logic
        async function fetchWithRetry(url, options = {}, maxRetries = 3, retryDelay = 1000) {
            let lastError;
            
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                    
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeout);
                    
                    if (!response.ok && response.status >= 500) {
                        throw new Error(`Server error: ${response.status}`);
                    }
                    
                    return response;
                } catch (error) {
                    lastError = error;
                    
                    if (error.name === 'AbortError') {
                        console.error(`Request timeout for ${url}`);
                    } else {
                        console.error(`Attempt ${i + 1} failed for ${url}:`, error);
                    }
                    
                    if (i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, retryDelay * (i + 1)));
                    }
                }
            }
            
            throw lastError || new Error(`Failed after ${maxRetries} attempts`);
        }
        
        // Error notification helper
        function showError(message, details = null) {
            console.error(message, details);
            showNotification(message, 'error');
            
            // Also update status indicators
            const apiStatus = document.getElementById('apiStatus');
            if (apiStatus) {
                apiStatus.querySelector('.status-dot').style.background = '#ff3366';
            }
        }
        
        // Simple direct save function for testing
        window.directSaveConfig = async function() {
            console.log('[DIRECT] Starting direct save...');
            
            const config = {
                num_lots: parseInt(document.getElementById('numLots').value) || 10,
                entry_timing: document.getElementById('entryTiming').value || 'immediate',
                exit_day_offset: parseInt(document.getElementById('exitDayOffset').value) || 0,
                exit_time: document.getElementById('exitTime').value || '15:15',
                weekday_config: {
                    monday: document.getElementById('expiryMonday').value || 'current',
                    tuesday: document.getElementById('expiryTuesday').value || 'current',
                    wednesday: document.getElementById('expiryWednesday').value || 'next',
                    thursday: document.getElementById('expiryThursday').value || 'next',
                    friday: document.getElementById('expiryFriday').value || 'next'
                }
            };
            
            try {
                // Use original fetch if available to bypass interceptor
                const fetchFn = window.originalFetch || fetch;
                const response = await fetchFn('http://localhost:8000/api/trade-config/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config: config,
                        config_name: 'default',
                        user_id: 'default'
                    })
                });
                
                const result = await response.json();
                console.log('[DIRECT] Save result:', result);
                
                if (result.success) {
                    alert('Configuration saved successfully!');
                } else {
                    alert('Save failed: ' + (result.message || 'Unknown error'));
                }
            } catch (error) {
                console.error('[DIRECT] Save error:', error);
                alert('Error saving: ' + error.message);
            }
        };
        
        // Trade Configuration Management Functions
        async function saveTradeConfig() {
            try {
                // Collect all configuration values
                const config = {
                    // Position Settings
                    num_lots: parseInt(document.getElementById('numLots').value) || null,  // Make it null if empty for validation
                    entry_timing: document.getElementById('entryTiming').value || 'immediate',
                    amo_enabled: document.getElementById('amoEnabled')?.checked || false,
                    
                    // Hedge Configuration
                    hedge_enabled: document.getElementById('enableHedge')?.checked || false,
                    hedge_method: document.querySelector('input[name="hedgeMethod"]:checked')?.value || 'percentage',
                    hedge_percent: parseFloat(document.getElementById('hedgePercent')?.value) || 30.0,
                    hedge_offset: parseInt(document.getElementById('hedgeOffset')?.value) || 200,
                    
                    // Stop Loss Settings
                    profit_lock_enabled: document.getElementById('profitLockEnabled')?.checked || false,
                    profit_target: parseFloat(document.getElementById('profitTarget')?.value) || 10.0,
                    profit_lock: parseFloat(document.getElementById('profitLock')?.value) || 5.0,
                    trailing_stop_enabled: document.getElementById('trailingStopEnabled')?.checked || false,
                    trail_percent: parseFloat(document.getElementById('trailPercent')?.value) || 1.0,
                    
                    // Auto Trading Settings (if applicable)
                    auto_trade_enabled: document.getElementById('autoTradeToggle')?.checked || false,
                    active_signals: Array.from(document.querySelectorAll('.signal-toggle:checked')).map(cb => cb.getAttribute('data-signal') || cb.value).filter(v => v && v !== 'on'),

                    // Telegram Alert Settings
                    telegram_enabled: document.getElementById('telegramEnabled')?.checked || false,
                    telegram_bot_token: document.getElementById('telegramBotToken')?.value || '',
                    telegram_chat_id: document.getElementById('telegramChatId')?.value || '',

                    // Email Alert Settings
                    email_enabled: document.getElementById('emailEnabled')?.checked || false,
                    email_from: document.getElementById('emailFrom')?.value || '',
                    email_to: document.getElementById('emailTo')?.value || '',

                    // Alert Types
                    alert_trade_entry: document.querySelector('input[value="trade_entry"]')?.checked ?? true,
                    alert_trade_exit: document.querySelector('input[value="trade_exit"]')?.checked ?? true,
                    alert_stop_loss: document.querySelector('input[value="stop_loss"]')?.checked ?? true,
                    alert_risk_warnings: document.querySelector('input[value="risk_warnings"]')?.checked ?? true,
                    alert_daily_summary: document.querySelector('input[value="daily_summary"]')?.checked ?? false,

                    // Expiry and Exit Timing Settings
                    exit_day_offset: parseInt(document.getElementById('exitDayOffset')?.value ?? 0),
                    exit_time: document.getElementById('exitTime')?.value || '15:15',
                    auto_square_off_enabled: document.getElementById('autoSquareOffEnabled')?.checked || true,
                    
                    // Weekday Expiry Configuration
                    weekday_config: {
                        monday: document.getElementById('expiryMonday')?.value || 'current',
                        tuesday: document.getElementById('expiryTuesday')?.value || 'current',
                        wednesday: document.getElementById('expiryWednesday')?.value || 'next',
                        thursday: document.getElementById('expiryThursday')?.value || 'next',
                        friday: document.getElementById('expiryFriday')?.value || 'next'
                    }
                };
                
                // Check mandatory fields client-side
                const errors = [];
                if (!config.num_lots || config.num_lots < 1) {
                    errors.push('Number of lots is required (minimum 1)');
                }
                
                if (errors.length > 0) {
                    showNotification('Please fill mandatory fields:\n' + errors.join('\n'), 'error');
                    
                    // Highlight missing fields
                    if (!config.num_lots) document.getElementById('numLots').style.borderColor = 'red';
                    
                    return;
                }
                
                // Save to backend - using direct fetch to avoid circuit breaker
                const apiUrl = getApiUrl('/api/trade-config/save');
                console.log('[CONFIG] Saving to API URL:', apiUrl);
                console.log('[CONFIG] Payload:', JSON.stringify({
                    config: config,
                    config_name: 'default',
                    user_id: 'default'
                }));
                
                // Add throwOnError: false to bypass error handler interceptor
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config: config,
                        config_name: 'default',
                        user_id: 'default'
                    }),
                    throwOnError: false  // This bypasses the error handler
                });
                
                let result;
                try {
                    result = await response.json();
                } catch (e) {
                    console.error('[CONFIG] Failed to parse response:', e);
                    result = { success: false, message: 'Invalid response from server' };
                }
                
                console.log('[CONFIG] Save response:', result);
                
                if (result && result.success) {
                    // Also save to localStorage for offline access
                    localStorage.setItem('tradeConfig', JSON.stringify(config));
                    localStorage.setItem('tradeConfigTimestamp', new Date().toISOString());
                    
                    // Also save AMO setting to /settings endpoint for backend integration
                    if (config.amo_enabled !== undefined) {
                        fetch(getApiUrl('/settings'), {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ amo_enabled: config.amo_enabled ? 'true' : 'false' })
                        }).catch(err => console.log('[CONFIG] AMO setting save:', err));
                    }
                    
                    showNotification('Configuration saved successfully', 'success');
                    console.log('[CONFIG] Saved configuration:', config);
                } else {
                    showNotification('Failed to save configuration: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('[CONFIG] Error saving configuration:', error);
                console.error('[CONFIG] Error details:', error.message, error.stack);
                
                // Fallback to localStorage only
                const config = collectTradeConfig();
                localStorage.setItem('tradeConfig', JSON.stringify(config));
                localStorage.setItem('tradeConfigTimestamp', new Date().toISOString());
                
                // More informative error message
                if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
                    showNotification('Cannot connect to API. Configuration saved locally only.', 'warning');
                } else if (error.message.includes('CORS')) {
                    showNotification('CORS error - check API settings. Saved locally.', 'warning');
                } else {
                    showNotification(`Configuration saved locally (Error: ${error.message})`, 'warning');
                }
            }
        }
        
        function updateWeekdayExpiryDates() {
            // Update the date displays for each weekday based on selected expiry
            const weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
            const today = new Date();
            
            weekdays.forEach(day => {
                const select = document.getElementById(`expiry${day}`);
                const dateDisplay = document.getElementById(`${day.toLowerCase()}ExpiryDate`);
                
                if (select && dateDisplay) {
                    const selectedValue = select.value;
                    let expiryDate = '';
                    
                    // Calculate expiry date based on selection
                    // This is a placeholder - actual logic would calculate based on current date
                    switch(selectedValue) {
                        case 'current':
                            expiryDate = 'This Tuesday';
                            break;
                        case 'next':
                            expiryDate = 'Next Tuesday';
                            break;
                        case 'month_end':
                            expiryDate = 'Month End Tuesday';
                            break;
                    }
                    
                    dateDisplay.textContent = expiryDate;
                }
            });
        }
        
        async function loadTradeConfig() {
            try {
                console.log('[CONFIG] Loading configuration from server...');
                // Try to load from backend first
                const response = await fetch(getApiUrl('/api/trade-config/load/default?user_id=default'));
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('[CONFIG] Server response:', result);
                    
                    if (result.success && result.config) {
                        console.log('[CONFIG] Applying configuration:', result.config);
                        applyTradeConfig(result.config);
                        
                        // Update localStorage cache
                        localStorage.setItem('tradeConfig', JSON.stringify(result.config));
                        localStorage.setItem('tradeConfigTimestamp', new Date().toISOString());
                        
                        // Show visual feedback that configuration is loaded from database
                        const lotsDisplay = document.getElementById('numLots');
                        if (lotsDisplay) {
                            const currentValue = lotsDisplay.value;
                            console.log(`[CONFIG] âœ… Database configuration loaded - Lots: ${currentValue}`);
                            // Add visual indicator that config is from database
                            lotsDisplay.style.borderColor = '#4CAF50';
                            setTimeout(() => {
                                lotsDisplay.style.borderColor = '';
                            }, 2000);
                        }
                        
                        console.log('[CONFIG] Configuration loaded and applied successfully from database');
                        return;
                    } else {
                        console.log('[CONFIG] No configuration found on server');
                    }
                } else {
                    console.error('[CONFIG] Server returned error:', response.status);
                }
            } catch (error) {
                console.error('[CONFIG] Error loading from backend:', error);
            }
            
            // Fallback to localStorage
            console.log('[CONFIG] Attempting to load from localStorage...');
            const localConfig = localStorage.getItem('tradeConfig');
            if (localConfig) {
                try {
                    const config = JSON.parse(localConfig);
                    console.log('[CONFIG] Found local config:', config);
                    applyTradeConfig(config);
                    console.log('[CONFIG] Configuration loaded from local storage');
                } catch (e) {
                    console.error('[CONFIG] Error parsing local config:', e);
                }
            } else {
                console.log('[CONFIG] No saved configuration found in localStorage');
            }
        }
        
        function resetTradeConfig() {
            if (confirm('Reset all settings to default values?')) {
                const defaultConfig = {
                    num_lots: 5,
                    entry_timing: 'immediate',
                    hedge_enabled: true,
                    hedge_method: 'percentage',
                    hedge_percent: 30.0,
                    hedge_offset: 200,
                    profit_lock_enabled: false,
                    profit_target: 10.0,
                    profit_lock: 5.0,
                    trailing_stop_enabled: false,
                    trail_percent: 1.0,
                    auto_trade_enabled: false,
                    active_signals: [],
                    // Telegram settings for Naveen
                    telegram_enabled: true,
                    telegram_bot_token: '8268902303:AAFy8t0gARt0iWGech3mlIfrOZ9S4Jrt3WM',
                    telegram_chat_id: '992005734',
                    email_enabled: false,
                    email_from: '',
                    email_to: '',
                    alert_trade_entry: true,
                    alert_trade_exit: true,
                    alert_stop_loss: true,
                    alert_risk_warnings: true,
                    alert_daily_summary: false,
                    exit_day_offset: 0,
                    exit_time: '15:15',
                    auto_square_off_enabled: true,
                    weekday_config: {
                        monday: 'current',
                        tuesday: 'current',
                        wednesday: 'next',
                        thursday: 'next',
                        friday: 'next'
                    }
                };
                
                applyTradeConfig(defaultConfig);
                showNotification('Configuration reset to defaults', 'info');
            }
        }
        
        function collectTradeConfig() {
            return {
                num_lots: parseInt(document.getElementById('numLots').value) || 10,
                entry_timing: document.getElementById('entryTiming').value || 'immediate',
                amo_enabled: document.getElementById('amoEnabled')?.checked || false,
                hedge_enabled: document.getElementById('enableHedge')?.checked || false,
                hedge_method: document.querySelector('input[name="hedgeMethod"]:checked')?.value || 'percentage',
                hedge_percent: parseFloat(document.getElementById('hedgePercent')?.value) || 30.0,
                hedge_offset: parseInt(document.getElementById('hedgeOffset')?.value) || 200,
                profit_lock_enabled: document.getElementById('profitLockEnabled')?.checked || false,
                profit_target: parseFloat(document.getElementById('profitTarget')?.value) || 10.0,
                profit_lock: parseFloat(document.getElementById('profitLock')?.value) || 5.0,
                trailing_stop_enabled: document.getElementById('trailingStopEnabled')?.checked || false,
                trail_percent: parseFloat(document.getElementById('trailPercent')?.value) || 1.0,
                auto_trade_enabled: document.getElementById('autoTradeToggle')?.checked || false,
                active_signals: Array.from(document.querySelectorAll('.signal-toggle:checked')).map(cb => cb.getAttribute('data-signal') || cb.value).filter(v => v && v !== 'on'),
                // Telegram settings
                telegram_enabled: document.getElementById('telegramEnabled')?.checked || false,
                telegram_bot_token: document.getElementById('telegramBotToken')?.value || '',
                telegram_chat_id: document.getElementById('telegramChatId')?.value || '',
                // Email settings
                email_enabled: document.getElementById('emailEnabled')?.checked || false,
                email_from: document.getElementById('emailFrom')?.value || '',
                email_to: document.getElementById('emailTo')?.value || '',
                // Alert types
                alert_trade_entry: document.querySelector('input[value="trade_entry"]')?.checked ?? true,
                alert_trade_exit: document.querySelector('input[value="trade_exit"]')?.checked ?? true,
                alert_stop_loss: document.querySelector('input[value="stop_loss"]')?.checked ?? true,
                alert_risk_warnings: document.querySelector('input[value="risk_warnings"]')?.checked ?? true,
                alert_daily_summary: document.querySelector('input[value="daily_summary"]')?.checked ?? false,
                // Add expiry and exit timing
                exit_day_offset: parseInt(document.getElementById('exitDayOffset')?.value) || 0,
                exit_time: document.getElementById('exitTime')?.value || '15:15',
                auto_square_off_enabled: document.getElementById('autoSquareOffEnabled')?.checked || true,
                // Add weekday configuration
                weekday_config: {
                    monday: document.getElementById('expiryMonday')?.value || 'current',
                    tuesday: document.getElementById('expiryTuesday')?.value || 'current',
                    wednesday: document.getElementById('expiryWednesday')?.value || 'next',
                    thursday: document.getElementById('expiryThursday')?.value || 'next',
                    friday: document.getElementById('expiryFriday')?.value || 'next'
                }
            };
        }
        
        function applyTradeConfig(config) {
            console.log('[CONFIG] Applying config to UI:', config);
            
            // Apply Position Settings
            if (document.getElementById('numLots')) {
                document.getElementById('numLots').value = config.num_lots || 5;
                console.log('[CONFIG] Set numLots to:', config.num_lots || 5);
            }
            if (document.getElementById('entryTiming')) {
                document.getElementById('entryTiming').value = config.entry_timing || 'immediate';
                console.log('[CONFIG] Set entryTiming to:', config.entry_timing || 'immediate');
            }
            if (document.getElementById('amoEnabled')) {
                document.getElementById('amoEnabled').checked = config.amo_enabled || false;
                console.log('[CONFIG] Set amoEnabled to:', config.amo_enabled || false);
            }
            
            // Apply Hedge Configuration
            if (document.getElementById('enableHedge')) {
                document.getElementById('enableHedge').checked = config.hedge_enabled !== false;
                console.log('[CONFIG] Set enableHedge to:', config.hedge_enabled !== false);
            }
            
            // Set hedge method radio button
            const hedgeMethodRadio = document.querySelector(`input[name="hedgeMethod"][value="${config.hedge_method || 'percentage'}"]`);
            if (hedgeMethodRadio) {
                hedgeMethodRadio.checked = true;
                // Call selectHedgeMethod without event, it will find the element itself
                selectHedgeMethod(config.hedge_method || 'percentage', null);
                console.log('[CONFIG] Set hedge method to:', config.hedge_method || 'percentage');
            }
            
            if (document.getElementById('hedgePercent')) {
                document.getElementById('hedgePercent').value = config.hedge_percent || 30.0;
                console.log('[CONFIG] Set hedgePercent to:', config.hedge_percent || 30.0);
            }
            if (document.getElementById('hedgeOffset')) {
                document.getElementById('hedgeOffset').value = config.hedge_offset || 200;
                console.log('[CONFIG] Set hedgeOffset to:', config.hedge_offset || 200);
            }
            
            // Apply Stop Loss Settings
            if (document.getElementById('profitLockEnabled')) {
                document.getElementById('profitLockEnabled').checked = config.profit_lock_enabled || false;
                console.log('[CONFIG] Set profitLockEnabled to:', config.profit_lock_enabled || false);
                // Trigger change event to show/hide config
                document.getElementById('profitLockEnabled').dispatchEvent(new Event('change'));
            }
            if (document.getElementById('profitTarget')) {
                document.getElementById('profitTarget').value = config.profit_target || 10.0;
                console.log('[CONFIG] Set profitTarget to:', config.profit_target || 10.0);
            }
            if (document.getElementById('profitLock')) {
                document.getElementById('profitLock').value = config.profit_lock || 5.0;
                console.log('[CONFIG] Set profitLock to:', config.profit_lock || 5.0);
            }
            if (document.getElementById('trailingStopEnabled')) {
                document.getElementById('trailingStopEnabled').checked = config.trailing_stop_enabled || false;
                console.log('[CONFIG] Set trailingStopEnabled to:', config.trailing_stop_enabled || false);
                // Trigger change event to show/hide config
                document.getElementById('trailingStopEnabled').dispatchEvent(new Event('change'));
            }
            if (document.getElementById('trailPercent')) {
                document.getElementById('trailPercent').value = config.trail_percent || 1.0;
                console.log('[CONFIG] Set trailPercent to:', config.trail_percent || 1.0);
            }
            
            
            // Apply Auto Trade Settings
            if (document.getElementById('autoTradeToggle')) {
                document.getElementById('autoTradeToggle').checked = config.auto_trade_enabled || false;
                console.log('[CONFIG] Set autoTradeToggle to:', config.auto_trade_enabled || false);
                // Update the UI display for auto trade mode
                updateTradingModeDisplay(config.auto_trade_enabled || false);
            }
            
            // Apply Active Signals
            if (config.active_signals && Array.isArray(config.active_signals)) {
                console.log('[CONFIG] Applying active signals:', config.active_signals);
                // First uncheck all signals
                document.querySelectorAll('.signal-toggle').forEach(cb => cb.checked = false);
                // Then check the saved signals
                config.active_signals.forEach(signal => {
                    // Try multiple selectors to find the checkbox
                    let checkbox = document.querySelector(`.signal-toggle[data-signal="${signal}"]`);
                    if (!checkbox) checkbox = document.querySelector(`.signal-toggle[value="${signal}"]`);
                    if (!checkbox) checkbox = document.querySelector(`#signal${signal}Toggle`);
                    if (checkbox) {
                        checkbox.checked = true;
                        console.log('[CONFIG] Enabled signal:', signal);
                    }
                });
            }
            
            // Apply Telegram Alert Settings
            if (document.getElementById('telegramEnabled')) {
                document.getElementById('telegramEnabled').checked = config.telegram_enabled || false;
                console.log('[CONFIG] Set telegramEnabled to:', config.telegram_enabled || false);
                // Trigger change event to show/hide config
                document.getElementById('telegramEnabled').dispatchEvent(new Event('change'));
            }
            if (document.getElementById('telegramBotToken')) {
                document.getElementById('telegramBotToken').value = config.telegram_bot_token || '';
                console.log('[CONFIG] Set telegramBotToken');
            }
            if (document.getElementById('telegramChatId')) {
                document.getElementById('telegramChatId').value = config.telegram_chat_id || '';
                console.log('[CONFIG] Set telegramChatId');
            }

            // Apply Email Alert Settings
            if (document.getElementById('emailEnabled')) {
                document.getElementById('emailEnabled').checked = config.email_enabled || false;
                console.log('[CONFIG] Set emailEnabled to:', config.email_enabled || false);
                // Trigger change event to show/hide config
                document.getElementById('emailEnabled').dispatchEvent(new Event('change'));
            }
            if (document.getElementById('emailFrom')) {
                document.getElementById('emailFrom').value = config.email_from || '';
            }
            if (document.getElementById('emailTo')) {
                document.getElementById('emailTo').value = config.email_to || '';
            }

            // Apply Alert Types
            const alertTypes = {
                'trade_entry': config.alert_trade_entry ?? true,
                'trade_exit': config.alert_trade_exit ?? true,
                'stop_loss': config.alert_stop_loss ?? true,
                'risk_warnings': config.alert_risk_warnings ?? true,
                'daily_summary': config.alert_daily_summary ?? false
            };

            Object.entries(alertTypes).forEach(([type, enabled]) => {
                const checkbox = document.querySelector(`input[value="${type}"]`);
                if (checkbox) {
                    checkbox.checked = enabled;
                    console.log(`[CONFIG] Set alert type ${type} to:`, enabled);
                }
            });

            // Expiry selection handled by weekday_config

            // Apply Exit Timing Settings from server config (server is source of truth)
            if (config.exit_day_offset !== undefined || config.exit_time || config.auto_square_off_enabled !== undefined) {
                // Apply from server config
                if (document.getElementById('exitDayOffset')) {
                    document.getElementById('exitDayOffset').value = config.exit_day_offset !== undefined ? config.exit_day_offset : 0;
                    console.log('[CONFIG] Set exitDayOffset to:', config.exit_day_offset);
                }
                if (document.getElementById('exitTime')) {
                    document.getElementById('exitTime').value = config.exit_time || '15:15';
                    console.log('[CONFIG] Set exitTime to:', config.exit_time || '15:15');
                }
                if (document.getElementById('autoSquareOffEnabled')) {
                    document.getElementById('autoSquareOffEnabled').checked = config.auto_square_off_enabled !== false;
                    console.log('[CONFIG] Set autoSquareOffEnabled to:', config.auto_square_off_enabled !== false);
                    // Show/hide config without triggering save
                    const exitTimingConfigDiv = document.getElementById('exitTimingConfig');
                    if (exitTimingConfigDiv) {
                        exitTimingConfigDiv.style.display = config.auto_square_off_enabled !== false ? 'flex' : 'none';
                    }
                }
            }
            
            // Apply weekday configuration from server
            if (config.weekday_config) {
                console.log('[CONFIG] Applying weekday configuration:', config.weekday_config);
                const weekdays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
                weekdays.forEach(day => {
                    const elementId = 'expiry' + day.charAt(0).toUpperCase() + day.slice(1);
                    const element = document.getElementById(elementId);
                    if (element && config.weekday_config[day]) {
                        element.value = config.weekday_config[day];
                        console.log(`[CONFIG] Set ${elementId} to:`, config.weekday_config[day]);
                    } else if (!element) {
                        console.warn(`[CONFIG] Element ${elementId} not found`);
                    }
                });
                // Update the preview after loading
                updateWeekdayExpiryDates();
            }
            
            // Update exit preview after loading settings
            if (typeof updateExitPreview === 'function') {
                updateExitPreview();
            }
        }
        
        // Auto-load configuration on page load
        // Single load on DOMContentLoaded
        window.addEventListener('DOMContentLoaded', () => {
            console.log('[CONFIG] DOM loaded, loading trade configuration...');
            // Add a small delay to ensure all elements are ready
            setTimeout(() => {
                loadTradeConfig();
            }, 500);
        });
        
        // Auto-save configuration on changes (debounced)
        let saveTimeout;
        function autoSaveConfig() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                const config = collectTradeConfig();
                localStorage.setItem('tradeConfig', JSON.stringify(config));
                console.log('[CONFIG] Auto-saved to localStorage');
            }, 2000);
        }
        
        // Function to attach auto-save listeners
        function attachAutoSaveListeners() {
            console.log('[CONFIG] Attaching auto-save listeners...');
            
            // Position settings
            ['numLots', 'entryTiming', 'amoEnabled', 'enableHedge', 'hedgePercent', 'hedgeOffset',
             'profitLockEnabled', 'profitTarget', 'profitLock', 
             'trailingStopEnabled', 'trailPercent'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('change', autoSaveConfig);
                    console.log(`[CONFIG] Attached listener to ${id}`);
                }
            });
            
            // Hedge method radio buttons
            document.querySelectorAll('input[name="hedgeMethod"]').forEach(radio => {
                radio.addEventListener('change', autoSaveConfig);
            });
            
            // Signal toggles
            document.querySelectorAll('.signal-toggle').forEach(cb => {
                cb.addEventListener('change', autoSaveConfig);
            });
            
            console.log('[CONFIG] Auto-save listeners attached');
        }
        
        // Ensure listeners are attached after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', attachAutoSaveListeners);
        } else {
            // DOM already loaded
            attachAutoSaveListeners();
        }
        
        // Show notification - make it global
        window.showNotification = function(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                background: ${type === 'error' ? '#ff4444' : type === 'success' ? '#00c851' : '#33b5e5'};
                color: white;
                border-radius: 5px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                z-index: 10000;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 5000);
        }

        // Toggle individual signal on/off
        window.toggleSignal = function(signalId) {
            const toggle = document.getElementById(`toggle${signalId}`);
            const card = document.getElementById(`signal${signalId}`);
            
            if (toggle && card) {
                if (toggle.checked) {
                    card.classList.add('active');
                    card.style.opacity = '1';
                    card.style.borderColor = 'var(--accent-green)';
                    card.style.background = 'rgba(34, 197, 94, 0.05)';
                    showNotification(`Signal ${signalId} ENABLED - Will process incoming alerts`, 'success');
                } else {
                    card.classList.remove('active');
                    card.style.opacity = '0.4';
                    card.style.borderColor = 'var(--accent-red)';
                    card.style.background = 'rgba(239, 68, 68, 0.03)';
                    showNotification(`Signal ${signalId} DISABLED - Will ignore incoming alerts`, 'warning');
                }
                
                // Update active count
                const activeCount = document.querySelectorAll('.signal-card.active').length;
                document.getElementById('activeSignals').textContent = activeCount;
                
                // Update master toggle state
                // Master toggle should be:
                // - Checked if ALL signals are active (8 of 8)
                // - Indeterminate if SOME signals are active (1-7 of 8)
                // - Unchecked if NO signals are active (0 of 8)
                const masterToggle = document.getElementById('masterSignalToggle');
                if (masterToggle) {
                    if (activeCount === 8) {
                        masterToggle.checked = true;
                        masterToggle.indeterminate = false;
                    } else if (activeCount === 0) {
                        masterToggle.checked = false;
                        masterToggle.indeterminate = false;
                    } else {
                        masterToggle.checked = false;
                        masterToggle.indeterminate = true;
                    }
                }
                
                // Save preference
                localStorage.setItem(`signal${signalId}Active`, toggle.checked);
                
                console.log(`Signal ${signalId} is now ${toggle.checked ? 'ENABLED' : 'DISABLED'}`);
            }
        }
        
        // Check if a signal is enabled
        window.isSignalEnabled = function(signalId) {
            const toggle = document.getElementById(`toggle${signalId}`);
            return toggle ? toggle.checked : false;
        }
        
        // Toggle all signals on/off with master switch
        window.toggleAllSignals = function(checkbox) {
            const signalCards = document.querySelectorAll('.signal-card');
            const isChecked = checkbox.checked;
            
            // Clear indeterminate state when user clicks
            checkbox.indeterminate = false;
            
            signalCards.forEach(card => {
                const signalId = card.dataset.signal;
                const toggle = document.getElementById(`toggle${signalId}`);
                
                if (toggle && toggle.checked !== isChecked) {
                    toggle.checked = isChecked;
                    // Trigger the individual toggle function to update styling
                    toggleSignal(signalId);
                }
            });
            
            // No need for additional notification as toggleSignal() already shows them
        }
        
        // Load saved signal states from localStorage
        function loadSavedSignalStates() {
            console.log('[SIGNALS] Loading saved signal states from localStorage...');
            let enabledCount = 0;
            
            for (let i = 1; i <= 8; i++) {
                const signalId = `S${i}`;
                const savedState = localStorage.getItem(`signal${signalId}Active`);
                const toggle = document.getElementById(`toggle${signalId}`);
                const card = document.getElementById(`signal${signalId}`);
                
                if (toggle && card) {
                    // Default to enabled if no saved state
                    const isEnabled = savedState === null ? true : savedState === 'true';
                    toggle.checked = isEnabled;
                    
                    // Apply visual state
                    if (isEnabled) {
                        card.classList.add('active');
                        card.style.opacity = '1';
                        card.style.borderColor = 'var(--accent-green)';
                        card.style.background = 'rgba(34, 197, 94, 0.05)';
                        enabledCount++;
                    } else {
                        card.classList.remove('active');
                        card.style.opacity = '0.4';
                        card.style.borderColor = 'var(--accent-red)';
                        card.style.background = 'rgba(239, 68, 68, 0.03)';
                    }
                    
                    console.log(`[SIGNALS] ${signalId}: ${isEnabled ? 'ENABLED' : 'DISABLED'} (from localStorage)`);
                }
            }
            
            // Update active count display
            document.getElementById('activeSignals').textContent = enabledCount;
            
            // Update master toggle
            const masterToggle = document.getElementById('masterSignalToggle');
            if (masterToggle) {
                masterToggle.checked = enabledCount === 8;
            }
            
            console.log(`[SIGNALS] Loaded states: ${enabledCount}/8 signals enabled`);
        }
        
        // Initialize signal card toggle functionality
        function initializeSignalToggles() {
            // Remove click event on cards - only checkbox should toggle
            // This prevents duplicate toggle mechanisms
            const signalCards = document.querySelectorAll('.signal-card');
            
            // Just add hover effect, no click handler
            signalCards.forEach(card => {
                card.style.transition = 'all 0.2s ease';
            });
        }
        
        // Initialize on page load
        window.onload = function() {
            document.getElementById('webhookUrl').textContent = window.location.origin + '/webhook/tradingview';
            console.log('[INIT] Page loading...');
            
            // Load saved mode - default to LIVE since paper trading is removed
            const savedMode = localStorage.getItem('tradingMode') || 'LIVE';
            console.log(`[INIT] Restored mode from localStorage: ${savedMode}`);
            
            // Set the initial mode without showing notification (it's not a mode change)
            window.currentTradingMode = savedMode;
            
            // Just update the UI without calling setTradingMode which shows notification
            if (document.readyState !== 'loading') {
                updateModeUI(savedMode);
            }
            
            // Don't call loadTradeConfig here as it's already called in DOMContentLoaded
            
            // Set initial mode button state
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(savedMode)) {
                    btn.classList.add('active');
                }
            });
            
            window.initializeWebSocket();
            
            // Initialize Breeze WebSocket for live NIFTY streaming
            window.initializeBreezeWebSocket();
            
            // Hide the alert loader after initialization (fallback if WebSocket doesn't connect)
            setTimeout(() => {
                const alertLoader = document.getElementById('alertLoader');
                if (alertLoader && alertLoader.style.display !== 'none') {
                    alertLoader.style.display = 'none';
                    console.log('[INIT] Alert loader hidden (timeout fallback)');
                }
            }, 3000);  // Hide after 3 seconds regardless of connection status
            
            // Initialize Live Positions WebSocket for real-time position updates
            window.initializeLivePositionsWebSocket();
            
            // Load all live data - Add small delay to ensure functions are defined
            setTimeout(() => {
                console.log('[INIT] Starting live data loading after delay...');
                console.log('[INIT] loadLiveSpotPrice exists?', typeof window.loadLiveSpotPrice);
                
                window.loadLivePositions();
                // Load spot price immediately
                console.log('[INIT] Calling loadLiveSpotPrice...');
                if (window.loadLiveSpotPrice) {
                    window.loadLiveSpotPrice();
                } else {
                    console.error('[INIT] loadLiveSpotPrice is not defined!');
                }
                loadLatestCandles();
            }, 100);
            
            // Add another delayed call to ensure spot price loads
            setTimeout(() => {
                console.log('[INIT] Force loading spot price after 2 seconds...');
                if (window.loadLiveSpotPrice) {
                    window.loadLiveSpotPrice();
                }
            }, 2000);
            
            updateHeaderStats(); // Live trading stats only
            updateWebhookStatus(); // Check TradingView webhook status
            updateSignalStats();
            // Paper trading removed - Live only
            updateHedgeExample();
            
            // Load pending alerts on startup with delay to ensure DOM is ready
            console.log('[INIT] Scheduling pending alerts load...');
            setTimeout(() => {
                console.log('[INIT] Loading pending alerts now...');
                loadPendingAlerts();
            }, 2000);
            
            // Start monitoring
            startBreakevenMonitoring();
            start1HourCandleMonitor();
            updateNextCandleTime();
            
            // Force an immediate update of candle monitor
            console.log('[INIT] Forcing immediate candle monitor update...');
            setTimeout(() => {
                update1HCandleMonitor();
            }, 2000);
            
            // Failsafe: Direct API call and display
            setTimeout(async () => {
                console.log('[FAILSAFE] Attempting direct API update...');
                try {
                    // Direct spot fetch
                    const spotRes = await fetch('http://localhost:8000/api/live/nifty-spot');
                    const spotData = await spotRes.json();
                    console.log('[FAILSAFE] Spot data:', spotData);
                    
                    if (spotData.success && spotData.data) {
                        // Support both Kite (price) and Breeze (ltp)
                        const spotPrice = spotData.data.price || spotData.data.ltp;
                        if (spotPrice) {
                            const el = document.getElementById('candleCurrentNifty');
                            if (el) {
                                el.textContent = spotPrice.toFixed(2);
                                el.style.color = '#28a745';
                                console.log('[FAILSAFE] Updated Current NIFTY to:', spotPrice);
                            }
                        }
                    }
                    
                    // Direct candle fetch
                    const candleRes = await fetch('http://localhost:8000/api/breeze/hourly-candle');
                    const candleData = await candleRes.json();
                    console.log('[FAILSAFE] Candle data:', candleData);
                    
                    if (candleData.success && candleData.candle && candleData.candle.close) {
                        const el = document.getElementById('candleLastClose');
                        if (el) {
                            el.textContent = candleData.candle.close.toFixed(2);
                            el.style.color = '#28a745';
                            console.log('[FAILSAFE] Updated Last 1H Close to:', candleData.candle.close);
                        }
                    }
                } catch (e) {
                    console.error('[FAILSAFE] Error:', e);
                }
            }, 5000);
            // loadSavedConfiguration(); // DISABLED - Conflicts with loadTradeConfig()
            
            // Trade configuration is already loaded in DOMContentLoaded event
            
            // Initialize signal card toggles
            initializeSignalToggles();
            
            // Load saved signal states from localStorage
            loadSavedSignalStates();
            
            // Check broker connections
            checkBrokerConnections();
            
            // Periodic updates
            setInterval(window.loadLivePositions, 60000); // Update positions every minute
            setInterval(window.loadLiveSpotPrice, 5000); // Update spot price every 5 seconds
            setInterval(updateHeaderStats, 10000); // Update header stats every 10 seconds
            setInterval(updateLatency, 5000); // Update latency every 5 seconds
            setInterval(updateWebhookStatus, 5000); // Update webhook status every 5 seconds
            setInterval(updateSignalStats, 30000); // Update signal stats every 30 seconds
            setInterval(updateNextCandleTime, 1000); // Update next candle timer every second
            setInterval(checkBrokerConnections, 10000); // Check broker connections every 10 seconds
            
            // Start loading active orders
            loadActiveOrders();
            setInterval(loadActiveOrders, 3000); // Update active orders every 3 seconds
            
            // Start loading option chain
            loadOptionChain();
            setInterval(loadOptionChain, 10000); // Update option chain every 10 seconds
            
            // Load spot price immediately
            console.log('[INIT] Loading live spot price...');
            loadLiveSpotPrice();
            setInterval(loadLiveSpotPrice, 5000); // Update spot price every 5 seconds
        };
        
        // ===== OPTION CHAIN FUNCTIONS =====
        async function loadOptionChain() {
            try {
                const response = await fetch(getApiUrl('/option-chain/fast?symbol=NIFTY&strikes=10'));
                if (!response.ok) return;
                
                const result = await response.json();
                if (result.status !== 'success' || !result.data?.chain) return;
                
                const data = result.data;
                const optionChainDiv = document.getElementById('optionChainTable');
                if (!optionChainDiv) return;
                
                // Build option chain table
                let html = `
                    <div style="padding: 10px; font-size: 12px;">
                        <div style="margin-bottom: 10px; display: flex; justify-content: space-between;">
                            <span><strong>Spot:</strong> ${data.spot_price?.toFixed(2) || 'N/A'}</span>
                            <span><strong>ATM:</strong> ${data.atm_strike || 'N/A'}</span>
                        </div>
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: var(--bg-secondary); font-size: 11px;">
                                    <th style="padding: 5px; text-align: center; border: 1px solid var(--border);">CALL OI</th>
                                    <th style="padding: 5px; text-align: center; border: 1px solid var(--border);">CALL LTP</th>
                                    <th style="padding: 5px; text-align: center; border: 1px solid var(--border); background: var(--bg-primary);">STRIKE</th>
                                    <th style="padding: 5px; text-align: center; border: 1px solid var(--border);">PUT LTP</th>
                                    <th style="padding: 5px; text-align: center; border: 1px solid var(--border);">PUT OI</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                // Display option chain data
                data.chain.forEach(item => {
                    const isATM = item.strike === data.atm_strike;
                    const rowStyle = isATM ? 'background: #FFD700; color: #000; font-weight: bold;' : '';
                    
                    // Handle both ce_ltp/pe_ltp and call_ltp/put_ltp formats
                    const callLtp = item.call_ltp || item.ce_ltp || 0;
                    const putLtp = item.put_ltp || item.pe_ltp || 0;
                    const callOi = item.call_oi || item.ce_oi || 0;
                    const putOi = item.put_oi || item.pe_oi || 0;
                    
                    html += `
                        <tr style="${rowStyle}">
                            <td style="padding: 4px; text-align: right; border: 1px solid var(--border); font-size: 11px;">
                                ${callOi > 0 ? (callOi / 1000000).toFixed(1) + 'M' : '-'}
                            </td>
                            <td style="padding: 4px; text-align: right; border: 1px solid var(--border); font-size: 11px; color: var(--accent-green);">
                                ${callLtp > 0 ? callLtp.toFixed(2) : '-'}
                            </td>
                            <td style="padding: 4px; text-align: center; border: 1px solid var(--border); font-size: 11px; font-weight: bold;">
                                ${item.strike}
                            </td>
                            <td style="padding: 4px; text-align: right; border: 1px solid var(--border); font-size: 11px; color: var(--accent-red);">
                                ${putLtp > 0 ? putLtp.toFixed(2) : '-'}
                            </td>
                            <td style="padding: 4px; text-align: right; border: 1px solid var(--border); font-size: 11px;">
                                ${putOi > 0 ? (putOi / 1000000).toFixed(1) + 'M' : '-'}
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                optionChainDiv.innerHTML = html;
            } catch (error) {
                console.error('Error loading option chain:', error);
            }
        }
        
        // ===== ORDER TRACKING FUNCTIONS =====
        
        // Cancel Kite order directly with broker
        async function cancelKiteOrder(orderId) {
            if (!confirm(`Are you sure you want to cancel order ${orderId}?`)) {
                return;
            }

            try {
                // Try the new endpoint first, fallback to the old one
                let response = await fetch(getApiUrl(`/orders/${orderId}`), {
                    method: 'DELETE'
                });

                let result;
                try {
                    result = await response.json();
                } catch (e) {
                    result = { status: 'error', message: 'Invalid response from server' };
                }

                if (response.ok && result.status === 'success') {
                    showNotification(`âœ“ Order ${orderId} cancelled successfully`, 'success');

                    // Remove the order row with fade animation
                    const orderRow = document.querySelector(`tr[data-order-id="${orderId}"]`);
                    if (orderRow) {
                        orderRow.style.opacity = '0.5';
                        orderRow.style.transition = 'opacity 0.3s';
                        setTimeout(() => {
                            orderRow.remove();
                        }, 300);
                    }

                    // Reload orders after a delay
                    setTimeout(loadActiveOrders, 500);
                } else {
                    // Extract error message from response
                    let errorMsg = result.message || result.detail || 'Unknown error';
                    if (errorMsg.includes('hash error')) {
                        errorMsg = 'Order may have already been cancelled or expired';
                    }
                    showNotification(`Failed to cancel order: ${errorMsg}`, 'error');
                }
            } catch (error) {
                console.error('Error cancelling order:', error);
                showNotification(`Error cancelling order: ${error.message}`, 'error');
            }
        }

        // Cancel all pending orders
        async function cancelAllOrders() {
            try {
                // First, get all active orders
                const response = await fetch(getApiUrl('/api/orders/active'));
                if (!response.ok) {
                    showNotification('Failed to fetch active orders', 'error');
                    return;
                }

                const data = await response.json();
                const orders = data.orders || [];

                // Filter cancellable orders
                const cancellableOrders = orders.filter(order =>
                    order.status === 'OPEN' ||
                    order.status === 'PENDING' ||
                    order.status === 'TRIGGER PENDING' ||
                    order.status === 'AMO REQ RECEIVED' ||
                    order.status === 'PUT ORDER REQ RECEIVED' ||
                    order.status === 'VALIDATION PENDING' ||
                    order.status === 'OPEN PENDING'
                );

                if (cancellableOrders.length === 0) {
                    showNotification('No cancellable orders found', 'info');
                    return;
                }

                if (!confirm(`Are you sure you want to cancel ${cancellableOrders.length} orders?`)) {
                    return;
                }

                let successCount = 0;
                let failCount = 0;

                // Cancel each order
                for (const order of cancellableOrders) {
                    try {
                        const cancelResponse = await fetch(getApiUrl(`/orders/${order.order_id}`), {
                            method: 'DELETE'
                        });

                        if (cancelResponse.ok) {
                            successCount++;
                            // Update UI - fade out the order
                            const orderRow = document.querySelector(`tr[data-order-id="${order.order_id}"]`);
                            if (orderRow) {
                                orderRow.style.opacity = '0.5';
                                orderRow.style.transition = 'opacity 0.3s';
                            }
                        } else {
                            failCount++;
                            console.error(`Failed to cancel order ${order.order_id}`);
                        }
                    } catch (error) {
                        failCount++;
                        console.error(`Error cancelling order ${order.order_id}:`, error);
                    }
                }

                // Show result
                if (successCount > 0 && failCount === 0) {
                    showNotification(`âœ“ Successfully cancelled ${successCount} orders`, 'success');
                } else if (successCount > 0 && failCount > 0) {
                    showNotification(`Cancelled ${successCount} orders, ${failCount} failed`, 'warning');
                } else {
                    showNotification(`Failed to cancel orders`, 'error');
                }

                // Reload orders after a delay
                setTimeout(loadActiveOrders, 500);

            } catch (error) {
                console.error('Error in cancelAllOrders:', error);
                showNotification(`Error: ${error.message}`, 'error');
            }
        }

        // Make functions available globally
        window.cancelKiteOrder = cancelKiteOrder;
        window.cancelAllOrders = cancelAllOrders;

        // Load and display active orders
        async function loadActiveOrders() {
            try {
                const response = await fetch(getApiUrl('/api/orders/active'));
                if (response.ok) {
                    const data = await response.json();
                    displayActiveOrders(data.orders || []);
                    updateOrderCounts(data.orders || []);
                } else {
                    console.error('Failed to load active orders:', response.status);
                }
            } catch (error) {
                console.error('Error loading active orders:', error);
            }
        }

        // Display orders in the table
        function displayActiveOrders(orders) {
            const tbody = document.getElementById('ordersTableBody');
            if (!tbody) return;
            
            if (orders.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="8" style="text-align: center; padding: 20px; color: var(--text-muted);">
                            No active orders
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = orders.map(order => {
                const filledQty = order.filled_quantity || 0;
                const totalQty = order.quantity || 0;
                const fillPercent = totalQty > 0 ? ((filledQty / totalQty) * 100).toFixed(0) : 0;
                const price = order.price || 'MARKET';
                const time = formatOrderTime(order.order_timestamp || order.exchange_update_timestamp);
                const statusClass = getStatusClass(order.status);

                // Only show cancel button for cancellable orders
                const canCancel = order.status === 'OPEN' ||
                                 order.status === 'PENDING' ||
                                 order.status === 'TRIGGER PENDING' ||
                                 order.status === 'AMO REQ RECEIVED' ||
                                 order.status === 'PUT ORDER REQ RECEIVED' ||
                                 order.status === 'VALIDATION PENDING' ||
                                 order.status === 'OPEN PENDING';

                return `
                    <tr data-order-id="${order.order_id}">
                        <td style="font-family: monospace; font-size: 11px;">${order.order_id}</td>
                        <td style="font-weight: 600;">${order.tradingsymbol}</td>
                        <td style="text-align: center;">
                            <span style="color: ${order.transaction_type === 'BUY' ? 'var(--accent-green)' : 'var(--accent-red)'};">
                                ${order.transaction_type}
                            </span>
                        </td>
                        <td style="text-align: center;">
                            ${filledQty}/${totalQty}
                            ${fillPercent > 0 ? `<span style="font-size: 10px; color: var(--text-muted);">(${fillPercent}%)</span>` : ''}
                        </td>
                        <td style="text-align: right; font-family: monospace;">${price}</td>
                        <td style="text-align: center;">
                            <span class="status-badge ${statusClass}">${order.status}</span>
                        </td>
                        <td style="text-align: center; font-size: 11px; color: var(--text-muted);">${time}</td>
                        <td style="text-align: center;">
                            ${canCancel ? `
                                <button onclick="cancelKiteOrder('${order.order_id}')"
                                        class="btn-action"
                                        style="padding: 4px 8px; font-size: 11px; background: var(--accent-red); color: white; border: none; border-radius: 4px; cursor: pointer;">
                                    <i class="fas fa-times"></i> Cancel
                                </button>
                            ` : '<span style="color: var(--text-muted); font-size: 10px;">-</span>'}
                        </td>
                    </tr>
                `;
            }).join('');
        }

        // Update order counts in header
        function updateOrderCounts(orders) {
            let pendingCount = 0;
            let openCount = 0;
            
            orders.forEach(order => {
                const status = order.status;
                if (status === 'OPEN') {
                    openCount++;
                } else if (status.includes('PENDING')) {
                    pendingCount++;
                }
            });
            
            const pendingEl = document.getElementById('pendingCount');
            const openEl = document.getElementById('openCount');
            
            if (pendingEl) pendingEl.textContent = `${pendingCount} Pending`;
            if (openEl) openEl.textContent = `${openCount} Open`;
        }

        // Get status class for styling
        function getStatusClass(status) {
            const statusMap = {
                'OPEN': 'status-open',
                'COMPLETE': 'status-complete',
                'REJECTED': 'status-rejected',
                'CANCELLED': 'status-cancelled',
                'TRIGGER PENDING': 'status-trigger-pending',
                'OPEN PENDING': 'status-open-pending',
                'VALIDATION PENDING': 'status-validation-pending',
                'MODIFY PENDING': 'status-modify-pending'
            };
            
            return statusMap[status] || 'status-badge';
        }

        // Format order timestamp
        function formatOrderTime(timestamp) {
            if (!timestamp) return '--';
            
            try {
                const date = new Date(timestamp);
                return date.toLocaleTimeString('en-IN', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            } catch (e) {
                return timestamp;
            }
        }
        
        // Update Hedge Preview with position data
        function updateHedgePreviewWithPositions(positions) {
            if (!positions || positions.length === 0) {
                clearHedgePreview();
                return;
            }
            
            // Take the first position for preview
            const position = positions[0];
            
            // Update main position
            const mainEl = document.getElementById('hedgePreviewMain');
            if (mainEl && position.main_strike) {
                mainEl.textContent = `SELL ${position.main_strike}${position.option_type || ''} @ â‚¹${position.main_price ? position.main_price.toFixed(2) : '--'}`;
            }
            
            // Update target hedge price (30% of main)
            const targetEl = document.getElementById('hedgePreviewTarget');
            if (targetEl && position.main_price) {
                const targetPrice = position.main_price * 0.3;
                targetEl.textContent = `â‚¹${targetPrice.toFixed(2)} (30%)`;
            }
            
            // Update selected hedge
            const selectedEl = document.getElementById('hedgePreviewSelected');
            if (selectedEl && position.hedge_strike) {
                selectedEl.textContent = `BUY ${position.hedge_strike}${position.option_type || ''} @ â‚¹${position.hedge_price ? position.hedge_price.toFixed(2) : '--'}`;
            }
            
            // Update max risk
            const riskEl = document.getElementById('hedgePreviewRisk');
            if (riskEl && position.main_strike && position.hedge_strike) {
                const strikeGap = Math.abs(position.main_strike - position.hedge_strike);
                const maxRisk = strikeGap * position.quantity * position.lot_size;
                riskEl.textContent = `â‚¹${maxRisk.toLocaleString()}`;
            }
        }
        
        // Clear Hedge Preview
        function clearHedgePreview() {
            const mainEl = document.getElementById('hedgePreviewMain');
            const targetEl = document.getElementById('hedgePreviewTarget');
            const selectedEl = document.getElementById('hedgePreviewSelected');
            const riskEl = document.getElementById('hedgePreviewRisk');
            
            if (mainEl) mainEl.textContent = '--';
            if (targetEl) targetEl.textContent = '-- (30%)';
            if (selectedEl) selectedEl.textContent = '--';
            if (riskEl) riskEl.textContent = '--';
        }
        
        // Update Live Breakeven Monitor with real position data
        function updateLiveBreakevenMonitor(positions) {
            const legsDisplay = document.getElementById('positionLegsDisplay');
            if (!legsDisplay) return;
            
            if (!positions || positions.length === 0) {
                legsDisplay.innerHTML = `
                    <div class="no-positions" style="text-align: center; padding: 20px; color: var(--text-muted);">
                        No active positions. Add a position to see live breakeven monitoring.
                    </div>
                `;
                return;
            }
            
            // Take the first position for display (or you can show all)
            const position = positions[0];
            
            // Build HTML for position legs
            let html = '';
            
            // Main leg
            if (position.main_strike) {
                const mainPnL = position.main_leg ? position.main_leg.pnl : 0;
                const pnlColor = mainPnL >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                const pnlSign = mainPnL >= 0 ? '+' : '';
                
                html += `
                    <div class="leg-card">
                        <div class="leg-title">MAIN LEG (SELL ${position.main_strike}${position.option_type || ''})</div>
                        <div class="leg-details">
                            <span>Entry:</span>
                            <span>â‚¹${position.main_price ? position.main_price.toFixed(2) : '--'}</span>
                        </div>
                        <div class="leg-details">
                            <span>Current:</span>
                            <span>â‚¹${position.current_main_price ? position.current_main_price.toFixed(2) : '--'}</span>
                        </div>
                        <div class="leg-details">
                            <span>P&L:</span>
                            <span style="color: ${pnlColor};">${pnlSign}â‚¹${Math.abs(mainPnL).toFixed(0)}</span>
                        </div>
                    </div>
                `;
            }
            
            // Hedge leg
            if (position.hedge_strike) {
                const hedgePnL = position.hedge_leg ? position.hedge_leg.pnl : 0;
                const pnlColor = hedgePnL >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                const pnlSign = hedgePnL >= 0 ? '+' : '';
                
                html += `
                    <div class="leg-card hedge">
                        <div class="leg-title">HEDGE LEG (BUY ${position.hedge_strike}${position.option_type || ''})</div>
                        <div class="leg-details">
                            <span>Entry:</span>
                            <span>â‚¹${position.hedge_price ? position.hedge_price.toFixed(2) : '--'}</span>
                        </div>
                        <div class="leg-details">
                            <span>Current:</span>
                            <span>â‚¹${position.current_hedge_price ? position.current_hedge_price.toFixed(2) : '--'}</span>
                        </div>
                        <div class="leg-details">
                            <span>P&L:</span>
                            <span style="color: ${pnlColor};">${pnlSign}â‚¹${Math.abs(hedgePnL).toFixed(0)}</span>
                        </div>
                    </div>
                `;
            }
            
            legsDisplay.innerHTML = html;
            
            // Update the Net P&L at the top
            const netPnLDisplay = document.querySelector('.net-premium div:last-child span');
            if (netPnLDisplay) {
                const totalPnL = position.pnl || 0;
                const pnlColor = totalPnL >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                const pnlSign = totalPnL >= 0 ? '+' : '';
                netPnLDisplay.style.color = pnlColor;
                netPnLDisplay.textContent = `${pnlSign}â‚¹${Math.abs(totalPnL).toFixed(0)}`;
            }
        }
        
        // WebSocket reconnection tracking
        let positionsWsReconnectAttempts = 0;
        let positionsWsMaxReconnectDelay = 30000; // Max 30 seconds
        
        // Initialize Live Positions WebSocket for real-time position updates
        window.initializeLivePositionsWebSocket = function() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname || 'localhost';
            const port = window.location.port || '8000';
            const wsUrl = `${protocol}//${host}:${port}/ws/live-positions`;
            
            console.log('Connecting to Live Positions WebSocket...');
            
            // Close existing connection if any
            if (window.positionsWs && window.positionsWs.readyState === WebSocket.OPEN) {
                window.positionsWs.close();
            }
            
            try {
                window.positionsWs = new WebSocket(wsUrl);
                
                window.positionsWs.onopen = function() {
                    console.log('Live Positions WebSocket connected');
                    positionsWsReconnectAttempts = 0; // Reset on successful connection
                    
                    // Update UI indicator
                    const wsIndicator = document.getElementById('apiStatus');
                    if (wsIndicator) {
                        wsIndicator.querySelector('.status-dot').style.background = '#00c851';
                    }
                };
                
                window.positionsWs.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        
                        if (data.type === 'positions_update') {
                            // Update the Live Breakeven Monitor
                            if (data.data && data.data.positions) {
                                positions = data.data.positions;
                                updateLiveBreakevenMonitor(data.data.positions);
                                
                                // Update the positions table
                                updatePositionsTable(data.data.positions);
                                
                                // Update positions list if visible
                                if (typeof displayPositions === 'function') {
                                    displayPositions();
                                }
                            }
                        }
                    } catch (parseError) {
                        console.error('Error parsing WebSocket message:', parseError);
                    }
                };
                
                window.positionsWs.onerror = function(error) {
                    console.error('Live Positions WebSocket error:', error);
                    
                    // Update UI indicator
                    const wsIndicator = document.getElementById('apiStatus');
                    if (wsIndicator) {
                        wsIndicator.querySelector('.status-dot').style.background = '#ff9800';
                    }
                };
                
                window.positionsWs.onclose = function(event) {
                    console.log('Live Positions WebSocket disconnected:', event.code, event.reason);
                    
                    // Exponential backoff for reconnection
                    positionsWsReconnectAttempts++;
                    const reconnectDelay = Math.min(1000 * Math.pow(2, positionsWsReconnectAttempts), positionsWsMaxReconnectDelay);
                    
                    console.log(`Reconnecting in ${reconnectDelay/1000} seconds... (attempt ${positionsWsReconnectAttempts})`);
                    setTimeout(window.initializeLivePositionsWebSocket, reconnectDelay);
                };
                
            } catch (error) {
                console.error('Failed to create Live Positions WebSocket:', error);
                // Try again after delay
                setTimeout(window.initializeLivePositionsWebSocket, 5000);
            }
        }
        
        // Initialize Breeze WebSocket for live NIFTY streaming
        window.initializeBreezeWebSocket = function() {
            // Always use localhost:8000 for local development
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname || 'localhost';
            const port = window.location.port || '8000';
            // Use Kite WebSocket instead of Breeze for better accuracy
            const wsUrl = `${protocol}//${host}:${port}/ws/kite-live`;
            
            console.log('Connecting to Kite WebSocket for live NIFTY streaming...');
            
            try {
                window.kiteWs = new WebSocket(wsUrl);
                
                window.kiteWs.onopen = function() {
                    console.log('Connected to Kite live stream');
                    updateBrokerStatus('kite', true);
                    const spotEl = document.getElementById('niftySpot');
                    if (spotEl) {
                        spotEl.style.color = '#ffc107'; // Yellow while connecting
                        spotEl.textContent = 'Connecting...';
                    }
                };
                
                window.kiteWs.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    
                    // Handle Kite market updates
                    if (data.type === 'market_update' && data.data) {
                        const niftyData = data.data.nifty;
                        const bankniftyData = data.data.banknifty;
                        
                        // Update NIFTY spot
                        if (niftyData && niftyData.spot) {
                            const spotEl = document.getElementById('niftySpot');
                            if (spotEl) {
                                spotEl.textContent = niftyData.spot.toFixed(2);
                                spotEl.style.color = '#28a745'; // Green for live data
                                spotEl.title = 'Live streaming from Kite WebSocket';
                            }
                            
                            // UPDATE TIMESTAMPS
                            const now = new Date();
                            const timeStr = now.toLocaleTimeString('en-IN', {hour12: false});
                            
                            // Update header timestamp
                            const spotTimeEl = document.getElementById('niftySpotTime');
                            if (spotTimeEl) spotTimeEl.textContent = timeStr;
                            
                            const spotAgeEl = document.getElementById('niftySpotAge');
                            if (spotAgeEl) {
                                spotAgeEl.textContent = 'LIVE';
                                spotAgeEl.style.color = 'var(--accent-green)';
                            }
                            
                            // Record update time for age tracking
                            window.recordDataUpdate('spot');
                            
                            // Update status panel
                            updateMarketDataStatus('spot', {
                                price: niftyData.spot.toFixed(2),
                                time: timeStr,
                                age: '0s',
                                source: 'Breeze WebSocket',
                                valid: true
                            });
                            
                            // Also update spotPrice element if exists
                            const spotPriceEl = document.getElementById('spotPrice');
                            if (spotPriceEl) {
                                spotPriceEl.textContent = niftyData.spot.toFixed(2);
                            }
                            
                            // Show timestamp for debugging
                            const timestamp = new Date(data.data.timestamp).toLocaleTimeString();
                            console.log(`NIFTY Live: ${niftyData.spot} @ ${timestamp} (Breeze WebSocket)`);
                        }
                    } else if (data.type === 'status') {
                        console.log('Breeze WebSocket status:', data.message);
                        const spotEl = document.getElementById('niftySpot');
                        if (spotEl && !data.message.includes('mock')) {
                            spotEl.textContent = 'Waiting...';
                            spotEl.style.color = '#ffc107'; // Yellow for waiting
                            spotEl.title = data.message;
                        } else if (spotEl) {
                            spotEl.textContent = 'No data';
                            spotEl.style.color = '#dc3545';
                            spotEl.title = 'Only real data allowed';
                        }
                    } else if (data.type === 'heartbeat') {
                        // Ignore heartbeat messages
                        console.debug('Heartbeat received');
                    } else if (data.type === 'error') {
                        console.error('Breeze WebSocket error:', data.message);
                        const spotEl = document.getElementById('niftySpot');
                        if (spotEl) {
                            spotEl.textContent = 'Stream Error';
                            spotEl.style.color = '#dc3545';
                            spotEl.title = data.message;
                        }
                    }
                };
                
                window.kiteWs.onerror = function(error) {
                    console.error('Kite WebSocket error:', error);
                    const spotEl = document.getElementById('niftySpot');
                    if (spotEl) {
                        spotEl.textContent = 'Connection Error';
                        spotEl.style.color = '#dc3545';
                    }
                };
                
                window.kiteWs.onclose = function() {
                    console.log('Kite WebSocket disconnected');
                    const spotEl = document.getElementById('niftySpot');
                    if (spotEl) {
                        spotEl.textContent = 'Disconnected';
                        spotEl.style.color = '#ffc107';
                    }
                    // Attempt reconnection after 5 seconds
                    setTimeout(window.initializeBreezeWebSocket, 5000);
                };
                
            } catch (error) {
                console.error('Failed to create Breeze WebSocket:', error);
            }
        }
        
        // Load live spot price - make it global (fallback for when WebSocket is not available)
        window.loadLiveSpotPrice = async function() {
            console.log('[SPOT] loadLiveSpotPrice called at', new Date().toISOString());
            try {
                // Try to get REAL data from Kite API (primary) or Breeze (fallback)
                let spotValue = null;
                let dataSource = 'NONE';
                
                // 1. First try Kite API endpoint
                try {
                    const apiUrl = getApiUrl('/api/live/nifty-spot');
                    console.log('[SPOT] Fetching from:', apiUrl);
                    const response = await fetch(apiUrl);
                    console.log('[SPOT] Response status:', response.status);
                    if (response.ok) {
                        const data = await response.json();
                        console.log('[SPOT] API Response:', data);
                        if (data.success && data.data) {
                            // Check if we have price data
                            const price = data.data.price || data.data.ltp;
                            console.log('[SPOT] Extracted price:', price);
                            if (price) {
                                spotValue = parseFloat(price).toFixed(2);
                                dataSource = data.data.source || 'KITE';
                                console.log(`[SPOT] Got NIFTY spot from ${dataSource}:`, spotValue);
                            }
                        }
                    }
                } catch (e) {
                    console.error('[SPOT] Kite API endpoint failed:', e);
                }
                
                // 2. If that fails, try option-chain endpoint (which also uses Kite now)
                if (!spotValue) {
                    try {
                        const optionResponse = await fetch(getApiUrl('/option-chain/fast?symbol=NIFTY&strikes=1'));
                        if (optionResponse.ok) {
                            const optionData = await optionResponse.json();
                            if (optionData.status === 'success' && optionData.data?.spot_price) {
                                spotValue = optionData.data.spot_price.toFixed(2);
                                dataSource = optionData.data.data_source || 'KITE';
                                console.log(`Got NIFTY spot from option chain (${dataSource}):`, spotValue);
                            }
                        }
                    } catch (e) {
                        console.log('Option chain endpoint failed:', e.message);
                    }
                }
                
                // 3. Update display - ONLY show real data or error messages
                const spotEl = document.getElementById('niftySpot');
                const spotTimeEl = document.getElementById('niftySpotTime');
                const spotAgeEl = document.getElementById('niftySpotAge');
                
                console.log('[SPOT] DOM Elements found:', {
                    spotEl: !!spotEl,
                    spotTimeEl: !!spotTimeEl,
                    spotAgeEl: !!spotAgeEl,
                    spotValue: spotValue,
                    dataSource: dataSource
                });
                
                if (spotEl) {
                    if (spotValue) {
                        // Show data from Kite or Breeze
                        console.log(`[SPOT] Updating UI with value: ${spotValue} from ${dataSource}`);
                        spotEl.textContent = spotValue;
                        spotEl.style.color = '#28a745'; // Green for real data
                        spotEl.title = `Real-time from ${dataSource}`;
                        
                        // UPDATE TIMESTAMP AND AGE
                        const now = new Date();
                        const timeStr = now.toLocaleTimeString('en-IN', {hour12: false});
                        
                        if (spotTimeEl) spotTimeEl.textContent = timeStr;
                        if (spotAgeEl) {
                            spotAgeEl.textContent = 'FRESH';
                            spotAgeEl.style.color = 'var(--accent-green)';
                        }
                        
                        // Record update time for age tracking
                        if (window.recordDataUpdate) {
                            window.recordDataUpdate('spot');
                        }
                        
                        // Update status panel
                        if (window.updateMarketDataStatus) {
                            updateMarketDataStatus('spot', {
                                price: spotValue,
                                time: timeStr,
                                age: '0s',
                                source: dataSource,
                                valid: true
                            });
                        }
                        console.log('[SPOT] UI update complete - element should now show:', spotValue);
                        
                        // IMPORTANT: Update the candle monitor with the new spot price
                        if (window.update1HCandleMonitor) {
                            console.log('[SPOT] Triggering candle monitor update');
                            window.update1HCandleMonitor();
                        }
                    } else {
                        // No data available
                        console.log('[SPOT] No data to display - showing "No data"');
                        spotEl.textContent = 'No data';
                        spotEl.style.color = '#ffc107'; // Yellow for waiting
                        spotEl.title = 'Waiting for market data from Kite API';
                    }
                } else {
                    console.error('[SPOT] Could not find element with id "niftySpot"');
                }
                
                // Also update spotPrice element if exists
                const spotPriceEl = document.getElementById('spotPrice');
                if (spotPriceEl) {
                    if (spotValue && dataSource !== 'NONE') {
                        spotPriceEl.textContent = spotValue;
                    } else {
                        spotPriceEl.textContent = 'No Data';
                    }
                }
                
            } catch (error) {
                console.error('Error loading spot price:', error);
                const spotEl = document.getElementById('niftySpot');
                if (spotEl) {
                    spotEl.textContent = 'Error';
                    spotEl.style.color = '#dc3545'; // Red for error
                    spotEl.title = 'Failed to load data - Check API connection';
                }
            }
        }
        
        // Update broker status indicators
        function updateBrokerStatus(broker, isConnected) {
            const dotId = `${broker}StatusDot`;
            const dot = document.getElementById(dotId);
            if (dot) {
                dot.style.background = isConnected ? 'var(--accent-green)' : '#6b7280';
                dot.style.boxShadow = isConnected ? '0 0 8px var(--accent-green)' : 'none';
            }
        }
        
        // Check broker connections
        async function checkBrokerConnections() {
            try {
                // Check Breeze connection
                const breezeRes = await fetch(getApiUrl('/live/auth/status'));
                if (breezeRes.ok) {
                    const breezeData = await breezeRes.json();
                    updateBrokerStatus('breeze', breezeData.authenticated === true);
                } else {
                    updateBrokerStatus('breeze', false);
                }
                
                // Check Kite connection (if endpoint exists)
                try {
                    const kiteRes = await fetch(getApiUrl('/kite/status'));
                    if (kiteRes.ok) {
                        const kiteData = await kiteRes.json();
                        updateBrokerStatus('kite', kiteData.connected === true);
                    } else {
                        updateBrokerStatus('kite', false);
                    }
                } catch {
                    updateBrokerStatus('kite', false);
                }
                
                // TradingView status updated by WebSocket
            } catch (error) {
                console.error('Error checking broker connections:', error);
            }
        }
        
        // Update header statistics with real data based on current mode
        async function updateHeaderStats() {
            try {
                // Get current trading mode
                const currentMode = window.currentTradingMode || 'LIVE';
                
                if (currentMode === 'LIVE') {
                    // For LIVE mode: Show real trading data
                    const positionsRes = await fetch(getApiUrl('/live/positions'));
                    const positions = await positionsRes.json();
                    
                    // Update Today's P&L - from live trading
                    const todayPnl = document.getElementById('todayPnL');
                    if (todayPnl) {
                        const pnl = positions.total_pnl || 0;
                        todayPnl.textContent = pnl >= 0 ? `+â‚¹${Math.abs(pnl).toLocaleString()}` : `-â‚¹${Math.abs(pnl).toLocaleString()}`;
                        todayPnl.className = pnl >= 0 ? 'stat-value positive' : 'stat-value negative';
                    }
                    
                    // Update Open Positions - live positions
                    const openPos = document.getElementById('openPositions');
                    if (openPos) {
                        openPos.textContent = positions.positions?.length || 0;
                    }
                    
                    // Update Win Rate - today's live trades
                    const winRate = document.getElementById('winRate');
                    if (winRate) {
                        // Calculate win rate from positions if available
                        const rate = positions.win_rate || 0;
                        if (rate === 0) {
                            winRate.textContent = '0%';
                            winRate.className = 'stat-value';
                        } else {
                            winRate.textContent = `${rate.toFixed(1)}%`;
                            winRate.className = rate >= 50 ? 'stat-value positive' : 'stat-value negative';
                        }
                    }
                    
                    // Update Active Signals count
                    const activeSignalsEl = document.getElementById('activeSignals');
                    if (activeSignalsEl) {
                        // Count enabled signals from localStorage or default all enabled
                        const signalStates = JSON.parse(localStorage.getItem('signalStates') || '{}');
                        const enabledCount = Object.keys(signalStates).filter(key => signalStates[key] !== false).length || 8;
                        activeSignalsEl.textContent = enabledCount;
                    }
                    
                    // Update mode indicator in header
                    updateModeIndicator('LIVE', 'var(--accent-green)');
                    
                } else if (currentMode === 'PAPER') {
                    // For PAPER mode: Show paper trading data
                    const positionsRes = await fetch(getApiUrl('/api/trading/positions'));
                    const positions = await positionsRes.json();
                    
                    // Update Today's P&L - from paper trading
                    const todayPnl = document.getElementById('todayPnL');
                    if (todayPnl) {
                        const pnl = positions.positions?.reduce((sum, p) => sum + (p.pnl || 0), 0) || 0;
                        todayPnl.textContent = pnl >= 0 ? `+â‚¹${Math.abs(pnl).toLocaleString()}` : `-â‚¹${Math.abs(pnl).toLocaleString()}`;
                        todayPnl.className = pnl >= 0 ? 'stat-value positive' : 'stat-value negative';
                    }
                    
                    // Update Open Positions - paper positions
                    const openPos = document.getElementById('openPositions');
                    if (openPos) {
                        openPos.textContent = positions.count || 0;
                    }
                    
                    // Update Win Rate - paper trades
                    const winRate = document.getElementById('winRate');
                    if (winRate) {
                        const wins = positions.positions?.filter(p => p.pnl > 0).length || 0;
                        const total = positions.positions?.length || 0;
                        if (total === 0) {
                            winRate.textContent = 'N/A';
                            winRate.className = 'stat-value';
                        } else {
                            const rate = (wins / total) * 100;
                            winRate.textContent = `${rate.toFixed(1)}%`;
                            winRate.className = rate >= 50 ? 'stat-value positive' : 'stat-value negative';
                        }
                    }
                    
                    // Update mode indicator
                    updateModeIndicator('PAPER', 'var(--accent-orange)');
                    
                } else if (currentMode === 'BACKTEST') {
                    // For BACKTEST mode: Show historical backtest data
                    const signalsRes = await fetch(getApiUrl('/signals/statistics'));
                    const signals = await signalsRes.json();
                    
                    // Update Today's P&L - total backtest P&L
                    const todayPnl = document.getElementById('todayPnL');
                    if (todayPnl) {
                        const pnl = signals.total_pnl || 0;
                        todayPnl.textContent = pnl >= 0 ? `+â‚¹${Math.abs(pnl).toLocaleString()}` : `-â‚¹${Math.abs(pnl).toLocaleString()}`;
                        todayPnl.className = pnl >= 0 ? 'stat-value positive' : 'stat-value negative';
                    }
                    
                    // Update Open Positions - total backtest trades
                    const openPos = document.getElementById('openPositions');
                    if (openPos) {
                        const totalTrades = signals.signal_details?.reduce((sum, s) => sum + s.trades, 0) || 0;
                        openPos.textContent = totalTrades;
                        // Change label for backtest mode
                        const label = openPos.previousElementSibling;
                        if (label) label.textContent = 'Total Trades';
                    }
                    
                    // Update Win Rate - backtest win rate
                    const winRate = document.getElementById('winRate');
                    if (winRate) {
                        const rate = signals.avg_win_rate || 0;
                        winRate.textContent = `${rate.toFixed(1)}%`;
                        winRate.className = rate >= 50 ? 'stat-value positive' : 'stat-value negative';
                    }
                    
                    // Update mode indicator
                    updateModeIndicator('BACKTEST', 'var(--accent-blue)');
                }
                
                // Update Active Signals (same for all modes)
                const activeSignalCards = document.querySelectorAll('.signal-card.active').length;
                const activeSignalsEl = document.getElementById('activeSignals');
                if (activeSignalsEl) {
                    activeSignalsEl.textContent = activeSignalCards;
                }
                
            } catch (error) {
                console.error('Error updating header stats:', error);
                // Set default values if error occurs
                const todayPnl = document.getElementById('todayPnL');
                if (todayPnl) {
                    todayPnl.textContent = 'â‚¹0';
                    todayPnl.className = 'stat-value';
                }
                const openPos = document.getElementById('openPositions');
                if (openPos) {
                    openPos.textContent = '0';
                }
                const winRate = document.getElementById('winRate');
                if (winRate) {
                    winRate.textContent = '0%';
                    winRate.className = 'stat-value';
                }
                const activeSignals = document.getElementById('activeSignals');
                if (activeSignals) {
                    activeSignals.textContent = '0';
                }
            }
        }
        
        // Helper function to update mode indicator
        function updateModeIndicator(mode, color) {
            // Add mode indicator if it doesn't exist
            let modeIndicator = document.getElementById('modeIndicator');
            if (!modeIndicator) {
                const headerTitle = document.querySelector('.header-title');
                if (headerTitle) {
                    modeIndicator = document.createElement('span');
                    modeIndicator.id = 'modeIndicator';
                    modeIndicator.style.cssText = `
                        margin-left: 15px;
                        padding: 4px 12px;
                        border-radius: 20px;
                        font-size: 12px;
                        font-weight: 600;
                        letter-spacing: 1px;
                        background: ${color};
                        color: white;
                    `;
                    headerTitle.appendChild(modeIndicator);
                }
            }
            
            if (modeIndicator) {
                modeIndicator.textContent = mode;
                modeIndicator.style.background = color;
            }
        }
        
        // Update latency and connection status
        async function updateLatency() {
            try {
                // Measure local API server response time
                const startTime = Date.now();
                const response = await fetch(getApiUrl('/api/health'));
                const latency = Date.now() - startTime;
                
                // Update API Server latency display
                const apiLatency = document.getElementById('apiLatency');
                if (apiLatency) {
                    apiLatency.textContent = `${latency}ms`;
                }
                
                // Update API Server connection status
                const apiStatus = document.getElementById('apiStatus');
                if (apiStatus) {
                    const statusDot = apiStatus.querySelector('.status-dot');
                    if (response.ok) {
                        statusDot.style.background = 'var(--accent-green)';
                        apiStatus.classList.add('connected');
                        apiStatus.classList.remove('disconnected');
                    } else {
                        statusDot.style.background = 'var(--accent-red)';
                        apiStatus.classList.remove('connected');
                        apiStatus.classList.add('disconnected');
                    }
                }
                
                // Check broker status
                const brokerRes = await fetch(getApiUrl('/live/auth/status'));
                const brokerData = await brokerRes.json();
                
                const brokerStatus = document.getElementById('brokerStatus');
                if (brokerStatus) {
                    const statusDot = brokerStatus.querySelector('.status-dot');
                    const brokerName = brokerStatus.querySelector('span:nth-child(2)');
                    
                    if (brokerData.authenticated || brokerData.is_authenticated) {
                        statusDot.style.background = 'var(--accent-green)';
                        brokerStatus.classList.add('connected');
                        brokerStatus.classList.remove('disconnected');
                        brokerName.textContent = brokerData.broker || 'Zerodha';
                    } else {
                        statusDot.style.background = 'var(--accent-orange)';
                        brokerStatus.classList.remove('connected');
                        brokerStatus.classList.add('disconnected');
                        brokerName.textContent = 'Not Connected';
                    }
                }
            } catch (error) {
                console.error('Error updating latency:', error);
                
                // Set offline status on error
                const apiStatus = document.getElementById('apiStatus');
                if (apiStatus) {
                    const statusDot = apiStatus.querySelector('.status-dot');
                    statusDot.style.background = 'var(--accent-red)';
                    apiStatus.classList.remove('connected');
                    apiStatus.classList.add('disconnected');
                }
            }
        }
        
        // Update TradingView webhook status
        async function updateWebhookStatus() {
            try {
                const response = await fetch(getApiUrl('/api/webhook/metrics'));
                const data = await response.json();
                
                const tvWebhookStatus = document.getElementById('tvWebhookStatus');
                const tvWebhookTime = document.getElementById('tvWebhookTime');
                
                if (tvWebhookStatus && tvWebhookTime) {
                    const statusDot = tvWebhookStatus.querySelector('.status-dot');
                    
                    // Update time display
                    if (data.seconds_ago === null) {
                        tvWebhookTime.textContent = 'Never';
                        statusDot.style.background = 'var(--accent-gray)';
                    } else if (data.seconds_ago < 60) {
                        tvWebhookTime.textContent = `${Math.round(data.seconds_ago)}s ago`;
                        statusDot.style.background = 'var(--accent-green)';
                        tvWebhookStatus.classList.add('connected');
                    } else if (data.seconds_ago < 300) {
                        const mins = Math.floor(data.seconds_ago / 60);
                        tvWebhookTime.textContent = `${mins}m ago`;
                        statusDot.style.background = 'var(--accent-orange)';
                        tvWebhookStatus.classList.remove('connected');
                    } else {
                        const mins = Math.floor(data.seconds_ago / 60);
                        tvWebhookTime.textContent = `${mins}m ago`;
                        statusDot.style.background = 'var(--accent-red)';
                        tvWebhookStatus.classList.remove('connected');
                    }
                    
                    // Add hover tooltip with more details
                    tvWebhookStatus.title = `Webhooks Today: ${data.webhooks_today || 0}\nAvg Processing: ${data.avg_processing_ms || 0}ms\nLast Alert: ${data.last_alert_message || 'None'}`;
                }
            } catch (error) {
                console.error('Error updating webhook status:', error);
                
                const tvWebhookStatus = document.getElementById('tvWebhookStatus');
                if (tvWebhookStatus) {
                    const statusDot = tvWebhookStatus.querySelector('.status-dot');
                    statusDot.style.background = 'var(--accent-gray)';
                    document.getElementById('tvWebhookTime').textContent = 'Error';
                }
            }
        }
        
        // Update signal statistics for each signal card
        async function updateSignalStats() {
            try {
                const response = await fetch(getApiUrl('/signals/statistics'));
                const data = await response.json();
                
                if (data.signal_details) {
                    // Map signal stats to cards
                    const signalMap = {};
                    data.signal_details.forEach(detail => {
                        signalMap[detail.signal] = detail;
                    });
                    
                    // Update each signal card
                    for (let i = 1; i <= 8; i++) {
                        const signal = `S${i}`;
                        const stats = signalMap[signal] || { trades: 0, win_rate: 0, total_pnl: 0 };
                        
                        // Find the signal card
                        const signalCards = document.querySelectorAll('.signal-card');
                        signalCards.forEach(card => {
                            if (card.querySelector('.signal-name')?.textContent === signal) {
                                // Update trades count
                                const tradesEl = card.querySelectorAll('.signal-stat-value')[0];
                                if (tradesEl) tradesEl.textContent = stats.trades || 0;
                                
                                // Update win rate
                                const winRateEl = card.querySelectorAll('.signal-stat-value')[1];
                                if (winRateEl) winRateEl.textContent = `${(stats.win_rate || 0).toFixed(0)}%`;
                                
                                // Update P&L
                                const pnlEl = card.querySelectorAll('.signal-stat-value')[2];
                                if (pnlEl) {
                                    const pnl = stats.total_pnl || 0;
                                    const formatted = Math.abs(pnl) >= 1000 ? 
                                        `${pnl >= 0 ? '+' : '-'}${(Math.abs(pnl)/1000).toFixed(1)}K` : 
                                        `${pnl >= 0 ? '+' : ''}${pnl.toFixed(0)}`;
                                    pnlEl.textContent = formatted;
                                    pnlEl.style.color = pnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                                }
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error updating signal stats:', error);
            }
        }
        
        // Risk metrics removed - no longer needed
        function updateRiskMetrics() {
            // Risk management removed from system
            return;
        }
        
        // Update paper trading statistics
        async function updatePaperTradingStats() {
            try {
                // Check paper trading state
                const stateRes = await fetch(getApiUrl('/api/trading/positions'));
                const state = await stateRes.json();
                
                if (state.is_paper) {
                    // Fetch paper trading specific stats
                    const capital = 500000; // Default capital
                    const used = state.positions.reduce((sum, pos) => 
                        sum + (pos.quantity * pos.avg_price), 0);
                    const available = capital - used;
                    const pnl = state.positions.reduce((sum, pos) => 
                        sum + pos.pnl, 0);
                    
                    // Update capital display
                    const paperCapital = document.getElementById('paperCapital');
                    if (paperCapital) {
                        paperCapital.textContent = `â‚¹${capital.toLocaleString()}`;
                    }
                    
                    // Update available capital
                    const paperAvailable = document.getElementById('paperAvailable');
                    if (paperAvailable) {
                        paperAvailable.textContent = `â‚¹${available.toLocaleString()}`;
                    }
                    
                    // Update P&L
                    const paperPnl = document.getElementById('paperPnl');
                    if (paperPnl) {
                        paperPnl.textContent = `â‚¹${Math.abs(pnl).toLocaleString()}`;
                        paperPnl.style.color = pnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                    }
                    
                    // Update win rate
                    const paperWinRate = document.getElementById('paperWinRate');
                    if (paperWinRate) {
                        const wins = state.positions.filter(p => p.pnl > 0).length;
                        const total = state.positions.length;
                        const rate = total > 0 ? (wins / total * 100) : 0;
                        paperWinRate.textContent = `${rate.toFixed(0)}%`;
                    }
                }
            } catch (error) {
                console.error('Error updating paper trading stats:', error);
            }
        }
        
        // Update hedge example with real option prices
        async function updateHedgeExample() {
            try {
                // Fetch current NIFTY spot price
                const spotRes = await fetch(getApiUrl('/api/live/nifty-spot'));
                const spotData = await spotRes.json();
                
                if (spotData.success) {
                    const spot = Math.round(spotData.data.ltp / 50) * 50; // Round to nearest 50
                    
                    // Fetch option chain for current strike
                    const chainRes = await fetch(getApiUrl(`/api/live/option-chain?strike=${spot}&range=2`));
                    const chainData = await chainRes.json();
                    
                    if (chainData.success && chainData.chain.length > 0) {
                        // Find ATM option
                        const atmOption = chainData.chain.find(o => o.strike === spot) || chainData.chain[0];
                        const otmOption = chainData.chain.find(o => o.strike === spot - 200) || chainData.chain[0];
                        
                        // Update main leg display
                        const mainLegEl = document.querySelector('.hedge-example-item:nth-child(1) span');
                        if (mainLegEl) {
                            mainLegEl.textContent = `SELL ${spot}PE @ â‚¹${Math.round(atmOption.pe_ltp)}`;
                        }
                        
                        // Update hedge premium (30% of main)
                        const hedgePremEl = document.querySelector('.hedge-example-item:nth-child(2) span:nth-child(2)');
                        if (hedgePremEl) {
                            const hedgePrem = Math.round(atmOption.pe_ltp * 0.3);
                            hedgePremEl.textContent = `â‚¹${hedgePrem} (30%)`;
                        }
                        
                        // Update hedge leg
                        const hedgeLegEl = document.querySelector('.hedge-example-item:nth-child(3) span');
                        if (hedgeLegEl) {
                            hedgeLegEl.textContent = `BUY ${spot - 200}PE @ â‚¹${Math.round(otmOption.pe_ltp)}`;
                        }
                        
                        // Update margin requirement
                        const marginEl = document.querySelector('.hedge-example-item:nth-child(4) span');
                        if (marginEl) {
                            const margin = Math.round((atmOption.pe_ltp - otmOption.pe_ltp) * 75 * 2);
                            marginEl.textContent = `â‚¹${margin.toLocaleString()}`;
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating hedge example:', error);
            }
        }
        
        // Load latest candles
        async function loadLatestCandles() {
            try {
                const response = await fetch(getApiUrl('/live/candles/latest?count=1'));
                const data = await response.json();
                
                if (data.success && data.candles && data.candles.length > 0) {
                    const lastCandle = data.candles[data.candles.length - 1];
                    const closeDisplay = document.getElementById('lastHourlyClose');
                    if (closeDisplay) {
                        closeDisplay.textContent = `Last 1H Close: ${lastCandle.close.toFixed(2)}`;
                    }
                }
            } catch (error) {
                console.error('Error loading candles:', error);
            }
        }

        // WebSocket connection for real-time updates - make it global
        window.initializeWebSocket = function() {
            // Close existing connection if any
            if (window.ws && window.ws.readyState === WebSocket.OPEN) {
                window.ws.close();
            }
            
            // Determine WebSocket URL based on current location
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.hostname || 'localhost';
            const port = window.location.port || '8000';
            const wsUrl = `${protocol}//${host}:${port}/ws/tradingview`;
            
            try {
                window.ws = new WebSocket(wsUrl);
            } catch (error) {
                console.error('WebSocket creation failed:', error);
                return;
            }
            
            window.ws.onopen = function() {
                console.log('WebSocket connected');
                updateConnectionStatus('tvStatus', true);
                updateBrokerStatus('tv', true);
                
                // Hide the alert loader spinner since we're connected
                const alertLoader = document.getElementById('alertLoader');
                if (alertLoader) {
                    alertLoader.style.display = 'none';
                }
            };

            window.ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };

            window.ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                updateConnectionStatus('tvStatus', false);
            };

            window.ws.onclose = function() {
                console.log('WebSocket disconnected');
                updateConnectionStatus('tvStatus', false);
                updateBrokerStatus('tv', false);
                // Attempt reconnection after 5 seconds
                setTimeout(initializeWebSocket, 5000);
            };
        }

        // Handle incoming WebSocket messages
        function handleWebSocketMessage(data) {
            switch(data.type) {
                case 'init':
                    // Initial data load from server
                    if (data.data) {
                        if (data.data.positions) {
                            positions = data.data.positions;
                            displayPositions();
                        }
                        if (data.data.spot_price) {
                            document.getElementById('spotPrice').textContent = data.data.spot_price.toFixed(2);
                        }
                    }
                    break;
                case 'alert':
                case 'signal':
                    // addAlertToStream will handle auto-execution internally if enabled
                    addAlertToStream(data.data || data);
                    // Process trade signal if auto-trade is enabled (but addAlertToStream already shows UI)
                    if (autoTradeEnabled && ((data.data && (data.data.action === 'Entry' || data.data.action === 'ENTRY')) || 
                                            (data.action === 'Entry' || data.action === 'ENTRY'))) {
                        processTradeSignal(data.data || data);
                    }
                    break;
                case 'position_created':
                case 'position_updated':
                    loadLivePositions();
                    break;
                case 'position_closed':
                    handlePositionClosed(data.data);
                    loadLivePositions();
                    break;
                case 'pnl_update':
                    updatePnL(data.data || data);
                    break;
                case 'breakeven_update':
                    updateBreakevenDisplay(data.data || data);
                    break;
                case 'spot_update':
                    if (data.data && data.data.price) {
                        document.getElementById('spotPrice').textContent = data.data.price.toFixed(2);
                    }
                    break;
                case 'candle_complete':
                    handleHourlyCandleClose(data.data);
                    break;
                case 'new_alert':
                    // Handle pending alert broadcast from server
                    console.log('[WebSocket] New pending alert received:', data.data);
                    if (data.data && data.data.status === 'PENDING') {
                        // Add the database ID if not present (for new alerts)
                        const pendingAlert = {
                            ...data.data,
                            id: data.data.id || Date.now(), // Use timestamp as fallback ID
                            webhook_data: {
                                signal: data.data.signal,
                                strike: data.data.strike,
                                type: data.data.option_type,
                                spot_price: data.data.spot_price
                            }
                        };
                        addPendingAlertToStream(pendingAlert);
                    }
                    break;
            }
        }

        // Add alert to stream
        function addAlertToStream(alert) {
            const stream = document.getElementById('alertStream');
            const alertId = `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            // CHECK IF SIGNAL IS ENABLED
            if (!isSignalEnabled(alert.signal)) {
                console.log(`Signal ${alert.signal} is DISABLED - Ignoring alert`);
                
                // Still show in stream but mark as ignored
                const ignoredHtml = `
                    <div class="alert-item" style="opacity: 0.4; border-color: var(--accent-red);">
                        <div class="alert-content">
                            <div class="alert-signal" style="text-decoration: line-through;">${alert.signal}: ${alert.description || 'Signal Triggered'}</div>
                            <div class="alert-details">Strike: ${alert.strike}${alert.type} | Action: ${alert.action}</div>
                        </div>
                        <div class="alert-actions-container">
                            <div class="alert-time">Just now</div>
                            <div style="color: var(--accent-red); font-weight: 600; font-size: 12px;">
                                IGNORED - Signal Disabled
                            </div>
                        </div>
                    </div>
                `;
                stream.insertAdjacentHTML('afterbegin', ignoredHtml);
                
                // Keep only last 10 alerts
                const alerts = stream.querySelectorAll('.alert-item');
                if (alerts.length > 10) {
                    alerts[alerts.length - 1].remove();
                }
                
                showNotification(`Alert for ${alert.signal} ignored - Signal is disabled`, 'warning');
                return; // Don't process further
            }
            
            // CHECK IF AUTO-TRADE IS ENABLED FOR ENTRY SIGNALS
            if (autoTradeEnabled && (alert.action === 'Entry' || alert.action === 'ENTRY')) {
                console.log('[AUTO-TRADE] Auto-executing signal:', alert.signal);
                
                // Show auto-execution notification in stream
                const autoExecHtml = `
                    <div class="alert-item" id="${alertId}" style="animation: slideIn 0.3s ease; border-left: 3px solid var(--accent-green); background: rgba(76, 175, 80, 0.1);">
                        <div class="alert-content" style="flex: 1;">
                            <div class="alert-signal" style="font-size: 14px; font-weight: 600; color: var(--accent-green);">
                                <i class="fas fa-robot"></i> AUTO-EXECUTING: ${alert.signal}
                            </div>
                            <div class="alert-details" style="margin: 8px 0;">
                                <div style="font-size: 13px; margin-bottom: 4px;">
                                    <strong>Strike:</strong> ${alert.strike}${alert.type} | 
                                    <strong>Spot:</strong> ${alert.spot_price || 'N/A'} | 
                                    <strong>Action:</strong> ${alert.action}
                                </div>
                                <div style="font-size: 11px; color: var(--accent-green); margin-top: 4px;">
                                    <i class="fas fa-spinner fa-spin"></i> Processing automatic execution...
                                </div>
                            </div>
                        </div>
                        <div class="alert-actions-container">
                            <div class="alert-time" style="font-size: 10px; color: var(--text-muted);">Just now</div>
                            <div style="color: var(--accent-green); font-size: 12px; font-weight: 600;">
                                <i class="fas fa-check-circle"></i> AUTO
                            </div>
                        </div>
                    </div>
                `;
                stream.insertAdjacentHTML('afterbegin', autoExecHtml);
                
                // Execute the trade automatically (processTradeSignal will be called from WebSocket handler)
                // Don't add to pendingAlerts since it's being auto-executed
                
                // Fade the notification after a few seconds
                setTimeout(() => {
                    const element = document.getElementById(alertId);
                    if (element) {
                        element.style.transition = 'opacity 0.5s';
                        element.style.opacity = '0.5';
                    }
                }, 5000);
                
                return; // Exit early - no manual actions needed
            }
            
            // For MANUAL mode or EXIT signals, store alert data for later use
            window.pendingAlerts = window.pendingAlerts || {};
            window.pendingAlerts[alertId] = alert;
            
            // Get current configuration for display
            const numLots = parseInt(document.getElementById('numLots').value) || 10;
            const totalQuantity = numLots * 75;
            const hedgeEnabled = document.getElementById('enableHedge')?.checked || false;
            const profitLockEnabled = document.getElementById('profitLockEnabled')?.checked || false;
            const profitTarget = profitLockEnabled ? parseFloat(document.getElementById('profitTarget')?.value || 10) : null;
            
            // Determine signal type for color coding
            const isBullish = ['S1', 'S2', 'S4', 'S7'].includes(alert.signal);
            const signalColor = isBullish ? 'var(--accent-green)' : 'var(--accent-red)';
            
            // Calculate estimated hedge strike (simplified - actual calculation happens on execution)
            let hedgeInfo = '';
            if (hedgeEnabled) {
                const hedgeOffset = alert.type === 'PE' ? -200 : 200;
                const estimatedHedgeStrike = alert.strike + hedgeOffset;
                hedgeInfo = `
                    <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                        <i class="fas fa-shield-alt"></i> Hedge: BUY ${estimatedHedgeStrike}${alert.type} (30% rule)
                    </div>
                `;
            }
            
            // Build comprehensive alert HTML
            const alertHtml = `
                <div class="alert-item" id="${alertId}" style="animation: slideIn 0.3s ease; border-left: 3px solid ${signalColor};">
                    <div class="alert-content" style="flex: 1;">
                        <div class="alert-signal" style="font-size: 14px; font-weight: 600; color: ${signalColor};">
                            ${alert.signal}: ${alert.description || 'Signal Triggered'}
                        </div>
                        <div class="alert-details" style="margin: 8px 0;">
                            <div style="font-size: 13px; margin-bottom: 4px;">
                                <strong>Main:</strong> SELL ${alert.strike}${alert.type} | 
                                <strong>Spot:</strong> ${alert.spot_price || 'N/A'} | 
                                <strong>Action:</strong> ${alert.action}
                            </div>
                            ${hedgeInfo}
                            <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                                <i class="fas fa-chart-bar"></i> Lots: ${numLots} (${totalQuantity} qty) | 
                                ${profitLockEnabled ? `<i class="fas fa-lock"></i> Profit Lock: ${profitTarget}% | ` : ''}
                                <i class="fas fa-rupee-sign"></i> Est. Margin: â‚¹${(numLots * 15000).toLocaleString()}
                            </div>
                        </div>
                        ${!autoTradeEnabled && (alert.action === 'Entry' || alert.action === 'ENTRY') ? `
                            <details style="margin-top: 8px;">
                                <summary style="cursor: pointer; font-size: 11px; color: var(--accent-blue);">
                                    View Trade Configuration
                                </summary>
                                <div style="margin-top: 8px; padding: 8px; background: var(--bg-tertiary); border-radius: 4px; font-size: 11px;">
                                    <div><strong>Entry Timing:</strong> ${document.getElementById('entryTiming')?.value || 'immediate'}</div>
                                    <div><strong>Stop Loss:</strong> At strike price (${alert.strike})</div>
                                    ${profitLockEnabled ? `<div><strong>Profit Lock:</strong> ${profitTarget}% target, ${document.getElementById('profitLock')?.value || 5}% lock</div>` : ''}
                                    ${document.getElementById('trailingStopEnabled')?.checked ? `<div><strong>Trailing Stop:</strong> ${document.getElementById('trailPercent')?.value || 1}% trail</div>` : ''}
                                    <div><strong>Max Risk:</strong> â‚¹${(numLots * 75 * 200).toLocaleString()} (if hedge enabled)</div>
                                </div>
                            </details>
                        ` : ''}
                    </div>
                    <div class="alert-actions-container" style="min-width: 120px;">
                        <div class="alert-time" style="font-size: 10px; color: var(--text-muted); margin-bottom: 8px;">Just now</div>
                        ${!autoTradeEnabled && (alert.action === 'Entry' || alert.action === 'ENTRY') ? `
                            <div class="alert-actions" style="display: flex; flex-direction: column; gap: 4px;">
                                <button class="btn-alert-action btn-execute" onclick="executeManualTrade('${alertId}')" style="background: var(--accent-green); font-size: 12px; padding: 6px 12px;">
                                    <i class="fas fa-play"></i> Execute
                                </button>
                                <button class="btn-alert-action btn-modify" onclick="modifyAlert('${alertId}')" style="background: var(--accent-blue); font-size: 12px; padding: 4px 12px;">
                                    <i class="fas fa-edit"></i> Modify
                                </button>
                                <button class="btn-alert-action btn-cancel" onclick="cancelAlert('${alertId}')" style="background: var(--accent-red); font-size: 12px; padding: 4px 12px;">
                                    <i class="fas fa-times"></i> Cancel
                                </button>
                            </div>
                        ` : autoTradeEnabled ? '<div style="color: var(--accent-green); font-size: 11px;"><i class="fas fa-robot"></i> Auto-Execute</div>' : ''}
                    </div>
                </div>
            `;
            stream.insertAdjacentHTML('afterbegin', alertHtml);
            
            // Keep only last 10 alerts
            const alerts = stream.querySelectorAll('.alert-item');
            if (alerts.length > 10) {
                alerts[alerts.length - 1].remove();
            }
            
            // Update pending alerts count
            updatePendingAlertsCount();
        }

        // Process trade signal
        async function processTradeSignal(signal) {
            if (!autoTradeEnabled) return;
            
            // CHECK IF SIGNAL IS ENABLED
            if (!isSignalEnabled(signal.signal)) {
                console.log(`Signal ${signal.signal} is DISABLED - Not auto-executing`);
                showNotification(`Auto-trade blocked for ${signal.signal} - Signal is disabled`, 'warning');
                return;
            }

            try {
                // Calculate hedge strike based on configuration
                const hedgeStrike = await calculateHedgeStrike(signal.strike, signal.type);
                
                // Place orders
                const response = await fetch(getApiUrl('/api/execute-trade'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        signal: signal,
                        hedgeStrike: hedgeStrike,
                        lots: document.getElementById('numLots').value,
                        mode: currentMode
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showNotification('Trade executed successfully', 'success');
                    updatePositions();
                } else {
                    showNotification('Trade execution failed: ' + result.message, 'error');
                }
            } catch (error) {
                showNotification('Error processing trade: ' + error.message, 'error');
            }
        }

        // Manual trade execution
        window.executeManualTrade = async function(alertId) {
            const alert = window.pendingAlerts[alertId];
            if (!alert) {
                showNotification('Alert not found', 'error');
                return;
            }
            
            // Immediately disable all buttons to prevent double-click
            const alertElement = document.getElementById(alertId);
            const executeBtn = alertElement.querySelector('.btn-execute');
            const allButtons = alertElement.querySelectorAll('.btn-alert-action');
            
            allButtons.forEach(btn => {
                btn.disabled = true;
            });
            
            // Show loading state
            const originalBtnHTML = executeBtn.innerHTML;
            executeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Executing...';
            
            // Get current settings
            const numLots = parseInt(document.getElementById('numLots').value) || 10;
            const totalQuantity = numLots * 75;
            const hedgeEnabled = document.getElementById('enableHedge')?.checked || false;
            const hedgeStrike = hedgeEnabled ? await calculateHedgeStrike(alert.strike, alert.type) : null;
            
            // Build confirmation message with full details
            let confirmMsg = `Execute ${alert.signal} ${alert.strike}${alert.type}?\n\n`;
            confirmMsg += `Main Leg: SELL ${alert.strike}${alert.type}\n`;
            if (hedgeEnabled && hedgeStrike) {
                confirmMsg += `Hedge Leg: BUY ${hedgeStrike}${alert.type}\n`;
            }
            confirmMsg += `\nLots: ${numLots} (${totalQuantity} qty)\n`;
            confirmMsg += `\nThis will use REAL money!`;
            
            // Confirmation dialog
            if (!confirm(confirmMsg)) {
                // Re-enable buttons if cancelled
                allButtons.forEach(btn => {
                    btn.disabled = false;
                });
                executeBtn.innerHTML = originalBtnHTML;
                return;
            }
            
            try {
                // Use existing executeTrade function
                const success = await executeTrade(alert.signal, alert.strike, alert.type, alert.action);
                
                if (success) {
                    // Mark alert as executed
                    alertElement.classList.add('executed');
                    alertElement.style.opacity = '0.7';
                    alertElement.style.borderColor = 'var(--accent-green)';
                    
                    // Update button text to show success
                    executeBtn.innerHTML = '<i class="fas fa-check"></i> Executed';
                    executeBtn.style.background = 'var(--accent-green)';
                    
                    showNotification(`Trade executed: ${alert.signal}`, 'success');
                    
                    // Remove from pending
                    delete window.pendingAlerts[alertId];
                    
                    // Reload positions
                    loadLivePositions();
                    updatePendingAlertsCount();
                }
            } catch (error) {
                console.error('Manual execution failed:', error);
                showNotification('Execution failed: ' + error.message, 'error');
                
                // Re-enable buttons on error
                allButtons.forEach(btn => {
                    btn.disabled = false;
                });
                executeBtn.innerHTML = originalBtnHTML;
            }
        }
        
        // Modify alert parameters
        window.modifyAlert = async function(alertId) {
    const alert = window.pendingAlerts[alertId];
    if (!alert) {
        showNotification('Alert not found', 'error');
        return;
    }
    
    // Get current configuration
    const hedgeEnabled = document.getElementById('enableHedge')?.checked || false;
    const currentLots = parseInt(document.getElementById('numLots').value) || 10;
    const hedgeOffset = 200; // Default hedge offset
    
    // Calculate initial hedge strike
    const initialHedgeStrike = alert.type === 'PE' ? alert.strike - hedgeOffset : alert.strike + hedgeOffset;
    
    // Create comprehensive modify dialog with hedge details
    const modalHtml = `
        <div id="modifyModal" class="modal" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000;">
            <div class="modal-content" style="max-width: 550px; margin: 40px auto; background: var(--bg-secondary); border-radius: 12px; padding: 25px; max-height: 85vh; overflow-y: auto; border: 1px solid var(--border-color);">
                <h3 style="margin: 0 0 20px 0; color: var(--text-primary); display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-edit" style="color: var(--accent-blue);"></i>
                    Modify Alert: ${alert.signal} - ${alert.description || ''}
                </h3>
                
                <!-- Main Position Section -->
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; border-left: 3px solid var(--accent-yellow);">
                    <h4 style="margin: 0 0 15px 0; color: var(--accent-yellow); font-size: 14px;">
                        <i class="fas fa-chart-line"></i> Main Position (SELL)
                    </h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div class="form-group">
                            <label style="font-size: 12px; color: var(--text-muted);">Strike Price</label>
                            <input type="number" id="modifyStrike" value="${alert.strike}" step="50" class="form-control" 
                                   style="padding: 8px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);" 
                                   onchange="updateModifyPreview()">
                        </div>
                        <div class="form-group">
                            <label style="font-size: 12px; color: var(--text-muted);">Option Type</label>
                            <select id="modifyType" class="form-control" 
                                    style="padding: 8px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);" 
                                    onchange="updateModifyPreview()">
                                <option value="PE" ${alert.type === 'PE' ? 'selected' : ''}>PUT (PE)</option>
                                <option value="CE" ${alert.type === 'CE' ? 'selected' : ''}>CALL (CE)</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 10px;">
                        <label style="font-size: 12px; color: var(--text-muted);">Number of Lots</label>
                        <input type="number" id="modifyLots" value="${currentLots}" min="1" max="30" class="form-control" 
                               style="padding: 8px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);" 
                               onchange="updateModifyPreview()">
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color);">
                        <span style="font-size: 12px; color: var(--text-muted);">Total Quantity:</span>
                        <span id="totalQtyPreview" style="font-size: 12px; font-weight: 600; color: var(--text-primary);">${currentLots * 75}</span>
                    </div>
                </div>
                
                <!-- Hedge Configuration Section -->
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; margin-top: 15px; border-left: 3px solid var(--accent-green);">
                    <h4 style="margin: 0 0 15px 0; color: var(--accent-green); font-size: 14px;">
                        <i class="fas fa-shield-alt"></i> Hedge Protection (BUY)
                    </h4>
                    <div class="form-group">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px;">
                            <input type="checkbox" id="modifyHedgeEnabled" ${hedgeEnabled ? 'checked' : ''} onchange="toggleModifyHedge()">
                            <span>Enable Hedge (30% Premium Rule)</span>
                        </label>
                    </div>
                    <div id="modifyHedgeDetails" style="${hedgeEnabled ? '' : 'display: none;'} margin-top: 15px;">
                        <div style="background: var(--bg-primary); padding: 12px; border-radius: 6px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="font-size: 12px; color: var(--text-muted);">Hedge Strike:</span>
                                <span id="hedgeStrikeDisplay" style="font-size: 13px; font-weight: 600; color: var(--accent-green);">
                                    ${initialHedgeStrike}${alert.type}
                                </span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="font-size: 12px; color: var(--text-muted);">Offset from Main:</span>
                                <span style="font-size: 13px; color: var(--text-primary);">${hedgeOffset} points</span>
                            </div>
                        </div>
                        <div style="margin-top: 10px; padding: 8px; background: rgba(34, 197, 94, 0.1); border-radius: 4px; font-size: 11px; color: var(--text-muted);">
                            <i class="fas fa-info-circle"></i> Hedge will be selected based on 30% of main leg premium
                        </div>
                    </div>
                </div>
                
                <!-- Trade Summary Section -->
                <div style="background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-primary)); padding: 15px; border-radius: 8px; margin-top: 15px; border: 1px solid var(--accent-blue);">
                    <h4 style="margin: 0 0 15px 0; color: var(--accent-blue); font-size: 14px;">
                        <i class="fas fa-clipboard-check"></i> Trade Summary
                    </h4>
                    <div id="modifyTradeSummary" style="font-size: 13px; line-height: 1.8;">
                        <div style="display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid var(--border-color);">
                            <span style="color: var(--text-muted);">Main Leg:</span>
                            <span style="font-weight: 600;">SELL <span id="summaryMainStrike">${alert.strike}</span><span id="summaryMainType">${alert.type}</span></span>
                        </div>
                        <div id="summaryHedgeRow" style="${hedgeEnabled ? '' : 'display: none;'} display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid var(--border-color);">
                            <span style="color: var(--text-muted);">Hedge Leg:</span>
                            <span style="font-weight: 600; color: var(--accent-green);">BUY <span id="summaryHedgeStrike">${initialHedgeStrike}</span><span id="summaryHedgeType">${alert.type}</span></span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid var(--border-color);">
                            <span style="color: var(--text-muted);">Position Size:</span>
                            <span><span id="summaryLots">${currentLots}</span> lots (<span id="summaryQty">${currentLots * 75}</span> qty)</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid var(--border-color);">
                            <span style="color: var(--text-muted);">Est. Margin:</span>
                            <span>â‚¹<span id="summaryMargin">${(currentLots * 15000).toLocaleString()}</span></span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 5px 0;">
                            <span style="color: var(--text-muted);">Max Risk:</span>
                            <span style="color: var(--accent-red); font-weight: 600;">
                                â‚¹<span id="summaryRisk">${hedgeEnabled ? (currentLots * 75 * hedgeOffset).toLocaleString() : 'Unlimited'}</span>
                            </span>
                        </div>
                    </div>
                </div>
                
                <!-- Stop Loss Configuration (Optional) -->
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; margin-top: 15px; border-left: 3px solid var(--accent-red);">
                    <h4 style="margin: 0 0 15px 0; color: var(--accent-red); font-size: 14px;">
                        <i class="fas fa-stop-circle"></i> Stop Loss Settings
                    </h4>
                    <div style="font-size: 12px; line-height: 1.8; color: var(--text-muted);">
                        <div>â€¢ Stop Loss: At main strike (${alert.strike})</div>
                        <div>â€¢ Entry Timing: ${document.getElementById('entryTiming')?.value || 'Immediate'}</div>
                        ${document.getElementById('profitLockEnabled')?.checked ? 
                            `<div>â€¢ Profit Lock: ${document.getElementById('profitTarget')?.value || 10}% target</div>` : ''}
                        ${document.getElementById('trailingStopEnabled')?.checked ? 
                            `<div>â€¢ Trailing Stop: ${document.getElementById('trailPercent')?.value || 1}% trail</div>` : ''}
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="modal-buttons" style="display: flex; gap: 10px; margin-top: 20px;">
                    <button onclick="confirmModify('${alertId}')" class="btn btn-primary" 
                            style="flex: 1; padding: 12px; background: var(--accent-green); border: none; border-radius: 6px; color: white; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                        <i class="fas fa-check"></i> Confirm Changes
                    </button>
                    <button onclick="closeModifyModal()" class="btn btn-secondary" 
                            style="flex: 1; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); font-weight: 600; cursor: pointer; transition: all 0.2s;">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Add modal to page
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // Add update functions
    window.updateModifyPreview = function() {
        const strike = parseInt(document.getElementById('modifyStrike').value);
        const type = document.getElementById('modifyType').value;
        const lots = parseInt(document.getElementById('modifyLots').value);
        const hedgeEnabled = document.getElementById('modifyHedgeEnabled').checked;
        
        // Update quantities
        document.getElementById('totalQtyPreview').textContent = lots * 75;
        
        // Update hedge display
        if (hedgeEnabled) {
            const hedgeStrike = type === 'PE' ? strike - hedgeOffset : strike + hedgeOffset;
            document.getElementById('hedgeStrikeDisplay').textContent = hedgeStrike + type;
            document.getElementById('summaryHedgeStrike').textContent = hedgeStrike;
            document.getElementById('summaryHedgeType').textContent = type;
        }
        
        // Update summary
        document.getElementById('summaryMainStrike').textContent = strike;
        document.getElementById('summaryMainType').textContent = type;
        document.getElementById('summaryLots').textContent = lots;
        document.getElementById('summaryQty').textContent = lots * 75;
        document.getElementById('summaryMargin').textContent = (lots * 15000).toLocaleString();
        document.getElementById('summaryRisk').textContent = hedgeEnabled ? 
            (lots * 75 * hedgeOffset).toLocaleString() : 'Unlimited';
    };
    
    window.toggleModifyHedge = function() {
        const hedgeEnabled = document.getElementById('modifyHedgeEnabled').checked;
        document.getElementById('modifyHedgeDetails').style.display = hedgeEnabled ? 'block' : 'none';
        document.getElementById('summaryHedgeRow').style.display = hedgeEnabled ? 'flex' : 'none';
        updateModifyPreview();
    };
}
        
        window.confirmModify = function(alertId) {
    const alert = window.pendingAlerts[alertId];
    const newStrike = parseInt(document.getElementById('modifyStrike').value);
    const newType = document.getElementById('modifyType').value;
    const newLots = parseInt(document.getElementById('modifyLots').value);
    const hedgeEnabled = document.getElementById('modifyHedgeEnabled').checked;
    
    // Update alert data
    alert.strike = newStrike;
    alert.type = newType;
    alert.hedgeEnabled = hedgeEnabled;
    window.tempLots = newLots; // Store for execution
    
    // Calculate hedge details for display
    const hedgeOffset = 200;
    const hedgeStrike = hedgeEnabled ? (newType === 'PE' ? newStrike - hedgeOffset : newStrike + hedgeOffset) : null;
    
    // Update display with complete details
    const alertElement = document.getElementById(alertId);
    if (alertElement) {
        const detailsHtml = `
            <div style="font-size: 13px; margin-bottom: 4px;">
                <strong>Main:</strong> SELL ${newStrike}${newType} | 
                <strong>Spot:</strong> ${alert.spot_price || 'N/A'} | 
                <strong>Action:</strong> ${alert.action}
            </div>
            ${hedgeEnabled ? `
                <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                    <i class="fas fa-shield-alt"></i> Hedge: BUY ${hedgeStrike}${newType} (30% rule)
                </div>
            ` : ''}
            <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                <i class="fas fa-chart-bar"></i> Lots: ${newLots} (${newLots * 75} qty) | 
                <i class="fas fa-rupee-sign"></i> Est. Margin: â‚¹${(newLots * 15000).toLocaleString()}
            </div>
            <div style="color: var(--accent-yellow); font-size: 11px; margin-top: 4px;">
                <i class="fas fa-edit"></i> Modified at ${new Date().toLocaleTimeString()}
            </div>
        `;
        
        alertElement.querySelector('.alert-details').innerHTML = detailsHtml;
        
        // Add modified indicator
        alertElement.style.borderColor = 'var(--accent-yellow)';
        alertElement.style.background = 'rgba(255, 193, 7, 0.05)';
    }
    
    closeModifyModal();
    showNotification('Alert modified successfully with hedge configuration', 'success');
}
        
        window.closeModifyModal = function() {
            document.getElementById('modifyModal')?.remove();
        }
        
        // Cancel alert
        window.cancelAlert = function(alertId) {
            if (!confirm('Cancel this alert? It will not be executed.')) {
                return;
            }
            
            const alertElement = document.getElementById(alertId);
            if (alertElement) {
                // Mark as cancelled
                alertElement.classList.add('cancelled');
                
                // Disable all buttons
                document.querySelectorAll(`#${alertId} .btn-alert-action`).forEach(btn => {
                    btn.disabled = true;
                });
                
                // Update display
                const cancelBtn = document.querySelector(`#${alertId} .btn-cancel`);
                if (cancelBtn) {
                    cancelBtn.innerHTML = '<i class="fas fa-ban"></i> Cancelled';
                }
                
                // Remove from pending
                delete window.pendingAlerts[alertId];
                
                showNotification('Alert cancelled', 'warning');
                updatePendingAlertsCount();
            }
        }
        
        // Update pending alerts count
        function updatePendingAlertsCount() {
            const pendingCount = Object.keys(window.pendingAlerts || {}).length;
            // You can add a visual indicator in the header if needed
            console.log(`Pending alerts: ${pendingCount}`);
        }
        
        // Load pending alerts from API
        async function loadPendingAlerts() {
            console.log('[PENDING ALERTS] Starting to load pending alerts...');
            try {
                const url = getApiUrl('/api/pending-alerts');
                console.log('[PENDING ALERTS] Fetching from:', url);
                const response = await fetch(url);
                const data = await response.json();
                console.log('[PENDING ALERTS] Response:', data);

                // Clear existing pending alerts from UI first
                const stream = document.getElementById('alertStream');
                if (stream) {
                    // Remove only pending alert elements (keep executed ones)
                    const pendingElements = stream.querySelectorAll('.alert-item[data-type="pending"]');
                    pendingElements.forEach(el => el.remove());
                }

                if (data.status === 'success' && data.alerts) {
                    console.log(`[PENDING ALERTS] Found ${data.pending_count} pending alerts`);
                    
                    // Display each pending alert in the stream
                    data.alerts.forEach(alert => {
                        // Reconstruct alert for display
                        const reconstructedAlert = {
                            id: alert.id,  // IMPORTANT: Include database ID
                            alert_id: alert.alert_id,
                            signal: alert.signal,
                            strike: alert.strike,
                            type: alert.option_type,
                            action: 'ENTRY',
                            spot_price: alert.spot_price,
                            timestamp: alert.timestamp,
                            isPending: true
                        };

                        // Add to stream with pending status
                        addPendingAlertToStream(reconstructedAlert);
                    });
                    
                    if (data.pending_count > 0) {
                        showNotification(`${data.pending_count} pending alerts loaded`, 'info');
                    }
                }
            } catch (error) {
                console.error('[PENDING ALERTS] Error loading pending alerts:', error);
            }
        }
        
        // Add pending alert to stream (similar to addAlertToStream but for pending alerts)
        function addPendingAlertToStream(alert) {
            console.log('[PENDING ALERTS] Adding alert to stream:', alert);
            console.log('[PENDING ALERTS] Alert has database ID:', alert.id);
            console.log('[PENDING ALERTS] Alert has alert_id:', alert.alert_id);

            const stream = document.getElementById('alertStream');
            if (!stream) {
                console.error('[PENDING ALERTS] Alert stream element not found!');
                return;
            }
            const alertId = alert.alert_id;
            const dbId = alert.id;  // Database ID for API calls

            if (!dbId) {
                console.error('[PENDING ALERTS] WARNING: Alert missing database ID!', alert);
            }

            // Store in window.pendingAlerts
            window.pendingAlerts = window.pendingAlerts || {};
            window.pendingAlerts[alertId] = alert;

            // Also create a dbId to alertId mapping for easier lookup
            window.pendingAlertsByDbId = window.pendingAlertsByDbId || {};
            window.pendingAlertsByDbId[dbId] = alertId;

            console.log('[PENDING ALERTS] Stored alert with key:', alertId, 'and DB ID:', dbId);
            
            const signalDescriptions = {
                'S1': 'Bear Trap',
                'S2': 'Support Hold',
                'S3': 'Resistance Hold',
                'S4': 'Bias Failure Bull',
                'S5': 'Bias Failure Bear',
                'S6': 'Weakness Confirmed',
                'S7': 'Breakout Confirmed',
                'S8': 'Breakdown Confirmed'
            };
            
            const description = signalDescriptions[alert.signal] || 'Signal Triggered';
            const isBullish = ['S1', 'S2', 'S4', 'S7'].includes(alert.signal);
            const signalColor = isBullish ? 'var(--accent-green)' : 'var(--accent-red)';
            
            const alertHtml = `
                <div class="alert-item" id="${alertId}" data-type="pending" style="border-left: 3px solid ${signalColor}; border-right: 3px solid var(--accent-yellow);">
                    <div class="alert-content" style="flex: 1;">
                        <div class="alert-signal" style="font-size: 14px; font-weight: 600; color: ${signalColor};">
                            ${alert.signal}: ${description}
                            <span style="color: var(--accent-yellow); margin-left: 10px; font-size: 12px;">
                                <i class="fas fa-clock"></i> PENDING
                            </span>
                        </div>
                        <div class="alert-details" style="margin: 8px 0;">
                            <div style="font-size: 13px;">
                                <strong>Strike:</strong> ${alert.strike}${alert.type} | 
                                <strong>Spot:</strong> ${alert.spot_price || 'N/A'}
                            </div>
                            <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                                Received: ${new Date(alert.timestamp).toLocaleTimeString()}
                            </div>
                        </div>
                    </div>
                    <div class="alert-actions-container">
                        <div class="alert-actions" style="display: flex; flex-direction: column; gap: 4px;">
                            <button class="btn-alert-action btn-execute" onclick="executePendingAlert('${dbId}')" style="background: var(--accent-green);">
                                <i class="fas fa-play"></i> Execute
                            </button>
                            <button class="btn-alert-action btn-modify" onclick="modifyPendingAlert('${dbId}')" style="background: var(--accent-blue);">
                                <i class="fas fa-edit"></i> Modify
                            </button>
                            <button class="btn-alert-action btn-cancel" onclick="cancelPendingAlert('${dbId}')" style="background: var(--accent-red);">
                                <i class="fas fa-times"></i> Cancel
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            stream.insertAdjacentHTML('afterbegin', alertHtml);
        }
        
        // Execute pending alert using API
        window.executePendingAlert = async function(dbId) {
            console.log('[EXECUTE] Looking for alert with DB ID:', dbId);

            // Use the dbId mapping to find the alertId
            const alertIdFromMapping = window.pendingAlertsByDbId && window.pendingAlertsByDbId[dbId];
            console.log('[EXECUTE] Alert ID from mapping:', alertIdFromMapping);

            let alertElement = null;
            let alertIdToDelete = null;

            if (alertIdFromMapping) {
                // Found via mapping
                alertElement = document.getElementById(alertIdFromMapping);
                alertIdToDelete = alertIdFromMapping;
                console.log('[EXECUTE] Found alert via mapping:', alertIdFromMapping);
            } else {
                // Fallback: search through all alerts
                console.log('[EXECUTE] No mapping found, searching all alerts...');
                for (const [alertId, alert] of Object.entries(window.pendingAlerts || {})) {
                    console.log(`[EXECUTE] Checking alert ${alertId}, has ID: ${alert.id}, comparing with ${dbId}`);
                    if (alert.id == dbId || alert.id === parseInt(dbId)) {
                        alertElement = document.getElementById(alertId);
                        alertIdToDelete = alertId;
                        console.log('[EXECUTE] Found matching alert:', alertId);
                        break;
                    }
                }
            }

            if (!alertElement) {
                console.error('[EXECUTE] Alert element not found for DB ID:', dbId);
                console.error('[EXECUTE] Available mappings:', window.pendingAlertsByDbId);
                console.error('[EXECUTE] Available alerts:', Object.keys(window.pendingAlerts || {}));
                showNotification('Alert element not found', 'error');
                return;
            }

            const buttons = alertElement.querySelectorAll('.btn-alert-action');

            // Disable buttons
            buttons.forEach(btn => btn.disabled = true);

            const executeBtn = alertElement.querySelector('.btn-execute');
            executeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Executing...';

            try {
                const response = await fetch(getApiUrl(`/api/pending-alerts/${dbId}/execute`), {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();

                if (result.status === 'success' || result.webhook_id) {
                    showNotification('Alert executed successfully', 'success');
                    alertElement.style.opacity = '0.5';
                    alertElement.style.borderColor = 'var(--accent-green)';
                    executeBtn.innerHTML = '<i class="fas fa-check"></i> Executed';

                    // Remove alert after a short delay
                    setTimeout(() => {
                        alertElement.style.transition = 'all 0.3s ease';
                        alertElement.style.transform = 'translateX(100%)';
                        setTimeout(() => {
                            alertElement.remove();
                            if (alertIdToDelete) {
                                delete window.pendingAlerts[alertIdToDelete];
                                // Also clean up the dbId mapping
                                if (window.pendingAlertsByDbId) {
                                    for (const [id, aId] of Object.entries(window.pendingAlertsByDbId)) {
                                        if (aId === alertIdToDelete) {
                                            delete window.pendingAlertsByDbId[id];
                                            break;
                                        }
                                    }
                                }
                            }
                        }, 300);
                    }, 1000);
                } else {
                    showNotification('Execution failed: ' + (result.message || 'Unknown error'), 'error');
                    buttons.forEach(btn => btn.disabled = false);
                    executeBtn.innerHTML = '<i class="fas fa-play"></i> Execute';
                }
            } catch (error) {
                showNotification('Error executing alert: ' + error.message, 'error');
                buttons.forEach(btn => btn.disabled = false);
                executeBtn.innerHTML = '<i class="fas fa-play"></i> Execute';
            }
        };
        
        // Modify pending alert
        window.modifyPendingAlert = async function(dbId) {
            // Find alert using dbId similar to execute function
            const alertIdFromMapping = window.pendingAlertsByDbId && window.pendingAlertsByDbId[dbId];
            let alert = null;
            let alertId = null;

            if (alertIdFromMapping) {
                alert = window.pendingAlerts[alertIdFromMapping];
                alertId = alertIdFromMapping;
            } else {
                // Fallback: search through all alerts
                for (const [aId, a] of Object.entries(window.pendingAlerts || {})) {
                    if (a.id == dbId || a.id === parseInt(dbId)) {
                        alert = a;
                        alertId = aId;
                        break;
                    }
                }
            }

            if (!alert) {
                showNotification('Alert not found', 'error');
                return;
            }

            // Store for later use
            window.tempDbId = dbId;
            window.tempAlertId = alertId;
            window.tempAlert = alert;

            // Create and show modify modal
            showModifyModal(alert, dbId, alertId);
        };

        // Show modify modal
        function showModifyModal(alert, dbId, alertId) {
            // Remove existing modal if any
            const existingModal = document.getElementById('modifyModal');
            if (existingModal) existingModal.remove();

            const modalHtml = `
                <div id="modifyModal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center;">
                    <div style="background: var(--background-light); border-radius: 12px; padding: 24px; width: 400px; max-width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                        <h3 style="margin: 0 0 20px 0; color: var(--text-primary); font-size: 18px;">
                            Modify Pending Alert - ${alert.signal}
                        </h3>

                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px;">Strike Price</label>
                            <input type="number" id="newModifyStrike" value="${alert.strike}" step="50" style="width: 100%; padding: 10px; background: var(--background-dark); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary);">
                        </div>

                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px;">Option Type</label>
                            <select id="newModifyType" style="width: 100%; padding: 10px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; color: #ffffff; font-size: 14px; cursor: pointer;">
                                <option value="PE" style="background: #1a1a1a; color: #ffffff;">PUT (PE)</option>
                                <option value="CE" style="background: #1a1a1a; color: #ffffff;">CALL (CE)</option>
                            </select>
                        </div>

                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px;">Number of Lots (Cannot be modified)</label>
                            <input type="number" id="newModifyLots" value="${alert.lots || 1}" min="1" max="50" disabled style="width: 100%; padding: 10px; background: #0a0a0a; border: 1px solid #222; border-radius: 6px; color: #666; cursor: not-allowed; opacity: 0.7;">
                        </div>

                        <div style="margin-bottom: 16px; padding: 12px; background: var(--background-dark); border-radius: 6px;">
                            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Hedge Configuration</div>
                            <div style="font-size: 14px; color: var(--text-primary);" id="hedgeConfigInfo">
                                <i class="fas fa-shield-alt" style="color: var(--accent-green);"></i>
                                Loading hedge configuration...
                            </div>
                        </div>

                        <div style="display: flex; gap: 12px; justify-content: flex-end;">
                            <button onclick="closeModifyModal()" style="padding: 10px 20px; background: var(--background-dark); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); cursor: pointer;">
                                Cancel
                            </button>
                            <button onclick="confirmModify()" style="padding: 10px 20px; background: var(--accent-blue); border: none; border-radius: 6px; color: white; cursor: pointer;">
                                <i class="fas fa-check"></i> Modify Alert
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);

            // Set the selected option type after modal is inserted
            const selectElement = document.getElementById('newModifyType');
            if (selectElement) {
                const currentType = alert.type || alert.option_type || 'PE';
                selectElement.value = currentType;
            }

            // Load and display actual hedge configuration
            const hedgeConfigDiv = document.getElementById('hedgeConfigInfo');
            if (hedgeConfigDiv) {
                // Load configuration from API
                fetch(getApiUrl('/api/config'))
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(config => {
                        console.log('Loaded hedge config:', config);
                        const hedgeEnabled = config.hedge_enabled;
                        const hedgeMethod = config.hedge_method || 'percentage';
                        const hedgePercent = config.hedge_percent || 30;
                        const hedgeOffset = config.hedge_offset || 200;

                        let hedgeText = '';
                        if (!hedgeEnabled) {
                            hedgeText = '<i class="fas fa-times-circle" style="color: var(--accent-red);"></i> Hedge is disabled';
                        } else if (hedgeMethod === 'percentage') {
                            hedgeText = `<i class="fas fa-shield-alt" style="color: var(--accent-green);"></i> Hedge at ${hedgePercent}% away from strike`;
                        } else {
                            hedgeText = `<i class="fas fa-shield-alt" style="color: var(--accent-green);"></i> Hedge at ${hedgeOffset} points away`;
                        }

                        hedgeConfigDiv.innerHTML = hedgeText;
                    })
                    .catch(error => {
                        console.error('Error loading hedge config:', error);
                        // Use default values if API fails
                        hedgeConfigDiv.innerHTML = '<i class="fas fa-shield-alt" style="color: var(--accent-green);"></i> Hedge at 30% away from strike (default)';
                    });
            }
        }

        // Confirm modify
        window.confirmModify = async function() {
            const newStrike = document.getElementById('newModifyStrike').value;
            const newType = document.getElementById('newModifyType').value;
            const newLots = document.getElementById('newModifyLots').value;

            if (!newStrike) {
                showNotification('Please enter strike price', 'error');
                return;
            }

            try {
                const response = await fetch(getApiUrl(`/api/pending-alerts/${window.tempDbId}/modify`), {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        strike: parseInt(newStrike),
                        lots: parseInt(newLots),
                        option_type: newType
                    })
                });

                const result = await response.json();

                if (result.status === 'success') {
                    showNotification('Alert modified successfully', 'success');

                    // Update display
                    const alertElement = document.getElementById(window.tempAlertId);
                    if (alertElement) {
                        const detailsDiv = alertElement.querySelector('.alert-details div');
                        if (detailsDiv) {
                            detailsDiv.innerHTML = `<strong>Strike:</strong> ${newStrike}${newType} | <strong>Lots:</strong> ${newLots}`;
                        }
                        // Add modified indicator
                        alertElement.style.borderColor = 'var(--accent-yellow)';
                    }

                    // Update local data
                    if (window.pendingAlerts[window.tempAlertId]) {
                        window.pendingAlerts[window.tempAlertId].strike = parseInt(newStrike);
                        window.pendingAlerts[window.tempAlertId].lots = parseInt(newLots);
                        window.pendingAlerts[window.tempAlertId].type = newType;
                        window.pendingAlerts[window.tempAlertId].option_type = newType;
                    }

                    // Close modal
                    closeModifyModal();
                } else {
                    showNotification('Modification failed: ' + result.message, 'error');
                }
            } catch (error) {
                showNotification('Error modifying alert: ' + error.message, 'error');
            }
        };

        // Close modify modal
        window.closeModifyModal = function() {
            const modal = document.getElementById('modifyModal');
            if (modal) {
                modal.style.opacity = '0';
                setTimeout(() => modal.remove(), 200);
            }
        };

        // Cancel pending alert
        window.cancelPendingAlert = async function(dbId) {
            if (!confirm('Cancel this pending alert?')) return;

            // Use the dbId mapping to find the alertId
            const alertIdFromMapping = window.pendingAlertsByDbId && window.pendingAlertsByDbId[dbId];

            let alertElement = null;
            let alertIdToDelete = null;

            if (alertIdFromMapping) {
                alertElement = document.getElementById(alertIdFromMapping);
                alertIdToDelete = alertIdFromMapping;
            } else {
                // Fallback: search through all alerts
                for (const [alertId, alert] of Object.entries(window.pendingAlerts || {})) {
                    if (alert.id == dbId || alert.id === parseInt(dbId)) {
                        alertElement = document.getElementById(alertId);
                        alertIdToDelete = alertId;
                        break;
                    }
                }
            }

            if (!alertElement) {
                showNotification('Alert element not found', 'error');
                return;
            }

            try {
                const response = await fetch(getApiUrl(`/api/pending-alerts/${dbId}/cancel`), {
                    method: 'POST'
                });

                const result = await response.json();

                if (result.status === 'success') {
                    showNotification('Alert cancelled', 'info');
                    alertElement.style.opacity = '0.3';
                    alertElement.style.textDecoration = 'line-through';
                    alertElement.querySelectorAll('button').forEach(btn => btn.remove());
                    if (alertIdToDelete) {
                        delete window.pendingAlerts[alertIdToDelete];
                        // Also clean up the dbId mapping
                        if (window.pendingAlertsByDbId) {
                            for (const [dbId, alertId] of Object.entries(window.pendingAlertsByDbId)) {
                                if (alertId === alertIdToDelete) {
                                    delete window.pendingAlertsByDbId[dbId];
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    showNotification('Cancellation failed: ' + result.message, 'error');
                }
            } catch (error) {
                showNotification('Error cancelling alert: ' + error.message, 'error');
            }
        };
        
        // Initialize auto trade status indicator
        function initializeAutoTradeStatus() {
            // Use the existing updateTradingModeDisplay function instead of creating duplicate
            // This prevents showing "MANUAL MODE" twice
            updateTradingModeDisplay(autoTradeEnabled);
        }
        
        // Generate test alert for demonstration
        window.generateTestAlert = function() {
            console.log('[TEST ALERT] Generating test alert...');

            const signals = ['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8'];
            const randomSignal = signals[Math.floor(Math.random() * signals.length)];
            const isBullish = ['S1', 'S2', 'S4', 'S7'].includes(randomSignal);
            const optionType = isBullish ? 'PE' : 'CE';

            // Get current spot from UI or use default
            let spotPrice = 25050;
            const spotElement = document.getElementById('spotPrice');
            if (spotElement && spotElement.textContent) {
                const parsed = parseFloat(spotElement.textContent);
                if (parsed && parsed > 15000 && parsed < 35000) {
                    spotPrice = parsed;
                }
            }

            const strikeBase = Math.floor(spotPrice / 50) * 50; // Round to nearest 50
            const strikeOffset = (Math.floor(Math.random() * 5) - 2) * 50; // -100 to +100
            const strike = strikeBase + strikeOffset;
            
            const signalDescriptions = {
                'S1': 'Bear Trap',
                'S2': 'Support Hold',
                'S3': 'Resistance Hold',
                'S4': 'Bias Failure Bull',
                'S5': 'Bias Failure Bear',
                'S6': 'Weakness Confirmed',
                'S7': 'Breakout Confirmed',
                'S8': 'Breakdown Confirmed'
            };
            
            const testAlert = {
                signal: randomSignal,
                description: signalDescriptions[randomSignal],
                strike: strike,
                type: optionType,
                action: 'ENTRY',
                spot_price: spotPrice,
                timestamp: new Date().toISOString()
            };

            console.log('[TEST ALERT] Test alert object:', testAlert);

            // Check if auto trade is enabled
            const autoTradeCheckbox = document.getElementById('autoTradeToggle');
            const autoTradeEnabled = autoTradeCheckbox ? autoTradeCheckbox.checked : false;

            if (!autoTradeEnabled) {
                console.log('[TEST ALERT] Auto trade disabled - creating pending alert');
                // Send webhook to create pending alert
                const webhookPayload = {
                    secret: 'tradingview-webhook-secret-key-2025',
                    signal: randomSignal,
                    action: 'Entry',
                    strike: strike,
                    type: optionType,
                    spot_price: spotPrice
                };

                fetch(getApiUrl('/webhook/entry'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(webhookPayload)
                })
                .then(response => response.json())
                .then(result => {
                    console.log('[TEST ALERT] Webhook response:', result);
                    if (result.status === 'pending') {
                        showNotification(`Test alert stored for manual review: ${randomSignal}`, 'warning');
                    } else {
                        showNotification(`Test alert generated: ${randomSignal}`, 'info');
                    }
                })
                .catch(error => {
                    console.error('[TEST ALERT] Error:', error);
                    showNotification('Error generating test alert', 'error');
                });
            } else {
                console.log('[TEST ALERT] Auto trade enabled - adding to stream');
                // Add the alert through the normal flow
                addAlertToStream(testAlert);
                showNotification(`Test alert generated: ${randomSignal}`, 'info');
            }
        }
        
        // Calculate hedge strike based on percentage rule
        async function calculateHedgeStrike(mainStrike, optionType) {
            const hedgeMethod = document.querySelector('input[name="hedgeMethod"]:checked').value;
            
            if (hedgeMethod === 'percentage') {
                const hedgePercent = parseFloat(document.getElementById('hedgePercent').value) || 30;
                
                // Fetch option chain to find appropriate hedge
                const response = await fetch(getApiUrl(`/api/option-chain?strike=${mainStrike}&type=${optionType}`));
                const optionChain = await response.json();
                
                // Find main leg price
                const mainLeg = optionChain.find(opt => opt.strike === mainStrike);
                if (!mainLeg) return null;
                
                const targetHedgePrice = mainLeg.price * (hedgePercent / 100);
                
                // Find best hedge match
                let bestHedge = null;
                let minDiff = Infinity;
                
                for (let option of optionChain) {
                    if ((optionType === 'PE' && option.strike < mainStrike) || 
                        (optionType === 'CE' && option.strike > mainStrike)) {
                        const priceDiff = Math.abs(option.price - targetHedgePrice);
                        if (priceDiff < minDiff) {
                            minDiff = priceDiff;
                            bestHedge = option;
                        }
                    }
                }
                
                return bestHedge ? bestHedge.strike : null;
            } else {
                // Fixed offset method
                const offset = parseInt(document.getElementById('hedgeOffset').value) || 200;
                return optionType === 'PE' ? mainStrike - offset : mainStrike + offset;
            }
        }

        // Start breakeven monitoring
        function startBreakevenMonitoring() {
            // Update every 60 seconds
            breakevenUpdateInterval = setInterval(updateBreakevenCalculation, 60000);
            // Initial update
            updateBreakevenCalculation();
        }

        // Load live positions from server - make it global
        window.loadLivePositions = async function() {
            try {
                const response = await fetch(getApiUrl('/live/positions'));
                const data = await response.json();
                
                if (data.success && data.positions) {
                    positions = data.positions;
                    displayPositions();
                    updateBreakevenCalculation();
                    // Update the Live Breakeven Monitor with real position data
                    updateLiveBreakevenMonitor(data.positions);
                    // Update hedge preview with actual position data
                    updateHedgePreviewWithPositions(data.positions);
                    // Update the positions table with real data
                    updatePositionsTable(data.positions);
                } else {
                    // No positions - clear everything
                    updateLiveBreakevenMonitor([]);
                    clearHedgePreview();
                    updatePositionsTable([]);
                }
            } catch (error) {
                console.error('Error loading positions:', error);
                // On error, show no positions
                updateLiveBreakevenMonitor([]);
                updatePositionsTable([]);
            }
        }

        // Update the positions table with real data
        function updatePositionsTable(positions) {
            const tableBody = document.getElementById('positionsTableBody');
            if (!tableBody) return;
            
            // Clear existing rows
            tableBody.innerHTML = '';
            
            if (!positions || positions.length === 0) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="11" style="text-align: center; padding: 20px; color: var(--text-muted);">
                            No active positions
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Add rows for each position
            positions.forEach(pos => {
                // Main leg row
                const mainRow = document.createElement('tr');
                const pnlClass = pos.pnl >= 0 ? 'positive' : 'negative';
                const pnlSign = pos.pnl >= 0 ? '+' : '';
                const percentChange = pos.pnl_percent || 0;
                const entryTime = new Date(pos.entry_time).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                
                mainRow.innerHTML = `
                    <td>${pos.signal_type}</td>
                    <td class="position-symbol">NIFTY${pos.main_strike}${pos.option_type || 'PE'}</td>
                    <td>SELL</td>
                    <td>${pos.main_price ? pos.main_price.toFixed(2) : '--'}</td>
                    <td>${pos.current_main_price ? pos.current_main_price.toFixed(2) : '--'}</td>
                    <td class="position-pnl ${pnlClass}">${pnlSign}${Math.abs(pos.pnl || 0).toFixed(0)}</td>
                    <td class="${pnlClass}">${pnlSign}${Math.abs(percentChange).toFixed(1)}%</td>
                    <td>${entryTime}</td>
                    <td>${pos.main_strike}</td>
                    <td>${pos.target || '-'}</td>
                    <td class="position-actions">
                        <button class="action-btn modify" onclick="modifyPosition(${pos.position_id || pos.id})">Modify</button>
                        <button class="action-btn exit" onclick="exitPosition(${pos.position_id || pos.id})">Exit</button>
                    </td>
                `;
                tableBody.appendChild(mainRow);
                
                // Hedge leg row if exists
                if (pos.hedge_strike) {
                    const hedgeRow = document.createElement('tr');
                    hedgeRow.innerHTML = `
                        <td>-</td>
                        <td class="position-symbol">NIFTY${pos.hedge_strike}${pos.option_type || 'PE'}</td>
                        <td>BUY (Hedge)</td>
                        <td>${pos.hedge_price ? pos.hedge_price.toFixed(2) : '--'}</td>
                        <td>${pos.current_hedge_price ? pos.current_hedge_price.toFixed(2) : '--'}</td>
                        <td class="position-pnl">-</td>
                        <td>-</td>
                        <td>${entryTime}</td>
                        <td>-</td>
                        <td>-</td>
                        <td class="position-actions">
                            <button class="action-btn exit" onclick="exitPosition(${pos.position_id || pos.id}, true)">Exit</button>
                        </td>
                    `;
                    tableBody.appendChild(hedgeRow);
                }
            });
        }
        
        // Display positions in UI
        function displayPositions() {
            const positionsList = document.getElementById('positionsList');
            if (!positionsList) return;
            
            positionsList.innerHTML = '';
            
            positions.forEach(pos => {
                const posCard = document.createElement('div');
                posCard.className = 'position-card';
                posCard.innerHTML = `
                    <div class="position-header">
                        <span class="signal-badge">${pos.signal_type}</span>
                        <span class="strike">${pos.main_strike} ${pos.option_type}</span>
                    </div>
                    <div class="position-details">
                        <div>Breakeven: ${pos.breakeven.toFixed(2)}</div>
                        <div class="pnl ${pos.pnl >= 0 ? 'profit' : 'loss'}">
                            P&L: â‚¹${pos.pnl.toFixed(2)}
                        </div>
                    </div>
                `;
                positionsList.appendChild(posCard);
            });
        }

        // Handle position closed event
        function handlePositionClosed(data) {
            showNotification(`Position closed: ${data.signal_type} - P&L: â‚¹${data.final_pnl}`, 'info');
        }

        // Handle hourly candle close
        function handleHourlyCandleClose(candle) {
            console.log('Hourly candle closed:', candle);
            
            // Update last candle close display
            const closeDisplay = document.getElementById('lastHourlyClose');
            if (closeDisplay) {
                closeDisplay.textContent = `Last 1H Close: ${candle.close.toFixed(2)}`;
            }
            
            // Trigger stop loss check
            checkAllStopLosses();
        }

        // Check all stop losses
        async function checkAllStopLosses() {
            for (const pos of positions) {
                try {
                    await fetch(getApiUrl(`/live/stoploss/check/${pos.position_id}`), {
                        method: 'POST'
                    });
                } catch (error) {
                    console.error(`Error checking stop loss for position ${pos.position_id}:`, error);
                }
            }
        }

        // Update breakeven calculation
        async function updateBreakevenCalculation() {
            try {
                // Fetch detailed breakeven data
                const response = await fetch(getApiUrl('/api/positions/breakeven'));
                const data = await response.json();
                
                if (data.success) {
                    // Update positions array
                    positions = data.positions;
                    
                    // Update the Live Breakeven Monitor display
                    updateLiveBreakevenMonitor(data.positions);
                    
                    // Update breakeven display
                    if (data.positions.length > 0) {
                        const totalPnl = data.summary.total_pnl;
                        const currentSpot = data.summary.current_spot;
                        
                        // Calculate average breakeven
                        let avgBreakeven = 0;
                        data.positions.forEach(pos => {
                            avgBreakeven += pos.breakeven_point;
                        });
                        avgBreakeven = avgBreakeven / data.positions.length;
                        
                        // Update display
                        document.querySelector('.breakeven-value').textContent = avgBreakeven.toFixed(0);
                        document.querySelector('.breakeven-display div:last-child').innerHTML = 
                            `Net P&L: <span style="color: ${totalPnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'}">
                            ${totalPnl >= 0 ? '+' : ''}â‚¹${Math.abs(totalPnl).toLocaleString()}</span>`;
                        
                        // Update spot price if available
                        if (currentSpot) {
                            document.getElementById('spotPrice').textContent = currentSpot.toFixed(2);
                        }
                        
                        // Update positions list
                        displayBreakevenPositions(data.positions);
                    } else {
                        // No positions
                        document.querySelector('.breakeven-value').textContent = '-';
                        document.querySelector('.breakeven-display div:last-child').innerHTML = 
                            'Net P&L: <span style="color: var(--text-muted)">â‚¹0</span>';
                    }
                }
            } catch (error) {
                console.error('Error updating breakeven:', error);
            }
        }

        // Display breakeven positions
        function displayBreakevenPositions(positions) {
            const container = document.querySelector('.position-legs');
            if (!container) return;
            
            container.innerHTML = '';
            
            positions.forEach(pos => {
                const posCard = document.createElement('div');
                posCard.className = 'leg-card';
                posCard.innerHTML = `
                    <div class="leg-header">
                        <span class="signal-badge">${pos.signal_type}</span>
                        <span>${pos.main_strike} ${pos.option_type}</span>
                    </div>
                    <div class="leg-details">
                        <span>Breakeven:</span>
                        <span style="font-weight: 600">${pos.breakeven_point.toFixed(0)}</span>
                    </div>
                    <div class="leg-details">
                        <span>Distance:</span>
                        <span>${pos.distance_from_breakeven.toFixed(0)} pts</span>
                    </div>
                    <div class="leg-details">
                        <span>P&L:</span>
                        <span style="color: ${pos.pnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'}">
                            ${pos.pnl >= 0 ? '+' : ''}â‚¹${Math.abs(pos.pnl).toFixed(0)}
                        </span>
                    </div>
                    ${pos.hedge_strike ? `
                    <div class="leg-details" style="font-size: 11px; color: var(--text-muted);">
                        <span>Hedge: ${pos.hedge_strike}</span>
                        <span>Net: â‚¹${pos.net_premium.toFixed(2)}</span>
                    </div>` : ''}
                `;
                container.appendChild(posCard);
            });
        }
        
        // Update breakeven display (WebSocket handler)
        function updateBreakevenDisplay(data) {
            // This function handles WebSocket updates
            if (data.breakevenPoint) {
                document.querySelector('.breakeven-value').textContent = data.breakevenPoint.toLocaleString();
            }
            if (data.netPnl !== undefined) {
                document.querySelector('.breakeven-display div:last-child').innerHTML = 
                    `Net P&L: <span style="color: ${data.netPnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'}">
                    ${data.netPnl >= 0 ? '+' : ''}â‚¹${Math.abs(data.netPnl).toLocaleString()}</span>`;
            }
        }

        // Check profit lock conditions
        function checkProfitLockConditions(netPnL) {
            if (!document.getElementById('enableProfitLock').checked) return;
            
            const profitLockAmount = parseFloat(document.getElementById('profitLockAmount').value) || 5000;
            
            if (netPnL >= profitLockAmount) {
                // Move stop loss to breakeven
                moveStopLossToBreakeven();
                showNotification('Stop loss moved to breakeven', 'success');
            }
            
            // Update progress bar
            const progress = Math.min((netPnL / profitLockAmount) * 100, 100);
            document.querySelector('.sl-progress-bar').style.width = progress + '%';
        }

        // Check trailing stop conditions
        function checkTrailingStopConditions(netPnL) {
            if (!document.getElementById('enableTrailing').checked) return;
            
            const levels = [
                { trigger: 5000, sl: -1000 },
                { trigger: 10000, sl: 0 },
                { trigger: 20000, sl: 5000 }
            ];
            
            for (let level of levels) {
                if (netPnL >= level.trigger) {
                    updateDynamicStopLoss(level.sl);
                }
            }
        }

        // Function to update 1H Candle Monitor with real data
        async function update1HCandleMonitor() {
            console.log('ðŸ”„ [CANDLE MONITOR] Starting update...');
            
            // Debug: Show we're actually running
            const debugEl = document.getElementById('candleCurrentNifty');
            if (debugEl) {
                debugEl.style.border = '2px solid yellow';
            }
            
            try {
                let currentSpot = 0;
                let lastHourlyClose = 0;
                let activePosition = null;
                let tradingViewSignal = null;
                
                // 1. Get current NIFTY spot - ONLY REAL DATA, NO MOCK
                // First priority: Use the same spot price shown in header (if it's real)
                const headerSpotEl = document.getElementById('niftySpot');
                const headerText = headerSpotEl ? headerSpotEl.textContent.trim() : '';
                
                // REJECT any non-real data indicators
                const invalidTexts = ['No data', '--', '0', 'Loading', 'Connecting', 'Error', 
                                     'Network Error', 'Session Expired', 'API Error', 'Disconnected', 
                                     'Waiting', 'Stream Error'];
                
                if (headerSpotEl && !invalidTexts.includes(headerText) && headerText !== '') {
                    const parsed = parseFloat(headerText.replace(/,/g, ''));
                    // Validate it's a realistic NIFTY value
                    if (parsed && parsed > 15000 && parsed < 35000) {
                        currentSpot = parsed;
                        console.log('[CANDLE MONITOR] Using REAL header spot:', currentSpot);
                    } else {
                        console.log('[CANDLE MONITOR] Header value suspicious, rejecting:', parsed);
                    }
                }
                
                // If header doesn't have spot, fetch from Breeze
                if (!currentSpot) {
                    try {
                        console.log('[CANDLE MONITOR] Header spot not available, fetching from Breeze...');
                        
                        // Try Breeze API - look for the actual working endpoint
                        const spotResponse = await fetch(getApiUrl('/api/live/nifty-spot'));
                        console.log('[DEBUG] Spot API URL:', getApiUrl('/api/live/nifty-spot'));
                        if (spotResponse.ok) {
                            const spotData = await spotResponse.json();
                            console.log('[DEBUG] Spot API Response:', spotData);
                            // CRITICAL: Reject ANY mock data - check both is_real and is_mock
                            if (spotData.success && spotData.data && (spotData.data.is_real || !spotData.data.is_mock) && !spotData.error) {
                                // Support both Kite (price) and Breeze (ltp) field names
                                const ltp = spotData.data.price || spotData.data.ltp;
                                // Validate realistic value
                                if (ltp && ltp > 15000 && ltp < 35000) {
                                    currentSpot = ltp;
                                    const source = spotData.data.source || 'API';
                                    console.log(`[CANDLE MONITOR] REAL ${source} spot:`, currentSpot);
                                } else {
                                    console.error('[CANDLE MONITOR] Invalid LTP value:', ltp);
                                    currentSpot = 0;
                                }
                            } else if (spotData.data && (spotData.data.is_mock || spotData.data.is_real === false)) {
                                console.error('[CANDLE MONITOR] REJECTED MOCK DATA from API');
                                currentSpot = 0;
                            } else {
                                console.error('[CANDLE MONITOR] API failed:', spotData.error || 'Unknown error');
                                currentSpot = 0;
                                
                                // Also update the header if it's empty - ONLY with real data
                                if (headerSpotEl && currentSpot > 0 && invalidTexts.includes(headerSpotEl.textContent.trim())) {
                                    headerSpotEl.textContent = currentSpot.toFixed(2);
                                    headerSpotEl.style.color = '#28a745'; // Green for real
                                }
                            }
                        }
                    } catch (e) {
                        console.log('[CANDLE MONITOR] Could not fetch spot price:', e);
                    }
                }
                
                // Final validation - ensure spot is real
                if (currentSpot) {
                    if (currentSpot < 15000 || currentSpot > 35000) {
                        console.error('[CANDLE MONITOR] INVALID spot price, rejecting:', currentSpot);
                        currentSpot = 0; // Don't use bad data
                    } else {
                        console.log('[CANDLE MONITOR] Final validated spot:', currentSpot);
                    }
                } else {
                    console.log('[CANDLE MONITOR] No real spot data available');
                }
                
                // 2. Get last hourly candle close from TradingView real-time data
                try {
                    const now = new Date();
                    const currentHour = now.getHours();
                    const currentMinute = now.getMinutes();
                    
                    // Use TradingView endpoint for real hourly candles
                    // Hourly candles close at :15 (9:15, 10:15, 11:15, 12:15, 13:15, 14:15, 15:15)
                    
                    let lastCandleHour = currentHour;
                    if (currentMinute < 15) {
                        lastCandleHour = currentHour - 1;
                    }
                    
                    // Only fetch if market hours (9:15 AM to 3:30 PM)
                    if (lastCandleHour >= 9 && lastCandleHour <= 15) {
                        // Check cache first
                        const cachedClose = window.lastKnownHourlyClose;
                        if (cachedClose && 
                            cachedClose.hour === lastCandleHour && 
                            cachedClose.date === new Date().toDateString() &&
                            cachedClose.close && cachedClose.close !== 0) {
                            lastHourlyClose = cachedClose.close;
                            console.log('[CANDLE MONITOR] Using cached hourly close:', lastHourlyClose);
                        } else {
                            // Fetch real-time hourly candle from Breeze (XX:10-XX:15 5-min candle)
                            try {
                                console.log('[CANDLE MONITOR] Fetching Breeze hourly candle data...');
                                const candleRes = await fetch(getApiUrl('/api/breeze/hourly-candle'));
                                console.log('[DEBUG] Candle API URL:', getApiUrl('/api/breeze/hourly-candle'));
                                
                                if (candleRes.ok) {
                                    const candleData = await candleRes.json();
                                    console.log('[DEBUG] Candle API Response:', candleData);
                                    if (candleData.success && candleData.candle) {
                                        // Only accept data from real sources, not live_spot fallback
                                        const validSources = ['breeze_1min', 'breeze_5min', 'breeze_5min_approx', 'tradingview_realtime', 'tradingview_webhook', 'aggregated_from_5min', 'KITE'];
                                        if (validSources.includes(candleData.source)) {
                                            lastHourlyClose = candleData.candle.close;
                                            console.log(`[CANDLE MONITOR] Fetched real candle close for ${candleData.candle.time}: ${lastHourlyClose} (source: ${candleData.source})`);
                                            
                                            // Cache the real candle data
                                            window.lastKnownHourlyClose = {
                                                hour: lastCandleHour,
                                                close: lastHourlyClose,
                                                time: candleData.candle.time,
                                                date: new Date().toDateString(),
                                                source: candleData.source
                                            };
                                        } else {
                                            console.log(`[CANDLE MONITOR] Rejecting invalid data from source: ${candleData.source}`);
                                            lastHourlyClose = 0; // Will show as "--"
                                        }
                                    } else {
                                        console.log('[CANDLE MONITOR] No real candle data:', candleData.error || 'Data not available');
                                        lastHourlyClose = 0; // Will show as "--"
                                    }
                                } else {
                                    console.log('[CANDLE MONITOR] Failed to fetch candle data');
                                    lastHourlyClose = 0; // Will show as "--"
                                }
                            } catch (e) {
                                console.log('[CANDLE MONITOR] Error fetching candle data:', e);
                                lastHourlyClose = 0; // Will show as "--"
                            }
                        }
                    } else {
                        console.log('[CANDLE MONITOR] Outside market hours - trying to fetch last available candle');
                        // Still try to fetch the last available candle even outside market hours
                        try {
                            const candleRes = await fetch(getApiUrl('/api/breeze/hourly-candle'));
                            if (candleRes.ok) {
                                const candleData = await candleRes.json();
                                if (candleData.success && candleData.candle) {
                                    lastHourlyClose = candleData.candle.close;
                                    console.log('[CANDLE MONITOR] Got last available candle:', lastHourlyClose);
                                }
                            }
                        } catch (e) {
                            console.log('[CANDLE MONITOR] Could not fetch last candle:', e);
                        }
                    }
                } catch (e) {
                    console.log('[CANDLE MONITOR] Error getting hourly candle:', e);
                    lastHourlyClose = 0; // Show -- instead of fake data
                }
                
                // 3. Get active positions from TradingView signals
                try {
                    // Check for active positions from live trading
                    const posResponse = await fetch(getApiUrl('/live/positions'));
                    if (posResponse.ok) {
                        const posData = await posResponse.json();
                        if (posData.positions && posData.positions.length > 0) {
                            // Find the most recent active position
                            activePosition = posData.positions.find(p => 
                                p.status === 'active' || p.status === 'OPEN'
                            ) || null;
                            console.log('[CANDLE MONITOR] Active position found:', activePosition);
                        }
                    }
                    
                    // Also check for recent TradingView signal from alerts history
                    const alertsEl = document.querySelector('.alert-item.active');
                    if (alertsEl) {
                        // Extract signal info from active alert
                        const signalEl = alertsEl.querySelector('.signal-badge');
                        const strikeEl = alertsEl.querySelector('.alert-details');
                        if (signalEl && strikeEl) {
                            const signalText = strikeEl.textContent;
                            const strikeMatch = signalText.match(/(\d{5})/);
                            if (strikeMatch) {
                                tradingViewSignal = {
                                    signal: signalEl.textContent,
                                    strike: parseInt(strikeMatch[1]),
                                    timestamp: new Date()
                                };
                                console.log('[CANDLE MONITOR] TradingView signal detected:', tradingViewSignal);
                            }
                        }
                    }
                } catch (e) {
                    console.log('[CANDLE MONITOR] Could not fetch positions:', e);
                }
                
                // 4. Update the display elements - STRICT validation
                // ONLY pass data that is 100% confirmed real
                const validSpot = (currentSpot && currentSpot > 15000 && currentSpot < 35000) ? currentSpot : 0;
                const validLastClose = (lastHourlyClose && lastHourlyClose > 15000 && lastHourlyClose < 35000) ? lastHourlyClose : 0;
                
                console.log('[CANDLE MONITOR] Passing to display - Spot:', validSpot, 'LastClose:', validLastClose);
                updateCandleMonitorDisplay(validSpot, validLastClose, activePosition, tradingViewSignal);
                
            } catch (error) {
                console.error('Error updating 1H Candle Monitor:', error);
            }
        }

        // Function to update the display elements
        function updateCandleMonitorDisplay(currentSpot, lastHourlyClose, activePosition, tradingViewSignal) {
            console.log('[CANDLE MONITOR] Updating display with:', {currentSpot, lastHourlyClose, activePosition, tradingViewSignal});
            
            // Entry Strike - Show ONLY when TradingView signal received and trade entered
            const entryStrikeEl = document.getElementById('candleEntryStrike');
            if (entryStrikeEl) {
                if (activePosition || tradingViewSignal) {
                    // We have an active trade from TradingView signal
                    let entryStrike = 0;
                    
                    // Priority 1: Get strike from active position
                    if (activePosition) {
                        entryStrike = activePosition.main_strike || activePosition.strike || activePosition.entry_strike;
                        
                        // Extract from symbol if needed (e.g., NIFTY24900PE)
                        if (!entryStrike && activePosition.symbol) {
                            const match = activePosition.symbol.match(/(\d{5})/);
                            if (match) {
                                entryStrike = parseInt(match[1]);
                            }
                        }
                        
                        // Extract from trading_symbol if available
                        if (!entryStrike && activePosition.trading_symbol) {
                            const match = activePosition.trading_symbol.match(/(\d{5})/);
                            if (match) {
                                entryStrike = parseInt(match[1]);
                            }
                        }
                    }
                    
                    // Priority 2: Get from TradingView signal
                    if (!entryStrike && tradingViewSignal) {
                        entryStrike = tradingViewSignal.strike;
                    }
                    
                    if (entryStrike) {
                        console.log('[CANDLE MONITOR] Entry strike from trade:', entryStrike);
                        entryStrikeEl.textContent = entryStrike.toLocaleString();
                    } else {
                        // No clear strike, show waiting
                        entryStrikeEl.textContent = 'Waiting...';
                    }
                } else {
                    // No TradingView signal received yet
                    console.log('[CANDLE MONITOR] No TradingView signal - waiting for entry');
                    entryStrikeEl.textContent = 'No data';
                    entryStrikeEl.style.color = '#dc3545'; // Red for no data
                }
            } else {
                console.error('[CANDLE MONITOR] Entry strike element not found!');
            }
            
            // Current NIFTY - ABSOLUTELY NO MOCK DATA
            const currentNiftyEl = document.getElementById('candleCurrentNifty');
            const currentNiftyTimeEl = document.getElementById('candleCurrentNiftyTime');
            const dataSourceEl = document.getElementById('dataSourceIndicator');
            
            if (currentNiftyEl) {
                // STRICT: Only show if we have validated real data
                if (currentSpot && currentSpot > 15000 && currentSpot < 35000) {
                    currentNiftyEl.textContent = currentSpot.toFixed(2);
                    currentNiftyEl.style.color = '#28a745'; // Green for real data
                    currentNiftyEl.title = 'Real-time data from KITE API';
                    
                    // Update timestamp
                    const now = new Date();
                    const timeStr = now.toLocaleTimeString('en-IN', {hour12: false});
                    if (currentNiftyTimeEl) {
                        currentNiftyTimeEl.textContent = `Updated: ${timeStr}`;
                    }
                    
                    // Update data source indicator
                    if (dataSourceEl) {
                        dataSourceEl.textContent = 'KITE';
                        dataSourceEl.style.background = 'rgba(46, 125, 50, 0.3)';
                    }
                    
                    console.log('[CANDLE DISPLAY] Showing real spot:', currentSpot);
                } else {
                    currentNiftyEl.textContent = 'No data';
                    currentNiftyEl.style.color = '#dc3545'; // Red for no data
                    currentNiftyEl.title = 'Waiting for real market data';
                    console.log('[CANDLE DISPLAY] No valid data to show');
                }
            }
            
            // Last 1H Close - Use current spot if no hourly data available
            const lastCloseEl = document.getElementById('candleLastClose');
            const lastCloseTimeEl = document.getElementById('candleLastCloseTime');
            const lastCloseAgeEl = document.getElementById('candleLastCloseAge');
            
            if (lastCloseEl) {
                // Use lastHourlyClose if available, otherwise use current spot
                const closeValue = (lastHourlyClose && lastHourlyClose > 0) ? lastHourlyClose : currentSpot;
                
                if (closeValue && closeValue > 0) {
                    lastCloseEl.textContent = closeValue.toFixed(2);
                    lastCloseEl.style.color = '#28a745'; // Green for real data
                    
                    // Update timestamp with current time
                    const now = new Date();
                    const timeStr = now.toLocaleTimeString('en-IN', {hour12: false});
                    
                    if (lastCloseTimeEl) {
                        lastCloseTimeEl.textContent = `Updated: ${timeStr}`;
                    }
                    
                    // Show age as "LIVE" when using current data
                    if (lastCloseAgeEl) {
                        if (lastHourlyClose && lastHourlyClose > 0) {
                            // We have actual hourly candle data
                            lastCloseAgeEl.textContent = 'Age: From last candle';
                            lastCloseAgeEl.style.color = '#ffc107';
                        } else {
                            // Using current spot price
                            lastCloseAgeEl.textContent = 'Age: LIVE';
                            lastCloseAgeEl.style.color = 'var(--accent-green)';
                        }
                    }
                    
                    // Record update for 1H candle
                    window.recordDataUpdate('candle1h');
                    
                    // Update status panel
                    if (window.updateMarketDataStatus) {
                        updateMarketDataStatus('1h', {
                            close: closeValue.toFixed(2),
                            period: '--',
                            time: timeStr,
                            age: lastCloseAgeEl ? lastCloseAgeEl.textContent.replace('Age: ', '') : 'LIVE',
                            valid: true
                        });
                    }
                } else {
                    lastCloseEl.textContent = 'No data';
                    lastCloseEl.style.color = '#dc3545'; // Red for no data
                    if (lastCloseTimeEl) lastCloseTimeEl.textContent = 'Updated: --:--:--';
                    if (lastCloseAgeEl) {
                        lastCloseAgeEl.textContent = 'Age: No data';
                        lastCloseAgeEl.style.color = 'var(--text-muted)';
                    }
                }
            }
            
            // Distance to Stop Loss & Status - Show ONLY when trade is active from TradingView
            const distanceEl = document.getElementById('candleDistanceToSL');
            const statusIndicatorEl = document.getElementById('candleStatusIndicator');
            const statusMessageEl = document.getElementById('candleStatusMessage');
            const statusContainer = statusIndicatorEl ? statusIndicatorEl.parentElement.parentElement.parentElement : null;
            
            if (activePosition && currentSpot && currentSpot > 0) {
                // We have an active trade with REAL data - calculate distance to stop loss
                let strike = activePosition.main_strike || activePosition.strike || 0;
                
                // Extract strike from symbol if needed
                if (!strike && activePosition.symbol) {
                    const match = activePosition.symbol.match(/(\d{5})/);
                    if (match) {
                        strike = parseInt(match[1]);
                    }
                }
                
                if (!strike && activePosition.trading_symbol) {
                    const match = activePosition.trading_symbol.match(/(\d{5})/);
                    if (match) {
                        strike = parseInt(match[1]);
                    }
                }
                
                if (strike && currentSpot) {
                    const optionType = activePosition.option_type || activePosition.right || 'PE';
                    const signalType = activePosition.signal_type || activePosition.signal || '';
                    
                    let distance = 0;
                    let isBreached = false;
                    
                    // Calculate distance based on option type and signal
                    // Bullish signals (S1, S2, S4, S7) - Sell PUT - SL if spot goes BELOW strike
                    // Bearish signals (S3, S5, S6, S8) - Sell CALL - SL if spot goes ABOVE strike
                    const bullishSignals = ['S1', 'S2', 'S4', 'S7'];
                    const isBullish = optionType === 'PE' || bullishSignals.includes(signalType);
                    
                    if (isBullish) {
                        // PUT selling - stop loss if spot goes BELOW strike
                        distance = currentSpot - strike;
                        isBreached = currentSpot < strike;
                    } else {
                        // CALL selling - stop loss if spot goes ABOVE strike  
                        distance = strike - currentSpot;
                        isBreached = currentSpot > strike;
                    }
                    
                    // Update distance display with REAL values only
                    if (distanceEl) {
                        const absDistance = Math.abs(distance);
                        if (currentSpot > 0) {
                            distanceEl.textContent = `${absDistance.toFixed(0)} pts`;
                        } else {
                            distanceEl.textContent = 'No data';
                            distanceEl.style.color = '#dc3545';
                        }
                        
                        // Color based on safety
                        if (isBreached) {
                            distanceEl.style.color = 'var(--accent-red)';
                        } else if (absDistance < 50) {
                            distanceEl.style.color = 'var(--accent-orange)';
                        } else {
                            distanceEl.style.color = 'var(--accent-green)';
                        }
                    }
                    
                    // Update status indicator with real status and send alerts
                    if (statusIndicatorEl && statusMessageEl) {
                        const alertData = {
                            strike: strike,
                            optionType: optionType,
                            currentSpot: currentSpot,
                            distance: distance,
                            signalType: signalType
                        };
                        
                        if (isBreached) {
                            statusIndicatorEl.innerHTML = 'ðŸ”´ BREACH';
                            statusIndicatorEl.style.color = 'var(--accent-red)';
                            statusMessageEl.textContent = `Stop loss hit! Exit at ${strike}`;
                            if (statusContainer) {
                                statusContainer.style.borderLeft = '3px solid var(--accent-red)';
                            }
                            
                            // Send breach alert
                            sendStopLossAlert('breach', alertData);
                            
                        } else if (Math.abs(distance) < 30) {
                            statusIndicatorEl.innerHTML = 'ðŸŸ¡ WARNING';
                            statusIndicatorEl.style.color = 'var(--accent-orange)';
                            statusMessageEl.textContent = `Only ${Math.abs(distance).toFixed(0)} points to SL at ${strike}`;
                            if (statusContainer) {
                                statusContainer.style.borderLeft = '3px solid var(--accent-orange)';
                            }
                            
                            // Send warning alert
                            sendStopLossAlert('warning', alertData);
                            
                        } else {
                            statusIndicatorEl.innerHTML = 'ðŸŸ¢ SAFE';
                            statusIndicatorEl.style.color = 'var(--accent-green)';
                            statusMessageEl.textContent = `${Math.abs(distance).toFixed(0)} pts from SL`;
                            if (statusContainer) {
                                statusContainer.style.borderLeft = '3px solid var(--accent-green)';
                            }
                            
                            // Check if we recovered from warning/breach
                            if (window.stopLossAlertState && 
                                window.stopLossAlertState.lastLevel !== 'safe' && 
                                window.stopLossAlertState.lastLevel !== null) {
                                // Send recovery alert
                                sendStopLossAlert('recovery', alertData);
                            }
                        }
                    }
                } else {
                    // Position exists but no clear strike
                    if (distanceEl) {
                        distanceEl.textContent = 'Calculating...';
                        distanceEl.style.color = 'var(--text-muted)';
                    }
                    if (statusIndicatorEl && statusMessageEl) {
                        statusIndicatorEl.innerHTML = 'â³ PENDING';
                        statusIndicatorEl.style.color = 'var(--text-muted)';
                        statusMessageEl.textContent = 'Waiting for position data';
                    }
                }
            } else {
                // No active position - waiting for TradingView signal
                if (distanceEl) {
                    distanceEl.textContent = '--';
                    distanceEl.style.color = 'var(--text-muted)';
                }
                if (statusIndicatorEl && statusMessageEl) {
                    statusIndicatorEl.innerHTML = 'ðŸ“¡ WAITING';
                    statusIndicatorEl.style.color = 'var(--text-muted)';
                    statusMessageEl.textContent = 'Waiting for TradingView signal';
                    if (statusContainer) {
                        statusContainer.style.borderLeft = '3px solid var(--text-muted)';
                    }
                }
            }
            
            // Update time to next candle
            updateTimeToNextCandle();
        }

        // Function to update time to next candle
        function updateTimeToNextCandle() {
            const timeEl = document.getElementById('candleTimeToNext');
            if (!timeEl) return;
            
            const now = new Date();
            const nextCandle = new Date(now);
            
            // Indian market hourly candles close at :15
            const currentMinutes = now.getMinutes();
            const currentHours = now.getHours();
            
            // Calculate next candle time
            if (currentMinutes >= 15) {
                nextCandle.setHours(currentHours + 1, 15, 0, 0);
            } else {
                nextCandle.setHours(currentHours, 15, 0, 0);
            }
            
            // Check if in market hours
            const nextHour = nextCandle.getHours();
            if (nextHour < 9 || (nextHour === 9 && nextCandle.getMinutes() < 15)) {
                // Before market opens
                nextCandle.setHours(9, 15, 0, 0);
            } else if (nextHour > 15 || (nextHour === 15 && nextCandle.getMinutes() > 15)) {
                // After last candle
                timeEl.textContent = 'Market Closed';
                return;
            }
            
            // Calculate time difference
            const diff = nextCandle - now;
            if (diff > 0) {
                const mins = Math.floor(diff / 60000);
                const secs = Math.floor((diff % 60000) / 1000);
                timeEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            } else {
                timeEl.textContent = 'Closing...';
            }
        }

        // Initialize stop-loss alert state tracking
        window.stopLossAlertState = {
            lastLevel: 'safe', // 'safe', 'warning', 'breach'
            lastAlertTime: null,
            positionId: null,
            alertCooldown: 300000 // 5 minutes cooldown between same level alerts
        };

        // Send stop-loss alert via notifications and Telegram
        async function sendStopLossAlert(level, data) {
            const { strike, optionType, currentSpot, distance, signalType } = data;
            
            // Check if we should send alert (avoid spam)
            const now = Date.now();
            const state = window.stopLossAlertState;
            
            // Reset state if position changed
            const positionId = `${strike}_${optionType}_${signalType}`;
            if (state.positionId !== positionId) {
                state.positionId = positionId;
                state.lastLevel = 'safe';
                state.lastAlertTime = null;
            }
            
            // Check if level changed or cooldown passed
            const levelChanged = state.lastLevel !== level;
            const cooldownPassed = !state.lastAlertTime || (now - state.lastAlertTime) > state.alertCooldown;
            
            if (!levelChanged && !cooldownPassed) {
                console.log('[SL ALERT] Skipping - cooldown active');
                return;
            }
            
            // Update state
            state.lastLevel = level;
            state.lastAlertTime = now;
            
            // Create alert message based on level
            let title, message, priority;
            
            if (level === 'breach') {
                title = 'â›” STOP LOSS BREACH!';
                message = `NIFTY at ${currentSpot.toFixed(2)}, Strike ${strike} ${optionType} breached. Manual exit recommended.`;
                priority = 'critical';
                
                // Browser notification with sound
                showNotification(message, 'error');
                
                // Play sound if available
                if (window.audioContext) {
                    try {
                        const osc = window.audioContext.createOscillator();
                        osc.frequency.value = 800;
                        osc.connect(window.audioContext.destination);
                        osc.start();
                        osc.stop(window.audioContext.currentTime + 0.5);
                    } catch (e) {}
                }
                
            } else if (level === 'warning') {
                title = 'âš ï¸ STOP LOSS WARNING';
                message = `Only ${Math.abs(distance).toFixed(0)} pts to SL. NIFTY at ${currentSpot.toFixed(2)}, Strike ${strike} ${optionType}.`;
                priority = 'high';
                
                // Browser notification
                showNotification(message, 'warning');
                
            } else if (level === 'recovery') {
                title = 'âœ… Position Recovered';
                message = `Position back to safe zone. ${Math.abs(distance).toFixed(0)} pts from SL.`;
                priority = 'medium';
                
                // Browser notification
                showNotification(message, 'success');
            }
            
            // Send Telegram alert via API
            try {
                const response = await fetch(getApiUrl('/api/alerts/stoploss'), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        level: level,
                        title: title,
                        message: message,
                        priority: priority,
                        data: {
                            strike: strike,
                            optionType: optionType,
                            currentSpot: currentSpot,
                            distance: distance,
                            signalType: signalType,
                            timestamp: new Date().toISOString()
                        }
                    })
                });
                
                if (response.ok) {
                    console.log('[SL ALERT] Alert sent successfully');
                } else {
                    console.error('[SL ALERT] Failed to send alert');
                }
            } catch (error) {
                console.error('[SL ALERT] Error sending alert:', error);
            }
        }

        // Start 1-hour candle monitoring
        function start1HourCandleMonitor() {
            console.log('[CANDLE MONITOR] Starting 1-hour candle monitoring...');
            hourCandleMonitor = setInterval(check1HourCandle, 60000); // Check every minute
            check1HourCandle(); // Initial check
            
            // Initialize audio context for alert sounds
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Initial update immediately
            update1HCandleMonitor();
            
            // Smart scheduler for hourly candle updates
            function scheduleHourlyCandleUpdate() {
                const now = new Date();
                const minutes = now.getMinutes();
                const seconds = now.getSeconds();
                
                // Calculate milliseconds until next XX:15:30
                let msToNext;
                if (minutes < 15 || (minutes === 15 && seconds < 30)) {
                    // Next update at XX:15:30
                    msToNext = ((15 - minutes) * 60 + (30 - seconds)) * 1000;
                } else {
                    // Next update at next hour's 15:30
                    msToNext = ((75 - minutes) * 60 + (30 - seconds)) * 1000; // 60 + 15 = 75
                }
                
                console.log(`[CANDLE MONITOR] Next hourly update scheduled in ${Math.round(msToNext/1000)} seconds at XX:15:30`);
                
                // Schedule the update
                setTimeout(() => {
                    console.log('[CANDLE MONITOR] Executing scheduled XX:15:30 update for accurate candle data');
                    // Clear cache to force fresh data fetch
                    window.lastKnownHourlyClose = null;
                    update1HCandleMonitor();
                    
                    // Reschedule for next hour
                    scheduleHourlyCandleUpdate();
                }, msToNext);
            }
            
            // Start the smart scheduler
            scheduleHourlyCandleUpdate();
            
            // Also update every 10 seconds for real-time monitoring (reduced from 5s to avoid too many API calls)
            setInterval(update1HCandleMonitor, 10000);
            
            // Update timer every second
            setInterval(updateTimeToNextCandle, 1000);
            
            console.log('[CANDLE MONITOR] Monitor started successfully');
        }
        
        // Debug function to manually test the monitor update
        window.testCandleMonitor = async function() {
            console.log('ðŸ§ª Testing Candle Monitor Update...');
            
            // Test with real API data
            await update1HCandleMonitor();
            
            // NO FAKE DATA - Only real data allowed
            console.log('âœ… Test complete - using REAL DATA only');
        }

        // Check 1-hour candle close (Indian market: candles close at :15)
        async function check1HourCandle() {
            // Use server time for accurate candle timing
            const now = await getServerTime();
            const minutes = now.getMinutes();
            const hours = now.getHours();
            
            // Update next candle time
            updateNextCandleTime();
            
            // Update the 1H Candle Monitor display with real data
            await update1HCandleMonitor();
            
            // Check if it's :15 minutes past the hour (Indian market candle boundary)
            // Market hours: 9:15 AM to 3:30 PM
            if (minutes === 15 && hours >= 9 && hours <= 15) {
                try {
                    const response = await fetch(getApiUrl('/api/nifty-1h-close'));
                    const data = await response.json();
                    
                    // Check for stop loss breach
                    positions.forEach(position => {
                        if (position.type === 'SELL') {
                            const strike = parseInt(position.symbol.match(/\d+/)[0]);
                            
                            if ((position.symbol.includes('PE') && data.close < strike) ||
                                (position.symbol.includes('CE') && data.close > strike)) {
                                // Stop loss hit
                                executeStopLoss(position);
                            }
                        }
                    });
                    
                    // REMOVED: Fake notification that shows dummy data
                    // Only show notification if we have REAL verified data
                    if (data.close && data.close > 15000 && data.close < 35000 && !data.is_mock) {
                        showNotification(`1H candle closed at ${data.close.toFixed(2)}`, 'info');
                    }
                    
                } catch (error) {
                    console.error('Error checking 1H candle:', error);
                }
            }
        }

        // Update next candle time (Indian market hours: 9:15 AM - 3:30 PM)
        function updateNextCandleTime() {
            const now = new Date();
            const nextCandle = new Date(now);
            
            // Indian market hourly candles form at :15 minutes past each hour
            // 9:15, 10:15, 11:15, 12:15, 13:15, 14:15, 15:15 (last candle)
            
            const currentMinutes = now.getMinutes();
            const currentHours = now.getHours();
            
            // If we're past :15 in current hour, next candle is at next hour:15
            if (currentMinutes >= 15) {
                nextCandle.setHours(currentHours + 1, 15, 0, 0);
            } else {
                // If before :15, next candle is at current hour:15
                nextCandle.setHours(currentHours, 15, 0, 0);
            }
            
            // Check if we're outside market hours or at end of day
            const nextHour = nextCandle.getHours();
            if (nextHour < 9 || (nextHour === 9 && nextCandle.getMinutes() < 15)) {
                // Before market opens, show time to 9:15
                nextCandle.setHours(9, 15, 0, 0);
            } else if (nextHour > 15 || (nextHour === 15 && nextCandle.getMinutes() > 15)) {
                // After 3:15 PM (last hourly candle), show time to market close at 3:30
                nextCandle.setHours(15, 30, 0, 0);
                
                // Update label to show "Market Close" instead of "Next 1H Candle"
                const label = document.querySelector('#nextHourTimer')?.parentElement?.querySelector('.stat-label');
                if (label) label.textContent = 'Market Close';
            }
            
            const hours = String(nextCandle.getHours()).padStart(2, '0');
            const minutes = String(nextCandle.getMinutes()).padStart(2, '0');
            const seconds = String(nextCandle.getSeconds()).padStart(2, '0');
            
            // Update next candle display if it exists
            const nextCandleEl = document.getElementById('nextCandle');
            if (nextCandleEl) {
                nextCandleEl.textContent = `Next: ${hours}:${minutes}:${seconds}`;
            }
            
            // Calculate time remaining
            const diff = nextCandle - now;
            const mins = Math.floor(diff / 60000);
            const secs = Math.floor((diff % 60000) / 1000);
            
            // Update or create the Next 1H timer element
            let nextHourTimer = document.getElementById('nextHourTimer');
            if (!nextHourTimer) {
                // Create it only once
                const statItem = document.createElement('div');
                statItem.className = 'stat-item';
                statItem.innerHTML = `
                    <div class="stat-label">Next 1H Candle</div>
                    <div class="stat-value" id="nextHourTimer">${mins}:${String(secs).padStart(2, '0')}</div>
                `;
                document.querySelector('.header-stats').appendChild(statItem);
            } else {
                // Just update the existing timer
                if (diff > 0) {
                    nextHourTimer.textContent = `${mins}:${String(secs).padStart(2, '0')}`;
                } else {
                    nextHourTimer.textContent = 'Closed';
                }
            }
        }

        // Custom Modal System
        class ModalManager {
            static show(options) {
                const {
                    title,
                    icon = 'fas fa-exclamation-triangle',
                    warning,
                    info,
                    confirmText = 'Confirm',
                    cancelText = 'Cancel',
                    confirmClass = '',
                    onConfirm,
                    onCancel
                } = options;
                
                // Create modal HTML
                const modalHtml = `
                    <div class="modal-overlay" id="customModal">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3><i class="${icon}"></i> ${title}</h3>
                            </div>
                            <div class="modal-body">
                                ${warning ? `
                                    <div class="modal-warning">
                                        <div class="modal-warning-title">
                                            <i class="fas fa-exclamation-circle"></i> Warning
                                        </div>
                                        ${warning}
                                    </div>
                                ` : ''}
                                ${info ? `
                                    <div class="modal-info">
                                        ${Object.entries(info).map(([label, value]) => `
                                            <div class="modal-info-row">
                                                <span class="modal-info-label">${label}</span>
                                                <span class="modal-info-value">${value}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                            </div>
                            <div class="modal-footer">
                                <button class="modal-btn modal-btn-cancel" onclick="ModalManager.close(false)">
                                    ${cancelText}
                                </button>
                                <button class="modal-btn modal-btn-confirm ${confirmClass}" onclick="ModalManager.close(true)">
                                    ${confirmText}
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                // Remove existing modal if any
                const existingModal = document.getElementById('customModal');
                if (existingModal) {
                    existingModal.remove();
                }
                
                // Add modal to body
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                
                // Show modal with animation
                setTimeout(() => {
                    document.getElementById('customModal').classList.add('active');
                }, 10);
                
                // Store callbacks
                window.modalCallbacks = { onConfirm, onCancel };
            }
            
            static close(confirmed) {
                const modal = document.getElementById('customModal');
                if (modal) {
                    modal.classList.remove('active');
                    setTimeout(() => {
                        modal.remove();
                        
                        // Call appropriate callback
                        if (window.modalCallbacks) {
                            if (confirmed && window.modalCallbacks.onConfirm) {
                                window.modalCallbacks.onConfirm();
                            } else if (!confirmed && window.modalCallbacks.onCancel) {
                                window.modalCallbacks.onCancel();
                            }
                            delete window.modalCallbacks;
                        }
                    }, 200);
                }
            }
        }
        
        // Update trading mode status display
        function updateTradingModeDisplay(isEnabled) {
            const statusDiv = document.getElementById('tradingModeStatus');
            const statusText = document.getElementById('tradingModeText');
            const statusIcon = document.getElementById('tradingModeIcon');
            
            if (isEnabled) {
                statusDiv.style.background = 'var(--accent-red)';
                statusText.textContent = 'LIVE TRADING MODE';
                statusText.style.color = 'white';
                statusIcon.style.animation = 'pulse 2s infinite';
            } else {
                statusDiv.style.background = 'var(--bg-tertiary)';
                statusText.textContent = 'MANUAL MODE';
                statusText.style.color = 'var(--text-secondary)';
                statusIcon.style.animation = 'none';
            }
        }
        
        // Toggle auto trade with custom modal and strict API checking
        window.toggleAutoTrade = async function() {
            const isEnabled = document.getElementById('autoTradeToggle').checked;
            
            // Show custom confirmation modal when enabling
            if (isEnabled) {
                ModalManager.show({
                    title: 'Enable Auto Trading',
                    icon: 'fas fa-robot',
                    warning: 'This will enable LIVE auto trading with REAL money. All signals will be executed automatically based on your configured parameters.',
                    info: {
                        'Trading Mode': 'LIVE',
                        'Active Signals': document.querySelectorAll('.signal-toggle:checked').length + ' of 8',
                        'Position Size': document.getElementById('numLots').value + ' lots',
                        'Broker Status': document.querySelector('.broker-status-indicator.connected') ? 'Connected' : 'Disconnected'
                    },
                    confirmText: 'Enable Auto Trading',
                    confirmClass: 'danger',
                    onConfirm: async () => {
                        await executeAutoTradeToggle(true);
                    },
                    onCancel: () => {
                        document.getElementById('autoTradeToggle').checked = false;
                    }
                });
            } else {
                // Show disable confirmation
                ModalManager.show({
                    title: 'Disable Auto Trading',
                    icon: 'fas fa-pause-circle',
                    warning: 'This will disable auto trading. Existing positions will remain open but no new trades will be executed.',
                    confirmText: 'Disable',
                    confirmClass: 'success',
                    onConfirm: async () => {
                        await executeAutoTradeToggle(false);
                    },
                    onCancel: () => {
                        document.getElementById('autoTradeToggle').checked = true;
                    }
                });
            }
        }
        
        // Execute auto trade toggle with strict API checking
        async function executeAutoTradeToggle(isEnabled) {
            try {
                // Call API to enable/disable
                const endpoint = isEnabled ? '/api/auto-trade/enable' : '/api/auto-trade/disable';
                const response = await fetch(getApiUrl(endpoint), {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                // STRICT CHECK - Only proceed if API confirms success
                if (result.success === true) { // Remove fallback - require explicit success
                    autoTradeEnabled = isEnabled;
                    
                    // Update the trading mode display
                    updateTradingModeDisplay(isEnabled);
                    
                    // Update UI with status - No second confirmation needed since we used custom modal
                    if (isEnabled) {
                        showNotification('Auto trading enabled - Real execution active!', 'success');
                    } else {
                        showNotification('Auto trading disabled', 'warning');
                    }
                    
                    // Save preference to server and localStorage
                    await saveSettingToServer('auto_trade_enabled', isEnabled.toString());
                    
                    // Update status indicator using consistent function
                    initializeAutoTradeStatus();
                } else {
                    // API explicitly returned failure
                    showNotification('Failed to toggle auto trade: ' + (result.message || 'Server error'), 'error');
                    // Revert toggle
                    document.getElementById('autoTradeToggle').checked = !isEnabled;
                    autoTradeEnabled = !isEnabled;
                    updateTradingModeDisplay(!isEnabled);
                    
                    // Show error modal with details
                    ModalManager.show({
                        title: 'Auto Trade Error',
                        icon: 'fas fa-exclamation-circle',
                        warning: `Failed to ${isEnabled ? 'enable' : 'disable'} auto trading on the server. ${result.message || 'Unknown error occurred.'}`,
                        confirmText: 'OK',
                        confirmClass: '',
                        onConfirm: () => {}
                    });
                }
            } catch (error) {
                console.error('Error toggling auto trade:', error);
                showNotification('Connection error - Auto trade state not changed', 'error');
                
                // Revert toggle on connection error
                document.getElementById('autoTradeToggle').checked = !isEnabled;
                autoTradeEnabled = !isEnabled;
                updateTradingModeDisplay(!isEnabled);
                
                // Show connection error modal
                ModalManager.show({
                    title: 'Connection Error',
                    icon: 'fas fa-wifi',
                    warning: 'Could not connect to the server to change auto trading state. Please check your connection and try again.',
                    confirmText: 'OK',
                    confirmClass: '',
                    onConfirm: () => {}
                });
            }
        }
        
        // Update auto trade status display
        async function updateAutoTradeStatus() {
            try {
                const response = await fetch(getApiUrl('/api/auto-trade/status'));
                const result = await response.json();
                
                if (result.success) {
                    const status = result.data;
                    
                    // Update toggle state
                    document.getElementById('autoTradeToggle').checked = status.enabled;
                    autoTradeEnabled = status.enabled;
                    // Just update the display using the existing function - no duplicate elements
                    updateTradingModeDisplay(status.enabled);
                    
                    // Show broker connection status
                    if (!status.connected.kite && status.mode === 'LIVE') {
                        showNotification('Warning: Kite not connected for live trading', 'warning');
                    }
                }
            } catch (error) {
                console.error('Error fetching auto trade status:', error);
            }
        }

        // Set trading mode - make it globally accessible
        window.setTradingMode = function(mode) {
            console.log(`[MODE] Switching to ${mode} mode`);
            
            // Update global mode variable
            window.currentTradingMode = mode;
            
            // Update UI - remove active state from all buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.classList.remove('btn-primary');
            });
            
            // Find and activate the correct button
            document.querySelectorAll('.mode-btn').forEach(btn => {
                if (btn.textContent.includes(mode)) {
                    btn.classList.add('active');
                    btn.classList.add('btn-primary');
                    console.log(`[MODE] Activated button for ${mode}`);
                }
            });
            
            // Store mode in localStorage for persistence
            localStorage.setItem('tradingMode', mode);
            console.log(`[MODE] Saved to localStorage: ${mode}`);
            
            // Update mode display in header if exists
            const modeDisplay = document.getElementById('currentModeDisplay');
            if (modeDisplay) {
                modeDisplay.textContent = mode;
            }
            
            // Update header stats immediately based on new mode
            if (typeof updateHeaderStats === 'function') {
                updateHeaderStats();
            }
            
            // Update other components if in paper mode
            if (mode === 'PAPER' && typeof updatePaperTradingStats === 'function') {
                updatePaperTradingStats();
            }
            
            // Send mode change to backend
            fetch(getApiUrl('/api/paper/mode'), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: mode.toLowerCase() })
            }).then(response => {
                if (response.ok) {
                    console.log(`[MODE] Backend updated to ${mode}`);
                }
            }).catch(error => {
                console.error('[MODE] Error setting mode:', error);
            });
            
            // Show notification if function is available
            if (window.showNotification) {
                window.showNotification(`Trading mode set to ${mode}`, 'success');
            } else {
                console.log(`[MODE] Notification: Trading mode set to ${mode}`);
            }
            
            // Load mode-specific data after switching
            setTimeout(() => {
                if (window.loadModeSpecificData) {
                    window.loadModeSpecificData();
                }
            }, 500);
        }

        // Emergency close all positions - make it global
        window.emergencyCloseAll = async function() {
            if (!confirm('âš ï¸ EMERGENCY CLOSE ALL POSITIONS âš ï¸\n\nThis will immediately close ALL open positions at market price!\n\nAre you absolutely sure?')) return;
            
            try {
                // Use the REAL square-off endpoint that actually closes positions
                const response = await fetch(getApiUrl('/positions/square-off-all'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const result = await response.json();
                
                // Check if we actually closed any positions
                if (result.status === 'success' || result.success) {
                    // Check if any positions were actually closed
                    if (result.order_ids && result.order_ids.length > 0) {
                        // Actual positions were closed
                        showNotification(`âœ… Successfully closed ${result.order_ids.length} position(s)`, 'success');
                        console.log('Closed orders:', result.order_ids);
                        
                        // Clear positions and refresh
                        positions = [];
                        updatePositionsTable();
                        
                        // Refresh positions after a short delay
                        setTimeout(() => {
                            loadLivePositions();
                        }, 1000);
                    } else {
                        // No positions to close - be clear about this
                        showNotification('â„¹ï¸ No open positions to close', 'info');
                        console.log('No positions were open');
                    }
                } else {
                    showNotification('âŒ Failed to close positions: ' + (result.message || result.detail || 'Unknown error'), 'error');
                }
            } catch (error) {
                showNotification('âŒ Critical error closing positions: ' + error.message, 'error');
                console.error('Emergency close failed:', error);
            }
        }

        // Copy webhook URL
        window.copyWebhookUrl = function() {
            const url = document.getElementById('webhookUrl').textContent;
            navigator.clipboard.writeText(url).then(() => {
                showNotification('Webhook URL copied to clipboard', 'success');
            });
        }

        // Test webhook
        window.testWebhook = async function() {
            try {
                const secretKey = document.getElementById('secretKey').value || 'tradingview-webhook-secret-key-2025';
                const response = await fetch(getApiUrl('/webhook/entry'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        secret: secretKey,
                        signal: 'S1',
                        strike: 25000,
                        option_type: 'PE',
                        lots: 10,
                        timestamp: new Date().toISOString(),
                        test_mode: true
                    })
                });

                if (response.ok) {
                    showNotification('Webhook test successful', 'success');
                } else {
                    showNotification('Webhook test failed', 'error');
                }
            } catch (error) {
                showNotification('Error testing webhook: ' + error.message, 'error');
            }
        }

        // Show setup wizard
        window.showSetupWizard = function() {
            // This would open a modal with step-by-step instructions
            alert('Setup wizard coming soon! For now, copy the webhook URL and add it to your TradingView alert.');
        }

        // Select hedge method
        function selectHedgeMethod(method, element) {
            // Clear all selected states
            document.querySelectorAll('.hedge-method').forEach(el => {
                el.classList.remove('selected');
            });
            
            // If called from click event, use event target; otherwise find the element
            if (element) {
                element.classList.add('selected');
            } else if (event && event.currentTarget) {
                event.currentTarget.classList.add('selected');
            } else {
                // Find the hedge method div that contains the radio button for this method
                const methodDiv = document.querySelector(`.hedge-method input[value="${method}"]`)?.closest('.hedge-method');
                if (methodDiv) {
                    methodDiv.classList.add('selected');
                }
            }
            
            // Enable/disable inputs
            if (method === 'percentage') {
                document.getElementById('hedgePercent').disabled = false;
                document.getElementById('hedgeOffset').disabled = true;
            } else {
                document.getElementById('hedgePercent').disabled = true;
                document.getElementById('hedgeOffset').disabled = false;
            }
        }

        // Update connection status
        function updateConnectionStatus(elementId, connected) {
            const element = document.getElementById(elementId);
            if (!element) {
                // Element doesn't exist, skip update
                return;
            }
            if (connected) {
                element.classList.remove('disconnected');
            } else {
                element.classList.add('disconnected');
            }
        }

        // Show notification
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                    <span>${message}</span>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    notification.remove();
                }, 300);
            }, 3000);
        }

        // Server settings storage
        let serverSettings = {};
        
        // Save setting to server database with retry
        async function saveSettingToServer(key, value) {
            try {
                serverSettings[key] = value;
                
                // Also save to localStorage immediately for offline resilience
                localStorage.setItem(key, value);
                
                const response = await fetchWithRetry(getApiUrl('/settings'), {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        key: key,
                        value: value,
                        category: getCategoryForKey(key)
                    })
                });
                
                if (response.ok) {
                    console.log(`[SETTINGS] Saved to database: ${key} = ${value}`);
                    return true;
                } else {
                    console.error('[SETTINGS] Failed to save to database, using localStorage');
                    return false;
                }
            } catch (error) {
                console.error('[SETTINGS] Error saving to database:', error);
                return false;
            }
        }
        
        // Helper to categorize settings
        function getCategoryForKey(key) {
            if (key.includes('risk')) return 'risk';
            if (key.includes('trading')) return 'trading';
            if (key.includes('expiry')) return 'expiry';
            if (key.includes('webhook')) return 'webhook';
            if (key.includes('kill')) return 'safety';
            return 'general';
        }
        
        // Load configuration from server database
        async function loadSavedConfiguration() {
            try {
                // First, try to load from server database
                const response = await fetch(getApiUrl('/settings'));
                if (response.ok) {
                    const data = await response.json();
                    serverSettings = data.settings || {};
                    console.log('[SETTINGS] Loaded from database:', serverSettings);
                    
                    // Apply server settings to UI
                    if (serverSettings.auto_trade_enabled !== undefined) {
                        const autoTrade = serverSettings.auto_trade_enabled === 'true';
                        document.getElementById('autoTradeToggle').checked = autoTrade;
                        autoTradeEnabled = autoTrade;
                        updateTradingModeDisplay(autoTrade);
                    }
                    
                    if (serverSettings.trading_mode) {
                        currentMode = serverSettings.trading_mode;
                        document.querySelectorAll('.mode-btn').forEach(btn => {
                            btn.classList.remove('active');
                            if (btn.textContent === serverSettings.trading_mode) {
                                btn.classList.add('active');
                            }
                        });
                    }
                    
                    if (serverSettings.position_size) {
                        document.getElementById('numLots').value = serverSettings.position_size;
                    }
                    
                    if (serverSettings.entry_timing) {
                        document.getElementById('entryTiming').value = serverSettings.entry_timing;
                    }
                    
                    // Initialize status indicator after loading
                    initializeAutoTradeStatus();
                    
                } else {
                    console.warn('[SETTINGS] Server unavailable, falling back to localStorage');
                    loadFromLocalStorage();
                }
            } catch (error) {
                console.error('[SETTINGS] Error loading from server:', error);
                loadFromLocalStorage();
            }
        }
        
        // Fallback function to load from localStorage
        function loadFromLocalStorage() {
            // Load auto trade setting
            const savedAutoTrade = localStorage.getItem('autoTradeEnabled');
            if (savedAutoTrade !== null) {
                const isEnabled = savedAutoTrade === 'true';
                document.getElementById('autoTradeToggle').checked = isEnabled;
                autoTradeEnabled = isEnabled;
                updateTradingModeDisplay(isEnabled);
            }
            
            // Initialize status indicator immediately
            initializeAutoTradeStatus();
            
            // Load trading mode
            const savedMode = localStorage.getItem('tradingMode');
            if (savedMode) {
                currentMode = savedMode;
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.textContent === savedMode) {
                        btn.classList.add('active');
                    }
                });
            }
            
            // Load other preferences
            const savedLots = localStorage.getItem('numLots');
            if (savedLots) {
                document.getElementById('numLots').value = savedLots;
            }
            
            // Load entry timing preference
            const savedTiming = localStorage.getItem('entryTiming');
            if (savedTiming) {
                document.getElementById('entryTiming').value = savedTiming;
            }
        }

        // Save configuration on change - to BOTH server and localStorage
        document.getElementById('numLots').addEventListener('change', async function() {
            await saveSettingToServer('position_size', this.value);
        });
        
        document.getElementById('entryTiming').addEventListener('change', async function() {
            await saveSettingToServer('entry_timing', this.value);
        });


        function updateRiskDisplay(data) {
            const riskLevel = document.getElementById('riskLevel');
            if (riskLevel) {
                riskLevel.textContent = data.risk_level;
                
                if (data.risk_level === 'HIGH') {
                    riskLevel.style.background = 'var(--accent-red)';
                } else if (data.risk_level === 'MEDIUM') {
                    riskLevel.style.background = 'var(--accent-orange)';
                } else {
                    riskLevel.style.background = 'var(--accent-green)';
                }
            }
            
            const dailyPnl = document.getElementById('dailyPnl');
            if (dailyPnl) {
                dailyPnl.textContent = `â‚¹${data.daily_pnl.toLocaleString()}`;
                dailyPnl.style.color = data.daily_pnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
            }
            
            const openPos = document.getElementById('openPositionsCount');
            if (openPos) openPos.textContent = `${data.open_positions}/3`;
            
            const exposure = document.getElementById('totalExposure');
            if (exposure) exposure.textContent = `â‚¹${data.total_exposure.toLocaleString()}`;
            
            const canTrade = document.getElementById('canTrade');
            if (canTrade) {
                canTrade.textContent = data.can_open_new ? 'YES' : 'NO';
                canTrade.style.color = data.can_open_new ? 'var(--accent-green)' : 'var(--accent-red)';
            }
            
            const warningsDiv = document.getElementById('riskWarnings');
            if (warningsDiv) {
                if (data.warnings && data.warnings.length > 0) {
                    warningsDiv.innerHTML = data.warnings.map(w => 
                        `<div class="alert alert-warning" style="padding: 8px; margin-bottom: 5px; font-size: 12px;">
                            <i class="fas fa-exclamation-triangle"></i> ${w}
                        </div>`
                    ).join('');
                } else {
                    warningsDiv.innerHTML = '';
                }
            }
        }

        window.updateRiskLimits = async function() {
            // Risk management removed from system
            return;
        }

        // Risk status removed - no longer needed

        // Alert Notification Functions
        // Wait for DOM to be ready before adding event listeners
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                setupAlertEventListeners();
            });
        } else {
            setupAlertEventListeners();
        }
        
        function setupAlertEventListeners() {
            const telegramCheckbox = document.getElementById('telegramEnabled');
            if (telegramCheckbox) {
                telegramCheckbox.addEventListener('change', function() {
                    document.getElementById('telegramConfig').style.display = this.checked ? 'block' : 'none';
                    updateAlertStatus();
                });
                console.log('[ALERT] Telegram checkbox listener attached');
            }
            
            const emailCheckbox = document.getElementById('emailEnabled');
            if (emailCheckbox) {
                emailCheckbox.addEventListener('change', function() {
                    document.getElementById('emailConfig').style.display = this.checked ? 'block' : 'none';
                    updateAlertStatus();
                });
                console.log('[ALERT] Email checkbox listener attached');
            }
        }

        function updateAlertStatus() {
            const telegramEnabled = document.getElementById('telegramEnabled').checked;
            const emailEnabled = document.getElementById('emailEnabled').checked;
            const status = document.getElementById('alertStatus');
            
            if (telegramEnabled || emailEnabled) {
                status.textContent = 'ON';
                status.style.background = 'var(--accent-green)';
                status.style.color = 'white';
            } else {
                status.textContent = 'OFF';
                status.style.background = 'var(--bg-tertiary)';
                status.style.color = 'var(--text-muted)';
            }
        }

        async function saveAlertConfig() {
            try {
                const config = {
                    telegram_enabled: document.getElementById('telegramEnabled').checked,
                    telegram_bot_token: document.getElementById('telegramBotToken').value,
                    telegram_chat_id: document.getElementById('telegramChatId').value,
                    email_enabled: document.getElementById('emailEnabled').checked,
                    email_from: document.getElementById('emailFrom').value,
                    email_password: document.getElementById('emailPassword').value,
                    email_to: document.getElementById('emailTo').value.split(',').map(e => e.trim())
                };
                
                const response = await fetch(getApiUrl('/api/alerts/config'), {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(config)
                });
                
                if (response.ok) {
                    showNotification('Alert settings saved', 'success');
                    loadAlertConfig();
                } else {
                    showNotification('Failed to save alert settings', 'error');
                }
            } catch (error) {
                console.error('Error saving alert config:', error);
                showNotification('Error saving alert settings', 'error');
            }
        }

        async function testTelegram() {
            try {
                // Direct Telegram API test for Naveen
                const botToken = "8268902303:AAFy8t0gARt0iWGech3mlIfrOZ9S4Jrt3WM";
                const chatId = "992005734";  // Naveen's chat ID
                
                const testMessage = {
                    chat_id: chatId,
                    text: `ðŸ§ª *Test Alert from TradingView Pro*\n\nHello Naveen! Your Telegram alerts are working.\n\nâœ… Bot: @Alphaone_alertbot\nâœ… Chat ID: ${chatId}\nâœ… Time: ${new Date().toLocaleTimeString()}\n\n_This is a test message from your trading dashboard._`,
                    parse_mode: "Markdown"
                };
                
                // Try direct Telegram API first
                const telegramUrl = `https://api.telegram.org/bot${botToken}/sendMessage`;
                const telegramResponse = await fetch(telegramUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(testMessage)
                });
                
                if (telegramResponse.ok) {
                    showNotification('âœ… Test alert sent to your Telegram!', 'success');
                    return;
                }
                
                // Fallback to API endpoint
                const response = await fetch(getApiUrl('/api/alerts/test/telegram'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    showNotification('Test Telegram alert sent', 'success');
                } else {
                    showNotification('Please check your network connection', 'error');
                }
            } catch (error) {
                console.error('Error testing Telegram:', error);
                // Show alternative method
                showNotification('Network blocked. Run: python send_sample_alerts.py', 'warning');
            }
        }

        async function testEmail() {
            try {
                const response = await fetch(getApiUrl('/api/alerts/test/email'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    showNotification('Test email alert sent', 'success');
                } else {
                    showNotification('Email test failed', 'error');
                }
            } catch (error) {
                console.error('Error testing email:', error);
                showNotification('Email test error', 'error');
            }
        }

        async function loadAlertConfig() {
            console.log('[ALERT] Loading alert configuration...');
            
            // Load Naveen's Telegram configuration
            const navenConfig = {
                telegram_enabled: true,
                telegram_bot_token: "8268902303:AAFy8t0gARt0iWGech3mlIfrOZ9S4Jrt3WM",
                telegram_chat_id: null  // Configure chat ID in settings
            };
            
            // Wait a bit for DOM to be fully ready
            setTimeout(() => {
                // Set Telegram fields with Naveen's config
                const telegramCheckbox = document.getElementById('telegramEnabled');
                const telegramConfigDiv = document.getElementById('telegramConfig');
                const telegramTokenInput = document.getElementById('telegramBotToken');
                const telegramChatInput = document.getElementById('telegramChatId');
                
                if (telegramCheckbox && telegramConfigDiv) {
                    console.log('[ALERT] Setting up Telegram configuration...');
                    telegramCheckbox.checked = true;
                    telegramConfigDiv.style.display = 'block';
                    
                    if (telegramTokenInput) {
                        telegramTokenInput.value = navenConfig.telegram_bot_token;
                    }
                    if (telegramChatInput) {
                        telegramChatInput.value = navenConfig.telegram_chat_id;
                    }
                    
                    // Force visibility
                    telegramConfigDiv.style.cssText = 'display: block !important;';
                    
                    // Also update the alert status
                    updateAlertStatus();
                    
                    console.log('[ALERT] Telegram config should now be visible');
                } else {
                    console.error('[ALERT] Could not find Telegram elements');
                }
            }, 100);
            
            try {
                const response = await fetch(getApiUrl('/api/alerts/config'));
                if (response.ok) {
                    const config = await response.json();
                    
                    // Override with API response if available
                    if (config.telegram_bot_token) {
                        document.getElementById('telegramBotToken').value = config.telegram_bot_token;
                    }
                    if (config.telegram_chat_id) {
                        document.getElementById('telegramChatId').value = config.telegram_chat_id;
                    }
                    
                    document.getElementById('emailEnabled').checked = config.email_enabled || false;
                    document.getElementById('emailConfig').style.display = config.email_enabled ? 'block' : 'none';
                    
                    if (config.email_from) {
                        document.getElementById('emailFrom').value = config.email_from;
                    }
                    if (config.email_to && config.email_to.length > 0) {
                        document.getElementById('emailTo').value = config.email_to.join(', ');
                    }
                    
                    updateAlertStatus();
                }
            } catch (error) {
                console.error('Error loading alert config:', error);
            }
        }

        async function loadRecentAlerts() {
            try {
                const response = await fetch(getApiUrl('/api/alerts/history?limit=10'));
                if (response.ok) {
                    const alerts = await response.json();
                    const alertsDiv = document.getElementById('recentAlerts');
                    
                    if (alerts.length > 0) {
                        alertsDiv.innerHTML = alerts.map(alert => {
                            const time = new Date(alert.timestamp).toLocaleTimeString();
                            const icon = alert.priority === 'critical' ? 'ðŸš¨' : 
                                        alert.priority === 'high' ? 'âš ï¸' : 
                                        alert.priority === 'medium' ? 'ðŸ“Œ' : 'â„¹ï¸';
                            return `<div style="padding: 5px; border-bottom: 1px solid var(--bg-tertiary);">
                                ${icon} ${time} - ${alert.title}
                            </div>`;
                        }).join('');
                    } else {
                        alertsDiv.innerHTML = '<div style="padding: 10px; text-align: center; color: var(--text-muted);">No recent alerts</div>';
                    }
                }
            } catch (error) {
                console.error('Error loading alerts:', error);
            }
        }

        window.saveAlertConfig = saveAlertConfig;
        window.testTelegram = testTelegram;
        window.testEmail = testEmail;

        // Load alert config and history on page load
        // Ensure DOM is ready before loading alert config
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                loadAlertConfig();
                loadRecentAlerts();
            });
        } else {
            // DOM is already ready
            loadAlertConfig();
            loadRecentAlerts();
        }
        setInterval(loadRecentAlerts, 60000); // Refresh every minute

        // Paper Trading Functions
        // Note: currentTradingMode is now window.currentTradingMode (set above)
        
        /* Commented out - duplicate function, using the one defined above
        async function setTradingMode(mode) {
            try {
                const response = await fetch(getApiUrl('/api/paper/mode'), {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ mode: mode })
                });
                
                if (response.ok) {
                    currentTradingMode = mode;
                    
                    // Update UI
                    document.getElementById('modeLive').classList.toggle('active', mode === 'live');
                    document.getElementById('modePaper').classList.toggle('active', mode === 'paper');
                    
                    if (mode === 'live') {
                        document.getElementById('modeLive').style.background = 'var(--accent-red)';
                        document.getElementById('modeLive').style.color = 'white';
                        document.getElementById('modePaper').style.background = 'var(--bg-tertiary)';
                        document.getElementById('modePaper').style.color = 'var(--text-secondary)';
                        
                        // Hide paper trading dashboard
                        document.getElementById('paperTradingDashboard').style.display = 'none';
                        
                        showNotification('âš ï¸ LIVE TRADING MODE - Real money at risk!', 'warning');
                    } else {
                        document.getElementById('modePaper').style.background = 'var(--accent-green)';
                        document.getElementById('modePaper').style.color = 'white';
                        document.getElementById('modeLive').style.background = 'var(--bg-tertiary)';
                        document.getElementById('modeLive').style.color = 'var(--text-secondary)';
                        
                        // Show paper trading dashboard
                        document.getElementById('paperTradingDashboard').style.display = 'block';
                        
                        showNotification('Paper trading mode - No real money', 'success');
                    }
                    
                    // Reload portfolio status
                    loadPaperPortfolio();
                } else {
                    showNotification('Failed to set trading mode', 'error');
                }
            } catch (error) {
                console.error('Error setting trading mode:', error);
                showNotification('Error setting trading mode', 'error');
            }
        }
        */
        
        async function loadPaperPortfolio() {
            try {
                const response = await fetch(getApiUrl('/api/paper/portfolio'));
                if (response.ok) {
                    const data = await response.json();
                    
                    // Update capital
                    document.getElementById('paperCapital').textContent = `â‚¹${data.capital.current.toLocaleString()}`;
                    document.getElementById('paperAvailable').textContent = `â‚¹${data.capital.available_margin.toLocaleString()}`;
                    
                    // Update P&L
                    const pnlElement = document.getElementById('paperPnl');
                    pnlElement.textContent = `â‚¹${data.pnl.total.toLocaleString()}`;
                    pnlElement.style.color = data.pnl.total >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                    
                    // Update trades
                    document.getElementById('paperActiveTrades').textContent = data.trades.active;
                    document.getElementById('paperTotalTrades').textContent = data.trades.total;
                    document.getElementById('paperWinRate').textContent = `${data.trades.win_rate.toFixed(1)}%`;
                }
            } catch (error) {
                console.error('Error loading paper portfolio:', error);
            }
        }
        
        async function loadPaperTrades() {
            try {
                const response = await fetch(getApiUrl('/api/paper/trades'));
                if (response.ok) {
                    const trades = await response.json();
                    const historyDiv = document.getElementById('paperTradeHistory');
                    
                    if (trades.length > 0) {
                        historyDiv.innerHTML = trades.slice(0, 10).map(trade => {
                            const time = new Date(trade.entry_time).toLocaleTimeString();
                            const pnlColor = trade.pnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                            return `<div style="padding: 8px; border-bottom: 1px solid var(--bg-tertiary);">
                                <span>${time}</span> - 
                                <span>${trade.signal}</span> 
                                <span>${trade.strike}${trade.type}</span>
                                <span style="color: ${pnlColor}; margin-left: 10px;">â‚¹${trade.pnl.toFixed(0)}</span>
                            </div>`;
                        }).join('');
                    } else {
                        historyDiv.innerHTML = '<div style="padding: 10px; text-align: center; color: var(--text-muted);">No paper trades yet</div>';
                    }
                }
            } catch (error) {
                console.error('Error loading paper trades:', error);
            }
        }
        
        async function loadStrategyComparison() {
            try {
                const response = await fetch(getApiUrl('/api/paper/compare'));
                if (response.ok) {
                    const strategies = await response.json();
                    const comparisonDiv = document.getElementById('strategyComparison');
                    
                    if (strategies.length > 0) {
                        comparisonDiv.innerHTML = `
                            <table style="width: 100%; font-size: 11px;">
                                <thead>
                                    <tr style="border-bottom: 1px solid var(--bg-tertiary);">
                                        <th style="text-align: left; padding: 5px;">Strategy</th>
                                        <th style="text-align: right; padding: 5px;">Trades</th>
                                        <th style="text-align: right; padding: 5px;">Win Rate</th>
                                        <th style="text-align: right; padding: 5px;">P&L</th>
                                        <th style="text-align: right; padding: 5px;">Sharpe</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${strategies.map(s => `
                                        <tr style="border-bottom: 1px solid var(--bg-tertiary);">
                                            <td style="padding: 5px;">${s.strategy_name}</td>
                                            <td style="text-align: right; padding: 5px;">${s.total_trades}</td>
                                            <td style="text-align: right; padding: 5px;">${s.win_rate.toFixed(1)}%</td>
                                            <td style="text-align: right; padding: 5px; color: ${s.total_pnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'}">
                                                â‚¹${s.total_pnl.toFixed(0)}
                                            </td>
                                            <td style="text-align: right; padding: 5px;">${s.sharpe_ratio.toFixed(2)}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        `;
                    } else {
                        comparisonDiv.innerHTML = '<div style="padding: 10px; text-align: center; color: var(--text-muted);">No strategy data available</div>';
                    }
                }
            } catch (error) {
                console.error('Error loading strategy comparison:', error);
            }
        }
        
        async function resetPaperPortfolio() {
            if (confirm('Are you sure you want to reset the paper trading portfolio? All trades will be cleared.')) {
                try {
                    const strategy = document.getElementById('strategySelect').value;
                    const response = await fetch(getApiUrl(`/api/paper/reset/${strategy}`), {
                        method: 'POST'
                    });
                    
                    if (response.ok) {
                        showNotification('Paper portfolio reset', 'success');
                        loadPaperPortfolio();
                        loadPaperTrades();
                    } else {
                        showNotification('Failed to reset portfolio', 'error');
                    }
                } catch (error) {
                    console.error('Error resetting portfolio:', error);
                    showNotification('Error resetting portfolio', 'error');
                }
            }
        }
        
        // Functions already made global above
        window.loadStrategyComparison = loadStrategyComparison;
        window.resetPaperPortfolio = resetPaperPortfolio;
        
        // Load paper trading data on page load
        // Commented out - paper trading elements not present in UI
        // loadPaperPortfolio();
        // loadPaperTrades();
        // setInterval(loadPaperPortfolio, 30000); // Refresh every 30 seconds
        // setInterval(loadPaperTrades, 60000); // Refresh every minute

        // Add more event listeners as needed
    
        
// ============== PRODUCTION TRADE EXECUTION ==============
/**
 * Production-Ready Trade Execution Frontend
 * Complete implementation with proper error handling and order tracking
 */

// Production Trade Execution Function
window.executeProductionTrade = async function(signal, strike, type, action = 'ENTRY') {
    const mode = 'LIVE';
    console.log(`[TRADE] Executing production trade: ${signal} ${strike}${type}`);
    
    // Gather all configuration
    const config = gatherTradeConfiguration();
    
    // Validate before execution
    const validation = validateTradeParameters(signal, strike, type, config);
    if (!validation.valid) {
        showNotification(`Validation failed: ${validation.errors.join(', ')}`, 'error');
        return false;
    }
    
    // Get current spot price
    const spotPrice = await fetchCurrentSpotPrice();
    
    // Log the actual configuration for debugging
    console.log('[TRADE] Configuration gathered:', config);
    console.log('[TRADE] Lots from UI:', config.numLots);
    
    // Build complete request payload with ALL UI settings
    const payload = {
        // Signal and market data
        signal_type: signal,
        current_spot: spotPrice,
        
        // Position details
        strike: strike,
        option_type: type,
        quantity: config.numLots,
        action: action,
        
        // EXPIRY - Most important!
        expiry: config.selectedExpiry,
        
        // Exit configuration
        exit_time: config.exitTime,
        exit_day_offset: config.exitDayOffset,
        use_weekday_config: config.useWeekdayConfig,
        
        // AMO settings
        amo_enabled: config.amoEnabled,
        
        // Hedge configuration
        hedge_enabled: config.hedgeEnabled,
        hedge_offset: config.hedgeOffset,
        hedge_percentage: 30.0,
        
        // Stop loss parameters
        profit_lock_enabled: config.profitLockEnabled,
        profit_target: config.profitTarget,
        profit_lock: config.profitLock,
        trailing_stop_enabled: config.trailingStopEnabled,
        trail_percent: config.trailPercent,
        
        // Entry timing
        entry_timing: config.entryTiming,
        
        // Risk limits
        max_loss_per_trade: config.maxLossPerTrade || 20000.0,
        max_exposure: config.maxExposure || 200000.0,
        max_position_size: 30,
        
        // Active signals (for reference)
        active_signals: config.activeSignals
    };
    
    // Log the final payload being sent
    console.log('[TRADE] Final payload to API:', JSON.stringify(payload, null, 2));
    console.log('[TRADE] Specifically, quantity field:', payload.quantity);
    
    // Show confirmation dialog
    const confirmed = await showTradeConfirmation(payload);
    if (!confirmed) return false;
    
    // Show loading state
    const loadingId = showLoadingOverlay('Executing trade...');
    
    try {
        // Execute the trade
        const response = await fetch(getApiUrl('/api/v1/execute-trade'), {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${getAuthToken()}`  // Add auth if needed
            },
            body: JSON.stringify(payload)
        });
        
        const result = await response.json();
        
        if (response.ok && result.success) {
            // Trade successful
            await handleTradeSuccess(result);
            return true;
        } else {
            // Trade failed
            await handleTradeFailure(result, response.status);
            return false;
        }
        
    } catch (error) {
        // Network or other error
        await handleTradeError(error);
        return false;
        
    } finally {
        hideLoadingOverlay(loadingId);
    }
};

// Gather all trade configuration from UI
function gatherTradeConfiguration() {
    // Get all UI configuration including expiry, exit time, AMO, etc.
    const lotsElement = document.getElementById('numLots');
    const lotsValue = lotsElement ? parseInt(lotsElement.value) : null;
    console.log('[CONFIG] Lots value from UI:', lotsValue);
    
    // Use UI value, NOT tempLots (which is for modified alerts only)
    // Clear tempLots after reading to prevent it from affecting future trades
    const finalLots = lotsValue || 5; // Use UI value or default to 5
    delete window.tempLots; // Clear any temporary override
    
    return {
        // Position sizing - Always use UI value
        numLots: finalLots,
        
        // Expiry configuration - IMPORTANT!
        selectedExpiry: document.getElementById('expiryDate')?.value || getCurrentExpiry(),
        
        // Exit timing configuration
        exitTime: document.getElementById('exitTime')?.value || '15:25',
        exitDayOffset: parseInt(document.getElementById('exitDayOffset')?.value) || 0,
        useWeekdayConfig: document.getElementById('useWeekdayConfig')?.checked || false,
        
        // AMO configuration
        amoEnabled: document.getElementById('amoEnabled')?.checked || false,
        
        // Hedge configuration
        hedgeEnabled: document.getElementById('enableHedge')?.checked || false,
        hedgeOffset: parseInt(document.getElementById('hedgeOffset')?.value) || 200,
        
        // Stop loss management
        profitLockEnabled: document.getElementById('profitLockEnabled')?.checked || false,
        profitTarget: parseFloat(document.getElementById('profitTarget')?.value) || 10,
        profitLock: parseFloat(document.getElementById('profitLock')?.value) || 5,
        trailingStopEnabled: document.getElementById('trailingStopEnabled')?.checked || false,
        trailPercent: parseFloat(document.getElementById('trailPercent')?.value) || 1,
        
        // Entry timing
        entryTiming: document.getElementById('entryTiming')?.value || 'immediate',
        
        // Risk management
        maxLossPerTrade: parseFloat(document.getElementById('maxLossPerTrade')?.value) || 20000,
        maxExposure: parseFloat(document.getElementById('maxExposure')?.value) || 200000,
        
        // Active signals (for auto trade)
        activeSignals: Array.from(document.querySelectorAll('.signal-toggle:checked')).map(cb => cb.getAttribute('data-signal') || cb.value).filter(v => v && v !== 'on')
    };
}

// Validate trade parameters
function validateTradeParameters(signal, strike, type, config) {
    const errors = [];
    
    // Validate signal
    const validSignals = ['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8'];
    if (!validSignals.includes(signal)) {
        errors.push(`Invalid signal: ${signal}`);
    }
    
    // Validate strike
    if (strike < 10000 || strike > 50000) {
        errors.push(`Strike ${strike} out of range`);
    }
    if (strike % 50 !== 0) {
        errors.push('Strike must be multiple of 50');
    }
    
    // Validate option type
    if (!['PE', 'CE'].includes(type)) {
        errors.push(`Invalid option type: ${type}`);
    }
    
    // Validate quantity
    if (config.numLots < 1 || config.numLots > 30) {
        errors.push('Quantity must be between 1 and 30 lots');
    }
    
    // Validate stop loss config
    if (config.profitLockEnabled) {
        if (config.profitTarget <= 0) {
            errors.push('Profit target must be positive');
        }
        if (config.profitLock >= config.profitTarget) {
            errors.push('Profit lock must be less than target');
        }
    }
    
    return {
        valid: errors.length === 0,
        errors: errors
    };
}

// Fetch current NIFTY spot price
async function fetchCurrentSpotPrice() {
    try {
        const response = await fetch(getApiUrl('/api/live/nifty-spot'));
        if (response.ok) {
            const data = await response.json();
            if (data.success && data.data) {
                return data.data.ltp;
            }
        }
    } catch (e) {
        console.warn('Could not fetch spot price, using default');
    }
    return null; // No data available
}

// Show trade confirmation dialog with full details
async function showTradeConfirmation(payload) {
    const lotSize = 75;
    const totalQty = payload.quantity * lotSize;
    const hedgeStrike = payload.hedge_enabled ? 
        (payload.option_type === 'PE' ? 
            payload.strike - payload.hedge_offset : 
            payload.strike + payload.hedge_offset) : null;
    
    // Create detailed confirmation message
    let message = `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘     PRODUCTION TRADE CONFIRMATION     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Signal: ${payload.signal_type}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“Š POSITION DETAILS:
â€¢ Main Leg: SELL ${payload.strike}${payload.option_type}
${payload.hedge_enabled ? `â€¢ Hedge Leg: BUY ${hedgeStrike}${payload.option_type}` : 'â€¢ Hedge: DISABLED âš ï¸'}
â€¢ Quantity: ${payload.quantity} lots (${totalQty} qty)
â€¢ Spot Price: ${payload.current_spot.toFixed(2)}

ðŸ“ˆ RISK MANAGEMENT:
â€¢ Max Risk: ${payload.hedge_enabled ? `â‚¹${(payload.hedge_offset * totalQty).toLocaleString()}` : 'UNLIMITED âš ï¸'}
â€¢ Est. Margin: â‚¹${(payload.quantity * 15000).toLocaleString()}
${payload.profit_lock_enabled ? `â€¢ Profit Lock: ${payload.profit_target}% target, ${payload.profit_lock}% lock` : ''}
${payload.trailing_stop_enabled ? `â€¢ Trailing Stop: ${payload.trail_percent}%` : ''}

â° ENTRY: ${payload.entry_timing === 'immediate' ? 'IMMEDIATE' : 'NEXT CANDLE'}

âš ï¸ THIS IS A REAL MONEY TRADE âš ï¸
`;
    
    return confirm(message);
}

// Show loading overlay
function showLoadingOverlay(message) {
    const overlayId = `loading-${Date.now()}`;
    const overlay = document.createElement('div');
    overlay.id = overlayId;
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100000;
    `;
    
    overlay.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 30px; border-radius: 12px; text-align: center;">
            <div class="spinner" style="width: 50px; height: 50px; border: 4px solid var(--border-color); border-top-color: var(--accent-blue); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
            <h3 style="color: var(--text-primary); margin: 0 0 10px 0;">${message}</h3>
            <p style="color: var(--text-muted); margin: 0;">Please wait, do not close this window...</p>
        </div>
        <style>
            @keyframes spin { to { transform: rotate(360deg); } }
        </style>
    `;
    
    document.body.appendChild(overlay);
    return overlayId;
}

// Hide loading overlay
function hideLoadingOverlay(overlayId) {
    const overlay = document.getElementById(overlayId);
    if (overlay) {
        overlay.remove();
    }
}

// Handle successful trade execution
async function handleTradeSuccess(result) {
    console.log('[TRADE] Success:', result);
    
    // Create success message
    let message = `âœ… Trade Executed Successfully!\n\n`;
    
    if (result.main_order) {
        message += `Main Order: ${result.main_order.order_id}\n`;
        message += `Strike: ${result.main_order.strike}${result.main_order.type}\n`;
        message += `Quantity: ${result.main_order.quantity}\n`;
        message += `Premium: â‚¹${result.main_order.premium}\n\n`;
    }
    
    if (result.hedge_order) {
        message += `Hedge Order: ${result.hedge_order.order_id}\n`;
        message += `Strike: ${result.hedge_order.strike}${result.hedge_order.type}\n`;
        message += `Quantity: ${result.hedge_order.quantity}\n`;
        message += `Premium: â‚¹${result.hedge_order.premium}\n\n`;
    }
    
    if (result.risk_metrics) {
        message += `Max Risk: â‚¹${result.risk_metrics.max_risk.toLocaleString()}\n`;
        message += `Margin Used: â‚¹${result.risk_metrics.margin_required.toLocaleString()}\n`;
        message += `Breakeven: ${result.risk_metrics.breakeven}`;
    }
    
    // Show detailed success notification
    showDetailedNotification(message, 'success');
    
    // Update UI
    if (window.loadLivePositions) {
        await window.loadLivePositions();
    }
    
    // Track the order
    trackOrderStatus(result.position_id, result.main_order.order_id, result.hedge_order?.order_id);
    
    // Play success sound if available
    playSound('success');
}

// Handle trade failure
async function handleTradeFailure(result, statusCode) {
    console.error('[TRADE] Failed:', result);
    
    let message = 'âŒ Trade Execution Failed\n\n';
    
    if (statusCode === 400) {
        message += 'Validation Error:\n';
    } else if (statusCode === 403) {
        message += 'Risk Limit Exceeded:\n';
    } else {
        message += 'Server Error:\n';
    }
    
    message += result.detail || result.message || 'Unknown error occurred';
    
    // Add helpful suggestions
    message += '\n\nPlease check:\n';
    message += 'â€¢ API connection status\n';
    message += 'â€¢ Broker connection\n';
    message += 'â€¢ Available margin\n';
    message += 'â€¢ Market hours (9:15 AM - 3:30 PM)\n';
    
    showDetailedNotification(message, 'error');
    playSound('error');
}

// Handle network or unexpected errors
async function handleTradeError(error) {
    console.error('[TRADE] Error:', error);
    
    let message = 'âŒ Trade Execution Error\n\n';
    message += error.message || 'Network error occurred';
    message += '\n\nPossible causes:\n';
    message += 'â€¢ API server not running\n';
    message += 'â€¢ Network connection issue\n';
    message += 'â€¢ Invalid API endpoint\n';
    
    showDetailedNotification(message, 'error');
    playSound('error');
}

// Track order status
function trackOrderStatus(positionId, mainOrderId, hedgeOrderId) {
    // Create order tracking entry
    const trackingData = {
        positionId: positionId,
        mainOrderId: mainOrderId,
        hedgeOrderId: hedgeOrderId,
        timestamp: new Date().toISOString(),
        status: 'PENDING'
    };
    
    // Store in session
    if (!window.activeOrders) {
        window.activeOrders = {};
    }
    window.activeOrders[positionId] = trackingData;
    
    // Start polling for status updates
    const pollInterval = setInterval(async () => {
        try {
            const response = await fetch(getApiUrl(`/api/order-status/${mainOrderId}`));
            if (response.ok) {
                const status = await response.json();
                
                // Update tracking data
                trackingData.status = status.status;
                
                // Update UI if needed
                updateOrderStatusDisplay(positionId, status);
                
                // Stop polling if order is complete or rejected
                if (['COMPLETE', 'REJECTED', 'CANCELLED'].includes(status.status)) {
                    clearInterval(pollInterval);
                }
            }
        } catch (e) {
            console.error('Error polling order status:', e);
        }
    }, 5000); // Poll every 5 seconds
    
    // Stop polling after 5 minutes
    setTimeout(() => clearInterval(pollInterval), 300000);
}

// Update order status display
function updateOrderStatusDisplay(positionId, status) {
    // Find position in UI and update status
    const positionElement = document.querySelector(`[data-position-id="${positionId}"]`);
    if (positionElement) {
        const statusBadge = positionElement.querySelector('.status-badge');
        if (statusBadge) {
            statusBadge.textContent = status.status;
            statusBadge.className = `status-badge status-${status.status.toLowerCase()}`;
        }
    }
}

// Show detailed notification
function showDetailedNotification(message, type) {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `detailed-notification ${type}`;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        max-width: 400px;
        padding: 20px;
        background: ${type === 'success' ? '#1b5e20' : '#b71c1c'};
        color: white;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 100001;
        font-family: monospace;
        white-space: pre-line;
        animation: slideIn 0.3s ease;
    `;
    
    notification.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: start;">
            <div style="flex: 1;">${message}</div>
            <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: white; cursor: pointer; font-size: 20px; margin-left: 10px;">Ã—</button>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.remove();
        }
    }, 10000);
}

// Play sound notification
function playSound(type) {
    try {
        const audio = new Audio();
        if (type === 'success') {
            audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSpopdzxvnkwBz6A0fPTezEHPHvI8NeCLgUjceD47Xg+HUmr3+miXh0wtNfXimcdaaTb1nk6FEGk4OWeMClbo9zbi1ghMLzY2IM1FDmh3OacTRY2n9vWljsWS6rn6Z1RGlCw8OecVhw7k9XikVsyb7Pp6pNXHF2t0sKCWyBbvNjRfS0UN5rv/LJlDwBtp/Dm0YJ0U5vO4KZ+dkt1mce5l4mTV6LZ7q1tFABSgp+iiaB+YGyBgsHI2+2SX0mLu6yVkWdXZHeEqKWtmHVIUYKKk4dqam1ybWpue3p9rLe5g11YVob2/vSmUBEFQ3Tu5VkaBw5v0OLFhB0ECy9w3euygS0FJ3jg5ZcrAQJPydnbsiMDDEzP1+KTIAZJX+TqxGw4FRCmteHIrGQ0FEmNzNWfkUALPYO38NSEJgs2W8rIx3szEAMZm9Xs';
        } else {
            audio.src = 'data:audio/wav;base64,UklGRhYCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YfIBAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAA';
        }
        audio.play();
    } catch (e) {
        // Ignore audio errors
    }
}

// Get auth token if using authentication
function getAuthToken() {
    return localStorage.getItem('authToken') || '';
}

// Replace the old executeTrade function
window.executeTrade = window.executeProductionTrade;

// Update manual execution to use production function
window.executeManualTrade = async function(alertId) {
    const alert = window.pendingAlerts[alertId];
    if (!alert) {
        showNotification('Alert not found', 'error');
        return;
    }
    
    // Immediately disable all buttons
    const alertElement = document.getElementById(alertId);
    const executeBtn = alertElement.querySelector('.btn-execute');
    const allButtons = alertElement.querySelectorAll('.btn-alert-action');
    
    allButtons.forEach(btn => btn.disabled = true);
    
    // Show loading state
    const originalBtnHTML = executeBtn.innerHTML;
    executeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Executing...';
    
    try {
        // Use production execution
        const success = await executeProductionTrade(
            alert.signal,
            alert.strike,
            alert.type,
            alert.action
        );
        
        if (success) {
            // Mark as executed
            alertElement.classList.add('executed');
            alertElement.style.opacity = '0.7';
            alertElement.style.borderColor = 'var(--accent-green)';
            executeBtn.innerHTML = '<i class="fas fa-check"></i> Executed';
            executeBtn.style.background = 'var(--accent-green)';
            
            // Remove from pending
            delete window.pendingAlerts[alertId];
            updatePendingAlertsCount();
        } else {
            // Re-enable buttons on failure
            allButtons.forEach(btn => btn.disabled = false);
            executeBtn.innerHTML = originalBtnHTML;
        }
    } catch (error) {
        console.error('Manual execution error:', error);
        allButtons.forEach(btn => btn.disabled = false);
        executeBtn.innerHTML = originalBtnHTML;
    }
};

console.log('âœ… Production-ready trade execution loaded');
// =========================================================


        
// ============== PRODUCTION TRADE EXECUTION ==============
/**
 * Production-Ready Trade Execution Frontend
 * Complete implementation with proper error handling and order tracking
 */

// Production Trade Execution Function
window.executeProductionTrade = async function(signal, strike, type, action = 'ENTRY') {
    const mode = 'LIVE';
    console.log(`[TRADE] Executing production trade: ${signal} ${strike}${type}`);
    
    // Gather all configuration
    const config = gatherTradeConfiguration();
    
    // Validate before execution
    const validation = validateTradeParameters(signal, strike, type, config);
    if (!validation.valid) {
        showNotification(`Validation failed: ${validation.errors.join(', ')}`, 'error');
        return false;
    }
    
    // Get current spot price
    const spotPrice = await fetchCurrentSpotPrice();
    
    // Log the actual configuration for debugging
    console.log('[TRADE] Configuration gathered:', config);
    console.log('[TRADE] Lots from UI:', config.numLots);
    
    // Build complete request payload with ALL UI settings
    const payload = {
        // Signal and market data
        signal_type: signal,
        current_spot: spotPrice,
        
        // Position details
        strike: strike,
        option_type: type,
        quantity: config.numLots,
        action: action,
        
        // EXPIRY - Most important!
        expiry: config.selectedExpiry,
        
        // Exit configuration
        exit_time: config.exitTime,
        exit_day_offset: config.exitDayOffset,
        use_weekday_config: config.useWeekdayConfig,
        
        // AMO settings
        amo_enabled: config.amoEnabled,
        
        // Hedge configuration
        hedge_enabled: config.hedgeEnabled,
        hedge_offset: config.hedgeOffset,
        hedge_percentage: 30.0,
        
        // Stop loss parameters
        profit_lock_enabled: config.profitLockEnabled,
        profit_target: config.profitTarget,
        profit_lock: config.profitLock,
        trailing_stop_enabled: config.trailingStopEnabled,
        trail_percent: config.trailPercent,
        
        // Entry timing
        entry_timing: config.entryTiming,
        
        // Risk limits
        max_loss_per_trade: config.maxLossPerTrade || 20000.0,
        max_exposure: config.maxExposure || 200000.0,
        max_position_size: 30,
        
        // Active signals (for reference)
        active_signals: config.activeSignals
    };
    
    // Log the final payload being sent
    console.log('[TRADE] Final payload to API:', JSON.stringify(payload, null, 2));
    console.log('[TRADE] Specifically, quantity field:', payload.quantity);
    
    // Show confirmation dialog
    const confirmed = await showTradeConfirmation(payload);
    if (!confirmed) return false;
    
    // Show loading state
    const loadingId = showLoadingOverlay('Executing trade...');
    
    try {
        // Execute the trade
        const response = await fetch(getApiUrl('/api/v1/execute-trade'), {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${getAuthToken()}`  // Add auth if needed
            },
            body: JSON.stringify(payload)
        });
        
        const result = await response.json();
        
        if (response.ok && result.success) {
            // Trade successful
            await handleTradeSuccess(result);
            return true;
        } else {
            // Trade failed
            await handleTradeFailure(result, response.status);
            return false;
        }
        
    } catch (error) {
        // Network or other error
        await handleTradeError(error);
        return false;
        
    } finally {
        hideLoadingOverlay(loadingId);
    }
};

// Gather all trade configuration from UI
function gatherTradeConfiguration() {
    // Get all UI configuration including expiry, exit time, AMO, etc.
    const lotsElement = document.getElementById('numLots');
    const lotsValue = lotsElement ? parseInt(lotsElement.value) : null;
    console.log('[CONFIG] Lots value from UI:', lotsValue);
    
    // Use UI value, NOT tempLots (which is for modified alerts only)
    // Clear tempLots after reading to prevent it from affecting future trades
    const finalLots = lotsValue || 5; // Use UI value or default to 5
    delete window.tempLots; // Clear any temporary override
    
    return {
        // Position sizing - Always use UI value
        numLots: finalLots,
        
        // Expiry configuration - IMPORTANT!
        selectedExpiry: document.getElementById('expiryDate')?.value || getCurrentExpiry(),
        
        // Exit timing configuration
        exitTime: document.getElementById('exitTime')?.value || '15:25',
        exitDayOffset: parseInt(document.getElementById('exitDayOffset')?.value) || 0,
        useWeekdayConfig: document.getElementById('useWeekdayConfig')?.checked || false,
        
        // AMO configuration
        amoEnabled: document.getElementById('amoEnabled')?.checked || false,
        
        // Hedge configuration
        hedgeEnabled: document.getElementById('enableHedge')?.checked || false,
        hedgeOffset: parseInt(document.getElementById('hedgeOffset')?.value) || 200,
        
        // Stop loss management
        profitLockEnabled: document.getElementById('profitLockEnabled')?.checked || false,
        profitTarget: parseFloat(document.getElementById('profitTarget')?.value) || 10,
        profitLock: parseFloat(document.getElementById('profitLock')?.value) || 5,
        trailingStopEnabled: document.getElementById('trailingStopEnabled')?.checked || false,
        trailPercent: parseFloat(document.getElementById('trailPercent')?.value) || 1,
        
        // Entry timing
        entryTiming: document.getElementById('entryTiming')?.value || 'immediate',
        
        // Risk management
        maxLossPerTrade: parseFloat(document.getElementById('maxLossPerTrade')?.value) || 20000,
        maxExposure: parseFloat(document.getElementById('maxExposure')?.value) || 200000,
        
        // Active signals (for auto trade)
        activeSignals: Array.from(document.querySelectorAll('.signal-toggle:checked')).map(cb => cb.getAttribute('data-signal') || cb.value).filter(v => v && v !== 'on')
    };
}

// Validate trade parameters
function validateTradeParameters(signal, strike, type, config) {
    const errors = [];
    
    // Validate signal
    const validSignals = ['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8'];
    if (!validSignals.includes(signal)) {
        errors.push(`Invalid signal: ${signal}`);
    }
    
    // Validate strike
    if (strike < 10000 || strike > 50000) {
        errors.push(`Strike ${strike} out of range`);
    }
    if (strike % 50 !== 0) {
        errors.push('Strike must be multiple of 50');
    }
    
    // Validate option type
    if (!['PE', 'CE'].includes(type)) {
        errors.push(`Invalid option type: ${type}`);
    }
    
    // Validate quantity
    if (config.numLots < 1 || config.numLots > 30) {
        errors.push('Quantity must be between 1 and 30 lots');
    }
    
    // Validate stop loss config
    if (config.profitLockEnabled) {
        if (config.profitTarget <= 0) {
            errors.push('Profit target must be positive');
        }
        if (config.profitLock >= config.profitTarget) {
            errors.push('Profit lock must be less than target');
        }
    }
    
    return {
        valid: errors.length === 0,
        errors: errors
    };
}

// Fetch current NIFTY spot price
async function fetchCurrentSpotPrice() {
    try {
        const response = await fetch(getApiUrl('/api/live/nifty-spot'));
        if (response.ok) {
            const data = await response.json();
            if (data.success && data.data) {
                return data.data.ltp;
            }
        }
    } catch (e) {
        console.warn('Could not fetch spot price, using default');
    }
    return null; // No data available
}

// Show trade confirmation dialog with full details
async function showTradeConfirmation(payload) {
    const lotSize = 75;
    const totalQty = payload.quantity * lotSize;
    const hedgeStrike = payload.hedge_enabled ? 
        (payload.option_type === 'PE' ? 
            payload.strike - payload.hedge_offset : 
            payload.strike + payload.hedge_offset) : null;
    
    // Create detailed confirmation message
    let message = `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘     PRODUCTION TRADE CONFIRMATION     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Signal: ${payload.signal_type}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“Š POSITION DETAILS:
â€¢ Main Leg: SELL ${payload.strike}${payload.option_type}
${payload.hedge_enabled ? `â€¢ Hedge Leg: BUY ${hedgeStrike}${payload.option_type}` : 'â€¢ Hedge: DISABLED âš ï¸'}
â€¢ Quantity: ${payload.quantity} lots (${totalQty} qty)
â€¢ Spot Price: ${payload.current_spot.toFixed(2)}

ðŸ“ˆ RISK MANAGEMENT:
â€¢ Max Risk: ${payload.hedge_enabled ? `â‚¹${(payload.hedge_offset * totalQty).toLocaleString()}` : 'UNLIMITED âš ï¸'}
â€¢ Est. Margin: â‚¹${(payload.quantity * 15000).toLocaleString()}
${payload.profit_lock_enabled ? `â€¢ Profit Lock: ${payload.profit_target}% target, ${payload.profit_lock}% lock` : ''}
${payload.trailing_stop_enabled ? `â€¢ Trailing Stop: ${payload.trail_percent}%` : ''}

â° ENTRY: ${payload.entry_timing === 'immediate' ? 'IMMEDIATE' : 'NEXT CANDLE'}

âš ï¸ THIS IS A REAL MONEY TRADE âš ï¸
`;
    
    return confirm(message);
}

// Show loading overlay
function showLoadingOverlay(message) {
    const overlayId = `loading-${Date.now()}`;
    const overlay = document.createElement('div');
    overlay.id = overlayId;
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100000;
    `;
    
    overlay.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 30px; border-radius: 12px; text-align: center;">
            <div class="spinner" style="width: 50px; height: 50px; border: 4px solid var(--border-color); border-top-color: var(--accent-blue); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
            <h3 style="color: var(--text-primary); margin: 0 0 10px 0;">${message}</h3>
            <p style="color: var(--text-muted); margin: 0;">Please wait, do not close this window...</p>
        </div>
        <style>
            @keyframes spin { to { transform: rotate(360deg); } }
        </style>
    `;
    
    document.body.appendChild(overlay);
    return overlayId;
}

// Hide loading overlay
function hideLoadingOverlay(overlayId) {
    const overlay = document.getElementById(overlayId);
    if (overlay) {
        overlay.remove();
    }
}

// Handle successful trade execution
async function handleTradeSuccess(result) {
    console.log('[TRADE] Success:', result);
    
    // Create success message
    let message = `âœ… Trade Executed Successfully!\n\n`;
    
    if (result.main_order) {
        message += `Main Order: ${result.main_order.order_id}\n`;
        message += `Strike: ${result.main_order.strike}${result.main_order.type}\n`;
        message += `Quantity: ${result.main_order.quantity}\n`;
        message += `Premium: â‚¹${result.main_order.premium}\n\n`;
    }
    
    if (result.hedge_order) {
        message += `Hedge Order: ${result.hedge_order.order_id}\n`;
        message += `Strike: ${result.hedge_order.strike}${result.hedge_order.type}\n`;
        message += `Quantity: ${result.hedge_order.quantity}\n`;
        message += `Premium: â‚¹${result.hedge_order.premium}\n\n`;
    }
    
    if (result.risk_metrics) {
        message += `Max Risk: â‚¹${result.risk_metrics.max_risk.toLocaleString()}\n`;
        message += `Margin Used: â‚¹${result.risk_metrics.margin_required.toLocaleString()}\n`;
        message += `Breakeven: ${result.risk_metrics.breakeven}`;
    }
    
    // Show detailed success notification
    showDetailedNotification(message, 'success');
    
    // Update UI
    if (window.loadLivePositions) {
        await window.loadLivePositions();
    }
    
    // Track the order
    trackOrderStatus(result.position_id, result.main_order.order_id, result.hedge_order?.order_id);
    
    // Play success sound if available
    playSound('success');
}

// Handle trade failure
async function handleTradeFailure(result, statusCode) {
    console.error('[TRADE] Failed:', result);
    
    let message = 'âŒ Trade Execution Failed\n\n';
    
    if (statusCode === 400) {
        message += 'Validation Error:\n';
    } else if (statusCode === 403) {
        message += 'Risk Limit Exceeded:\n';
    } else {
        message += 'Server Error:\n';
    }
    
    message += result.detail || result.message || 'Unknown error occurred';
    
    // Add helpful suggestions
    message += '\n\nPlease check:\n';
    message += 'â€¢ API connection status\n';
    message += 'â€¢ Broker connection\n';
    message += 'â€¢ Available margin\n';
    message += 'â€¢ Market hours (9:15 AM - 3:30 PM)\n';
    
    showDetailedNotification(message, 'error');
    playSound('error');
}

// Handle network or unexpected errors
async function handleTradeError(error) {
    console.error('[TRADE] Error:', error);
    
    let message = 'âŒ Trade Execution Error\n\n';
    message += error.message || 'Network error occurred';
    message += '\n\nPossible causes:\n';
    message += 'â€¢ API server not running\n';
    message += 'â€¢ Network connection issue\n';
    message += 'â€¢ Invalid API endpoint\n';
    
    showDetailedNotification(message, 'error');
    playSound('error');
}

// Track order status
function trackOrderStatus(positionId, mainOrderId, hedgeOrderId) {
    // Create order tracking entry
    const trackingData = {
        positionId: positionId,
        mainOrderId: mainOrderId,
        hedgeOrderId: hedgeOrderId,
        timestamp: new Date().toISOString(),
        status: 'PENDING'
    };
    
    // Store in session
    if (!window.activeOrders) {
        window.activeOrders = {};
    }
    window.activeOrders[positionId] = trackingData;
    
    // Start polling for status updates
    const pollInterval = setInterval(async () => {
        try {
            const response = await fetch(getApiUrl(`/api/order-status/${mainOrderId}`));
            if (response.ok) {
                const status = await response.json();
                
                // Update tracking data
                trackingData.status = status.status;
                
                // Update UI if needed
                updateOrderStatusDisplay(positionId, status);
                
                // Stop polling if order is complete or rejected
                if (['COMPLETE', 'REJECTED', 'CANCELLED'].includes(status.status)) {
                    clearInterval(pollInterval);
                }
            }
        } catch (e) {
            console.error('Error polling order status:', e);
        }
    }, 5000); // Poll every 5 seconds
    
    // Stop polling after 5 minutes
    setTimeout(() => clearInterval(pollInterval), 300000);
}

// Update order status display
function updateOrderStatusDisplay(positionId, status) {
    // Find position in UI and update status
    const positionElement = document.querySelector(`[data-position-id="${positionId}"]`);
    if (positionElement) {
        const statusBadge = positionElement.querySelector('.status-badge');
        if (statusBadge) {
            statusBadge.textContent = status.status;
            statusBadge.className = `status-badge status-${status.status.toLowerCase()}`;
        }
    }
}

// Show detailed notification
function showDetailedNotification(message, type) {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `detailed-notification ${type}`;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        max-width: 400px;
        padding: 20px;
        background: ${type === 'success' ? '#1b5e20' : '#b71c1c'};
        color: white;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 100001;
        font-family: monospace;
        white-space: pre-line;
        animation: slideIn 0.3s ease;
    `;
    
    notification.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: start;">
            <div style="flex: 1;">${message}</div>
            <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: white; cursor: pointer; font-size: 20px; margin-left: 10px;">Ã—</button>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.remove();
        }
    }, 10000);
}

// Play sound notification
function playSound(type) {
    try {
        const audio = new Audio();
        if (type === 'success') {
            audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSpopdzxvnkwBz6A0fPTezEHPHvI8NeCLgUjceD47Xg+HUmr3+miXh0wtNfXimcdaaTb1nk6FEGk4OWeMClbo9zbi1ghMLzY2IM1FDmh3OacTRY2n9vWljsWS6rn6Z1RGlCw8OecVhw7k9XikVsyb7Pp6pNXHF2t0sKCWyBbvNjRfS0UN5rv/LJlDwBtp/Dm0YJ0U5vO4KZ+dkt1mce5l4mTV6LZ7q1tFABSgp+iiaB+YGyBgsHI2+2SX0mLu6yVkWdXZHeEqKWtmHVIUYKKk4dqam1ybWpue3p9rLe5g11YVob2/vSmUBEFQ3Tu5VkaBw5v0OLFhB0ECy9w3euygS0FJ3jg5ZcrAQJPydnbsiMDDEzP1+KTIAZJX+TqxGw4FRCmteHIrGQ0FEmNzNWfkUALPYO38NSEJgs2W8rIx3szEAMZm9Xs';
        } else {
            audio.src = 'data:audio/wav;base64,UklGRhYCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YfIBAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAA';
        }
        audio.play();
    } catch (e) {
        // Ignore audio errors
    }
}

// Get auth token if using authentication
function getAuthToken() {
    return localStorage.getItem('authToken') || '';
}

// Replace the old executeTrade function
window.executeTrade = window.executeProductionTrade;

// Update manual execution to use production function
window.executeManualTrade = async function(alertId) {
    const alert = window.pendingAlerts[alertId];
    if (!alert) {
        showNotification('Alert not found', 'error');
        return;
    }
    
    // Immediately disable all buttons
    const alertElement = document.getElementById(alertId);
    const executeBtn = alertElement.querySelector('.btn-execute');
    const allButtons = alertElement.querySelectorAll('.btn-alert-action');
    
    allButtons.forEach(btn => btn.disabled = true);
    
    // Show loading state
    const originalBtnHTML = executeBtn.innerHTML;
    executeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Executing...';
    
    try {
        // Use production execution
        const success = await executeProductionTrade(
            alert.signal,
            alert.strike,
            alert.type,
            alert.action
        );
        
        if (success) {
            // Mark as executed
            alertElement.classList.add('executed');
            alertElement.style.opacity = '0.7';
            alertElement.style.borderColor = 'var(--accent-green)';
            executeBtn.innerHTML = '<i class="fas fa-check"></i> Executed';
            executeBtn.style.background = 'var(--accent-green)';
            
            // Remove from pending
            delete window.pendingAlerts[alertId];
            updatePendingAlertsCount();
        } else {
            // Re-enable buttons on failure
            allButtons.forEach(btn => btn.disabled = false);
            executeBtn.innerHTML = originalBtnHTML;
        }
    } catch (error) {
        console.error('Manual execution error:', error);
        allButtons.forEach(btn => btn.disabled = false);
        executeBtn.innerHTML = originalBtnHTML;
    }
};

console.log('âœ… Production-ready trade execution loaded');
// =========================================================


        
// ============== PRODUCTION TRADE EXECUTION ==============
/**
 * Production-Ready Trade Execution Frontend
 * Complete implementation with proper error handling and order tracking
 */

// Production Trade Execution Function
window.executeProductionTrade = async function(signal, strike, type, action = 'ENTRY') {
    const mode = 'LIVE';
    console.log(`[TRADE] Executing production trade: ${signal} ${strike}${type}`);
    
    // Gather all configuration
    const config = gatherTradeConfiguration();
    
    // Validate before execution
    const validation = validateTradeParameters(signal, strike, type, config);
    if (!validation.valid) {
        showNotification(`Validation failed: ${validation.errors.join(', ')}`, 'error');
        return false;
    }
    
    // Get current spot price
    const spotPrice = await fetchCurrentSpotPrice();
    
    // Log the actual configuration for debugging
    console.log('[TRADE] Configuration gathered:', config);
    console.log('[TRADE] Lots from UI:', config.numLots);
    
    // Build complete request payload with ALL UI settings
    const payload = {
        // Signal and market data
        signal_type: signal,
        current_spot: spotPrice,
        
        // Position details
        strike: strike,
        option_type: type,
        quantity: config.numLots,
        action: action,
        
        // EXPIRY - Most important!
        expiry: config.selectedExpiry,
        
        // Exit configuration
        exit_time: config.exitTime,
        exit_day_offset: config.exitDayOffset,
        use_weekday_config: config.useWeekdayConfig,
        
        // AMO settings
        amo_enabled: config.amoEnabled,
        
        // Hedge configuration
        hedge_enabled: config.hedgeEnabled,
        hedge_offset: config.hedgeOffset,
        hedge_percentage: 30.0,
        
        // Stop loss parameters
        profit_lock_enabled: config.profitLockEnabled,
        profit_target: config.profitTarget,
        profit_lock: config.profitLock,
        trailing_stop_enabled: config.trailingStopEnabled,
        trail_percent: config.trailPercent,
        
        // Entry timing
        entry_timing: config.entryTiming,
        
        // Risk limits
        max_loss_per_trade: config.maxLossPerTrade || 20000.0,
        max_exposure: config.maxExposure || 200000.0,
        max_position_size: 30,
        
        // Active signals (for reference)
        active_signals: config.activeSignals
    };
    
    // Log the final payload being sent
    console.log('[TRADE] Final payload to API:', JSON.stringify(payload, null, 2));
    console.log('[TRADE] Specifically, quantity field:', payload.quantity);
    
    // Show confirmation dialog
    const confirmed = await showTradeConfirmation(payload);
    if (!confirmed) return false;
    
    // Show loading state
    const loadingId = showLoadingOverlay('Executing trade...');
    
    try {
        // Execute the trade
        const response = await fetch(getApiUrl('/api/v1/execute-trade'), {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${getAuthToken()}`  // Add auth if needed
            },
            body: JSON.stringify(payload)
        });
        
        const result = await response.json();
        
        if (response.ok && result.success) {
            // Trade successful
            await handleTradeSuccess(result);
            return true;
        } else {
            // Trade failed
            await handleTradeFailure(result, response.status);
            return false;
        }
        
    } catch (error) {
        // Network or other error
        await handleTradeError(error);
        return false;
        
    } finally {
        hideLoadingOverlay(loadingId);
    }
};

// Gather all trade configuration from UI
function gatherTradeConfiguration() {
    // Get all UI configuration including expiry, exit time, AMO, etc.
    const lotsElement = document.getElementById('numLots');
    const lotsValue = lotsElement ? parseInt(lotsElement.value) : null;
    console.log('[CONFIG] Lots value from UI:', lotsValue);
    
    // Use UI value, NOT tempLots (which is for modified alerts only)
    // Clear tempLots after reading to prevent it from affecting future trades
    const finalLots = lotsValue || 5; // Use UI value or default to 5
    delete window.tempLots; // Clear any temporary override
    
    return {
        // Position sizing - Always use UI value
        numLots: finalLots,
        
        // Expiry configuration - IMPORTANT!
        selectedExpiry: document.getElementById('expiryDate')?.value || getCurrentExpiry(),
        
        // Exit timing configuration
        exitTime: document.getElementById('exitTime')?.value || '15:25',
        exitDayOffset: parseInt(document.getElementById('exitDayOffset')?.value) || 0,
        useWeekdayConfig: document.getElementById('useWeekdayConfig')?.checked || false,
        
        // AMO configuration
        amoEnabled: document.getElementById('amoEnabled')?.checked || false,
        
        // Hedge configuration
        hedgeEnabled: document.getElementById('enableHedge')?.checked || false,
        hedgeOffset: parseInt(document.getElementById('hedgeOffset')?.value) || 200,
        
        // Stop loss management
        profitLockEnabled: document.getElementById('profitLockEnabled')?.checked || false,
        profitTarget: parseFloat(document.getElementById('profitTarget')?.value) || 10,
        profitLock: parseFloat(document.getElementById('profitLock')?.value) || 5,
        trailingStopEnabled: document.getElementById('trailingStopEnabled')?.checked || false,
        trailPercent: parseFloat(document.getElementById('trailPercent')?.value) || 1,
        
        // Entry timing
        entryTiming: document.getElementById('entryTiming')?.value || 'immediate',
        
        // Risk management
        maxLossPerTrade: parseFloat(document.getElementById('maxLossPerTrade')?.value) || 20000,
        maxExposure: parseFloat(document.getElementById('maxExposure')?.value) || 200000,
        
        // Active signals (for auto trade)
        activeSignals: Array.from(document.querySelectorAll('.signal-toggle:checked')).map(cb => cb.getAttribute('data-signal') || cb.value).filter(v => v && v !== 'on')
    };
}

// Validate trade parameters
function validateTradeParameters(signal, strike, type, config) {
    const errors = [];
    
    // Validate signal
    const validSignals = ['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8'];
    if (!validSignals.includes(signal)) {
        errors.push(`Invalid signal: ${signal}`);
    }
    
    // Validate strike
    if (strike < 10000 || strike > 50000) {
        errors.push(`Strike ${strike} out of range`);
    }
    if (strike % 50 !== 0) {
        errors.push('Strike must be multiple of 50');
    }
    
    // Validate option type
    if (!['PE', 'CE'].includes(type)) {
        errors.push(`Invalid option type: ${type}`);
    }
    
    // Validate quantity
    if (config.numLots < 1 || config.numLots > 30) {
        errors.push('Quantity must be between 1 and 30 lots');
    }
    
    // Validate stop loss config
    if (config.profitLockEnabled) {
        if (config.profitTarget <= 0) {
            errors.push('Profit target must be positive');
        }
        if (config.profitLock >= config.profitTarget) {
            errors.push('Profit lock must be less than target');
        }
    }
    
    return {
        valid: errors.length === 0,
        errors: errors
    };
}

// Fetch current NIFTY spot price
async function fetchCurrentSpotPrice() {
    try {
        const response = await fetch(getApiUrl('/api/live/nifty-spot'));
        if (response.ok) {
            const data = await response.json();
            if (data.success && data.data) {
                return data.data.ltp;
            }
        }
    } catch (e) {
        console.warn('Could not fetch spot price, using default');
    }
    return null; // No data available
}

// Show trade confirmation dialog with full details
async function showTradeConfirmation(payload) {
    const lotSize = 75;
    const totalQty = payload.quantity * lotSize;
    const hedgeStrike = payload.hedge_enabled ? 
        (payload.option_type === 'PE' ? 
            payload.strike - payload.hedge_offset : 
            payload.strike + payload.hedge_offset) : null;
    
    // Create detailed confirmation message
    let message = `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘     PRODUCTION TRADE CONFIRMATION     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Signal: ${payload.signal_type}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“Š POSITION DETAILS:
â€¢ Main Leg: SELL ${payload.strike}${payload.option_type}
${payload.hedge_enabled ? `â€¢ Hedge Leg: BUY ${hedgeStrike}${payload.option_type}` : 'â€¢ Hedge: DISABLED âš ï¸'}
â€¢ Quantity: ${payload.quantity} lots (${totalQty} qty)
â€¢ Spot Price: ${payload.current_spot.toFixed(2)}

ðŸ“ˆ RISK MANAGEMENT:
â€¢ Max Risk: ${payload.hedge_enabled ? `â‚¹${(payload.hedge_offset * totalQty).toLocaleString()}` : 'UNLIMITED âš ï¸'}
â€¢ Est. Margin: â‚¹${(payload.quantity * 15000).toLocaleString()}
${payload.profit_lock_enabled ? `â€¢ Profit Lock: ${payload.profit_target}% target, ${payload.profit_lock}% lock` : ''}
${payload.trailing_stop_enabled ? `â€¢ Trailing Stop: ${payload.trail_percent}%` : ''}

â° ENTRY: ${payload.entry_timing === 'immediate' ? 'IMMEDIATE' : 'NEXT CANDLE'}

âš ï¸ THIS IS A REAL MONEY TRADE âš ï¸
`;
    
    return confirm(message);
}

// Show loading overlay
function showLoadingOverlay(message) {
    const overlayId = `loading-${Date.now()}`;
    const overlay = document.createElement('div');
    overlay.id = overlayId;
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100000;
    `;
    
    overlay.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 30px; border-radius: 12px; text-align: center;">
            <div class="spinner" style="width: 50px; height: 50px; border: 4px solid var(--border-color); border-top-color: var(--accent-blue); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
            <h3 style="color: var(--text-primary); margin: 0 0 10px 0;">${message}</h3>
            <p style="color: var(--text-muted); margin: 0;">Please wait, do not close this window...</p>
        </div>
        <style>
            @keyframes spin { to { transform: rotate(360deg); } }
        </style>
    `;
    
    document.body.appendChild(overlay);
    return overlayId;
}

// Hide loading overlay
function hideLoadingOverlay(overlayId) {
    const overlay = document.getElementById(overlayId);
    if (overlay) {
        overlay.remove();
    }
}

// Handle successful trade execution
async function handleTradeSuccess(result) {
    console.log('[TRADE] Success:', result);
    
    // Create success message
    let message = `âœ… Trade Executed Successfully!\n\n`;
    
    if (result.main_order) {
        message += `Main Order: ${result.main_order.order_id}\n`;
        message += `Strike: ${result.main_order.strike}${result.main_order.type}\n`;
        message += `Quantity: ${result.main_order.quantity}\n`;
        message += `Premium: â‚¹${result.main_order.premium}\n\n`;
    }
    
    if (result.hedge_order) {
        message += `Hedge Order: ${result.hedge_order.order_id}\n`;
        message += `Strike: ${result.hedge_order.strike}${result.hedge_order.type}\n`;
        message += `Quantity: ${result.hedge_order.quantity}\n`;
        message += `Premium: â‚¹${result.hedge_order.premium}\n\n`;
    }
    
    if (result.risk_metrics) {
        message += `Max Risk: â‚¹${result.risk_metrics.max_risk.toLocaleString()}\n`;
        message += `Margin Used: â‚¹${result.risk_metrics.margin_required.toLocaleString()}\n`;
        message += `Breakeven: ${result.risk_metrics.breakeven}`;
    }
    
    // Show detailed success notification
    showDetailedNotification(message, 'success');
    
    // Update UI
    if (window.loadLivePositions) {
        await window.loadLivePositions();
    }
    
    // Track the order
    trackOrderStatus(result.position_id, result.main_order.order_id, result.hedge_order?.order_id);
    
    // Play success sound if available
    playSound('success');
}

// Handle trade failure
async function handleTradeFailure(result, statusCode) {
    console.error('[TRADE] Failed:', result);
    
    let message = 'âŒ Trade Execution Failed\n\n';
    
    if (statusCode === 400) {
        message += 'Validation Error:\n';
    } else if (statusCode === 403) {
        message += 'Risk Limit Exceeded:\n';
    } else {
        message += 'Server Error:\n';
    }
    
    message += result.detail || result.message || 'Unknown error occurred';
    
    // Add helpful suggestions
    message += '\n\nPlease check:\n';
    message += 'â€¢ API connection status\n';
    message += 'â€¢ Broker connection\n';
    message += 'â€¢ Available margin\n';
    message += 'â€¢ Market hours (9:15 AM - 3:30 PM)\n';
    
    showDetailedNotification(message, 'error');
    playSound('error');
}

// Handle network or unexpected errors
async function handleTradeError(error) {
    console.error('[TRADE] Error:', error);
    
    let message = 'âŒ Trade Execution Error\n\n';
    message += error.message || 'Network error occurred';
    message += '\n\nPossible causes:\n';
    message += 'â€¢ API server not running\n';
    message += 'â€¢ Network connection issue\n';
    message += 'â€¢ Invalid API endpoint\n';
    
    showDetailedNotification(message, 'error');
    playSound('error');
}

// Track order status
function trackOrderStatus(positionId, mainOrderId, hedgeOrderId) {
    // Create order tracking entry
    const trackingData = {
        positionId: positionId,
        mainOrderId: mainOrderId,
        hedgeOrderId: hedgeOrderId,
        timestamp: new Date().toISOString(),
        status: 'PENDING'
    };
    
    // Store in session
    if (!window.activeOrders) {
        window.activeOrders = {};
    }
    window.activeOrders[positionId] = trackingData;
    
    // Start polling for status updates
    const pollInterval = setInterval(async () => {
        try {
            const response = await fetch(getApiUrl(`/api/order-status/${mainOrderId}`));
            if (response.ok) {
                const status = await response.json();
                
                // Update tracking data
                trackingData.status = status.status;
                
                // Update UI if needed
                updateOrderStatusDisplay(positionId, status);
                
                // Stop polling if order is complete or rejected
                if (['COMPLETE', 'REJECTED', 'CANCELLED'].includes(status.status)) {
                    clearInterval(pollInterval);
                }
            }
        } catch (e) {
            console.error('Error polling order status:', e);
        }
    }, 5000); // Poll every 5 seconds
    
    // Stop polling after 5 minutes
    setTimeout(() => clearInterval(pollInterval), 300000);
}

// Update order status display
function updateOrderStatusDisplay(positionId, status) {
    // Find position in UI and update status
    const positionElement = document.querySelector(`[data-position-id="${positionId}"]`);
    if (positionElement) {
        const statusBadge = positionElement.querySelector('.status-badge');
        if (statusBadge) {
            statusBadge.textContent = status.status;
            statusBadge.className = `status-badge status-${status.status.toLowerCase()}`;
        }
    }
}

// Show detailed notification
function showDetailedNotification(message, type) {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `detailed-notification ${type}`;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        max-width: 400px;
        padding: 20px;
        background: ${type === 'success' ? '#1b5e20' : '#b71c1c'};
        color: white;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 100001;
        font-family: monospace;
        white-space: pre-line;
        animation: slideIn 0.3s ease;
    `;
    
    notification.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: start;">
            <div style="flex: 1;">${message}</div>
            <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: white; cursor: pointer; font-size: 20px; margin-left: 10px;">Ã—</button>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.remove();
        }
    }, 10000);
}

// Play sound notification
function playSound(type) {
    try {
        const audio = new Audio();
        if (type === 'success') {
            audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSpopdzxvnkwBz6A0fPTezEHPHvI8NeCLgUjceD47Xg+HUmr3+miXh0wtNfXimcdaaTb1nk6FEGk4OWeMClbo9zbi1ghMLzY2IM1FDmh3OacTRY2n9vWljsWS6rn6Z1RGlCw8OecVhw7k9XikVsyb7Pp6pNXHF2t0sKCWyBbvNjRfS0UN5rv/LJlDwBtp/Dm0YJ0U5vO4KZ+dkt1mce5l4mTV6LZ7q1tFABSgp+iiaB+YGyBgsHI2+2SX0mLu6yVkWdXZHeEqKWtmHVIUYKKk4dqam1ybWpue3p9rLe5g11YVob2/vSmUBEFQ3Tu5VkaBw5v0OLFhB0ECy9w3euygS0FJ3jg5ZcrAQJPydnbsiMDDEzP1+KTIAZJX+TqxGw4FRCmteHIrGQ0FEmNzNWfkUALPYO38NSEJgs2W8rIx3szEAMZm9Xs';
        } else {
            audio.src = 'data:audio/wav;base64,UklGRhYCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YfIBAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAA';
        }
        audio.play();
    } catch (e) {
        // Ignore audio errors
    }
}

// Get auth token if using authentication
function getAuthToken() {
    return localStorage.getItem('authToken') || '';
}

// Replace the old executeTrade function
window.executeTrade = window.executeProductionTrade;

// Update manual execution to use production function
window.executeManualTrade = async function(alertId) {
    const alert = window.pendingAlerts[alertId];
    if (!alert) {
        showNotification('Alert not found', 'error');
        return;
    }
    
    // Immediately disable all buttons
    const alertElement = document.getElementById(alertId);
    const executeBtn = alertElement.querySelector('.btn-execute');
    const allButtons = alertElement.querySelectorAll('.btn-alert-action');
    
    allButtons.forEach(btn => btn.disabled = true);
    
    // Show loading state
    const originalBtnHTML = executeBtn.innerHTML;
    executeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Executing...';
    
    try {
        // Use production execution
        const success = await executeProductionTrade(
            alert.signal,
            alert.strike,
            alert.type,
            alert.action
        );
        
        if (success) {
            // Mark as executed
            alertElement.classList.add('executed');
            alertElement.style.opacity = '0.7';
            alertElement.style.borderColor = 'var(--accent-green)';
            executeBtn.innerHTML = '<i class="fas fa-check"></i> Executed';
            executeBtn.style.background = 'var(--accent-green)';
            
            // Remove from pending
            delete window.pendingAlerts[alertId];
            updatePendingAlertsCount();
        } else {
            // Re-enable buttons on failure
            allButtons.forEach(btn => btn.disabled = false);
            executeBtn.innerHTML = originalBtnHTML;
        }
    } catch (error) {
        console.error('Manual execution error:', error);
        allButtons.forEach(btn => btn.disabled = false);
        executeBtn.innerHTML = originalBtnHTML;
    }
};

console.log('âœ… Production-ready trade execution loaded');
// =========================================================

// Update Market Data Status Panel
window.updateMarketDataStatus = function(type, data) {
    if (type === 'spot') {
        const els = {
            price: document.getElementById('statusSpotPrice'),
            time: document.getElementById('statusSpotTime'),
            age: document.getElementById('statusSpotAge'),
            source: document.getElementById('statusSpotSource'),
            validation: document.getElementById('statusSpotValidation')
        };
        
        if (els.price) els.price.textContent = data.price || '--';
        if (els.time) els.time.textContent = data.time || '--:--:--';
        if (els.age) {
            els.age.textContent = data.age || '--';
            els.age.style.color = data.age === '0s' || data.age === 'LIVE' ? 'var(--accent-green)' :
                                 data.age.includes('s') && parseInt(data.age) < 60 ? 'var(--accent-yellow)' : 
                                 'var(--accent-red)';
        }
        if (els.source) els.source.textContent = data.source || '--';
        if (els.validation) {
            if (data.valid) {
                els.validation.textContent = 'âœ“ Can Trade';
                els.validation.style.background = 'rgba(0,255,136,0.2)';
                els.validation.style.color = 'var(--accent-green)';
            } else {
                els.validation.textContent = 'âœ— Too Old';
                els.validation.style.background = 'rgba(255,51,102,0.2)';
                els.validation.style.color = 'var(--accent-red)';
            }
        }
    } else if (type === '1h') {
        const els = {
            candle: document.getElementById('status1HCandle'),
            period: document.getElementById('status1HPeriod'),
            time: document.getElementById('status1HTime'),
            age: document.getElementById('status1HAge'),
            validation: document.getElementById('status1HValidation')
        };
        
        if (els.candle) els.candle.textContent = data.close || '--';
        if (els.period) els.period.textContent = data.period || 'XX:15 - XX:15';
        if (els.time) els.time.textContent = data.time || '--:--:--';
        if (els.age) els.age.textContent = data.age || '--';
        if (els.validation) {
            if (data.valid) {
                els.validation.textContent = 'âœ“ Valid';
                els.validation.style.background = 'rgba(0,212,255,0.2)';
                els.validation.style.color = 'var(--accent-blue)';
            } else {
                els.validation.textContent = 'âœ— Stale';
                els.validation.style.background = 'rgba(255,51,102,0.2)';
                els.validation.style.color = 'var(--accent-red)';
            }
        }
        
        // Update candle monitor section
        const candlePeriodEl = document.getElementById('candlePeriod');
        if (candlePeriodEl) candlePeriodEl.textContent = data.period || 'XX:15 - XX:15';
        
        const candleAgeEl = document.getElementById('candleDataAge');
        if (candleAgeEl) candleAgeEl.textContent = `Age: ${data.age || '--'}`;
        
        // Update Current NIFTY in candle monitor
        const candleTimeEl = document.getElementById('candleCurrentNiftyTime');
        if (candleTimeEl) candleTimeEl.textContent = `Updated: ${data.time || '--:--:--'}`;
    }
    
    // Update overall status
    updateOverallSystemStatus();
}

// Get server time from API instead of using local system time
window.getServerTime = async function() {
    try {
        const response = await fetch(getApiUrl('/server-time'));
        if (response.ok) {
            const data = await response.json();
            if (data.time) {
                return new Date(data.time);
            }
        }
    } catch (error) {
        console.error('Failed to get server time:', error);
    }
    // Fallback to local time with warning
    console.warn('WARNING: Using local system time - may be incorrect!');
    return new Date();
}

// Get correct 1H candle period for Indian markets (XX:15 boundaries)
window.get1HCandlePeriod = function(date) {
    const hour = date.getHours();
    const minute = date.getMinutes();
    
    // Market hours: 9:15 AM to 3:30 PM
    if (hour < 9 || (hour === 9 && minute < 15)) {
        return null; // Market not open
    }
    if (hour > 15 || (hour === 15 && minute > 30)) {
        return null; // Market closed
    }
    
    // Determine current and last completed candle
    let currentPeriod, lastCompleted;
    
    if (hour === 9 || (hour === 10 && minute < 15)) {
        currentPeriod = "09:15-10:15";
        lastCompleted = null;
    } else if (hour === 10 || (hour === 11 && minute < 15)) {
        currentPeriod = minute >= 15 ? "10:15-11:15" : "09:15-10:15";
        lastCompleted = minute >= 15 ? "09:15-10:15" : null;
    } else if (hour === 11 || (hour === 12 && minute < 15)) {
        currentPeriod = minute >= 15 ? "11:15-12:15" : "10:15-11:15";
        lastCompleted = minute >= 15 ? "10:15-11:15" : "09:15-10:15";
    } else if (hour === 12 || (hour === 13 && minute < 15)) {
        currentPeriod = minute >= 15 ? "12:15-13:15" : "11:15-12:15";
        lastCompleted = minute >= 15 ? "11:15-12:15" : "10:15-11:15";
    } else if (hour === 13 || (hour === 14 && minute < 15)) {
        currentPeriod = minute >= 15 ? "13:15-14:15" : "12:15-13:15";
        lastCompleted = minute >= 15 ? "12:15-13:15" : "11:15-12:15";
    } else if (hour === 14 || (hour === 15 && minute < 15)) {
        currentPeriod = minute >= 15 ? "14:15-15:15" : "13:15-14:15";
        lastCompleted = minute >= 15 ? "13:15-14:15" : "12:15-13:15";
    } else {
        currentPeriod = "15:15-15:30";
        lastCompleted = "14:15-15:15";
    }
    
    return {
        current: currentPeriod,
        lastCompleted: lastCompleted,
        isComplete: minute >= 15
    };
}

// Update overall system status based on data validation
window.updateOverallSystemStatus = function() {
    const overallStatus = document.getElementById('overallDataStatus');
    const tradingPermission = document.getElementById('tradingPermission');
    
    // Check spot validation status
    const spotValidation = document.getElementById('statusSpotValidation');
    const candleValidation = document.getElementById('status1HValidation');
    
    const spotValid = spotValidation && spotValidation.textContent.includes('âœ“');
    const candleValid = candleValidation && candleValidation.textContent.includes('âœ“');
    
    if (spotValid && candleValid) {
        if (overallStatus) {
            overallStatus.textContent = 'ALL SYSTEMS GO';
            overallStatus.style.background = 'var(--accent-green)';
        }
        if (tradingPermission) {
            tradingPermission.textContent = 'TRADING ENABLED';
            tradingPermission.style.background = 'var(--gradient-green)';
        }
    } else if (spotValid || candleValid) {
        if (overallStatus) {
            overallStatus.textContent = 'PARTIAL DATA';
            overallStatus.style.background = 'var(--accent-yellow)';
        }
        if (tradingPermission) {
            tradingPermission.textContent = 'TRADING LIMITED';
            tradingPermission.style.background = 'linear-gradient(135deg, #ff9500 0%, #ffd700 100%)';
        }
    } else {
        if (overallStatus) {
            overallStatus.textContent = 'DATA ISSUES';
            overallStatus.style.background = 'var(--accent-red)';
        }
        if (tradingPermission) {
            tradingPermission.textContent = 'TRADING DISABLED';
            tradingPermission.style.background = 'var(--gradient-red)';
        }
    }
    
    // Update next validation time
    const nextValTime = document.getElementById('nextValidationTime');
    if (nextValTime) {
        const nextTime = new Date();
        nextTime.setSeconds(nextTime.getSeconds() + 5);
        nextValTime.textContent = nextTime.toLocaleTimeString('en-IN', {hour12: false});
    }
}

// Track last data update times
window.lastDataUpdates = {
    spot: null,
    candle1h: null,
    candle5m: null
};

// Function to calculate and display age
function updateDataAges() {
    const now = new Date();
    
    // Update NIFTY Spot age
    if (window.lastDataUpdates.spot) {
        const ageSeconds = Math.floor((now - window.lastDataUpdates.spot) / 1000);
        const spotAgeEl = document.getElementById('niftySpotAge');
        const statusSpotAge = document.getElementById('statusSpotAge');
        
        let ageText, ageColor;
        if (ageSeconds < 5) {
            ageText = 'LIVE';
            ageColor = 'var(--accent-green)';
        } else if (ageSeconds < 30) {
            ageText = `${ageSeconds}s ago`;
            ageColor = 'var(--accent-green)';
        } else if (ageSeconds < 60) {
            ageText = `${ageSeconds}s ago`;
            ageColor = 'var(--accent-yellow)';
        } else if (ageSeconds < 300) {
            ageText = `${Math.floor(ageSeconds/60)}m ago`;
            ageColor = 'var(--accent-orange)';
        } else {
            ageText = 'STALE';
            ageColor = 'var(--accent-red)';
        }
        
        if (spotAgeEl) {
            spotAgeEl.textContent = ageText;
            spotAgeEl.style.color = ageColor;
        }
        if (statusSpotAge) {
            statusSpotAge.textContent = ageText;
            statusSpotAge.style.color = ageColor;
        }
        
        // Update validation status
        const spotValidation = document.getElementById('statusSpotValidation');
        if (spotValidation) {
            if (ageSeconds < 60) {
                spotValidation.textContent = 'âœ“ Can Trade';
                spotValidation.style.background = 'rgba(0,255,136,0.2)';
                spotValidation.style.color = 'var(--accent-green)';
            } else {
                spotValidation.textContent = 'âœ— Too Old';
                spotValidation.style.background = 'rgba(255,51,102,0.2)';
                spotValidation.style.color = 'var(--accent-red)';
            }
        }
    }
    
    // Update 1H Candle age
    if (window.lastDataUpdates.candle1h) {
        const ageMinutes = Math.floor((now - window.lastDataUpdates.candle1h) / 60000);
        const candleAgeEl = document.getElementById('candleDataAge');
        const status1HAge = document.getElementById('status1HAge');
        const lastCloseAgeEl = document.getElementById('candleLastCloseAge');
        
        let ageText, ageColor;
        if (ageMinutes < 1) {
            ageText = 'Just closed';
            ageColor = 'var(--accent-green)';
        } else if (ageMinutes < 30) {
            ageText = `${ageMinutes}m old`;
            ageColor = 'var(--accent-green)';
        } else if (ageMinutes < 60) {
            ageText = `${ageMinutes}m old`;
            ageColor = 'var(--accent-yellow)';
        } else {
            const hours = Math.floor(ageMinutes/60);
            const mins = ageMinutes % 60;
            ageText = mins > 0 ? `${hours}h ${mins}m old` : `${hours}h old`;
            ageColor = 'var(--accent-orange)';
        }
        
        if (candleAgeEl) candleAgeEl.textContent = `Age: ${ageText}`;
        if (status1HAge) status1HAge.textContent = ageText;
        
        // Also update Last 1H Close age based on current time and candle period
        const candlePeriod = get1HCandlePeriod(now);
        if (lastCloseAgeEl && candlePeriod && candlePeriod.lastCompleted) {
            const [endHour, endMinute] = candlePeriod.lastCompleted.split('-')[1].split(':').map(Number);
            const candleCloseTime = new Date(now);
            candleCloseTime.setHours(endHour, endMinute, 0, 0);
            
            const actualMinutes = Math.floor((now - candleCloseTime) / 60000);
            let actualAgeText;
            if (actualMinutes < 1) {
                actualAgeText = 'Just closed';
            } else if (actualMinutes < 60) {
                actualAgeText = `${actualMinutes}m ago`;
            } else {
                const h = Math.floor(actualMinutes / 60);
                const m = actualMinutes % 60;
                actualAgeText = m > 0 ? `${h}h ${m}m ago` : `${h}h ago`;
            }
            lastCloseAgeEl.textContent = `Age: ${actualAgeText}`;
            lastCloseAgeEl.style.color = actualMinutes < 30 ? 'var(--accent-green)' : 
                                        actualMinutes < 60 ? 'var(--accent-yellow)' : 
                                        'var(--accent-orange)';
        }
    }
    
    // Update next validation time
    const nextValTime = document.getElementById('nextValidationTime');
    if (nextValTime) {
        const nextTime = new Date();
        nextTime.setSeconds(nextTime.getSeconds() + 5);
        nextValTime.textContent = nextTime.toLocaleTimeString('en-IN', {hour12: false});
    }
    
    // Update overall status
    updateOverallSystemStatus();
}

// When data is updated, record the time
window.recordDataUpdate = function(type) {
    window.lastDataUpdates[type] = new Date();
}

// Start periodic age update (every second)
setInterval(updateDataAges, 1000);

// Start periodic validation check
setInterval(function() {
    // This would normally fetch fresh data and update all timestamps
    const lastValTime = document.getElementById('lastValidationTime');
    if (lastValTime) {
        lastValTime.textContent = new Date().toLocaleTimeString('en-IN', {hour12: false});
    }
}, 5000);

// IMPORTANT: Configuration is now loaded once in DOMContentLoaded event
// Weekday settings are loaded immediately after dropdown HTML
console.log('[INIT] Configuration loading handled by event listeners...');
setTimeout(() => {
    // Only load alert configuration here
    if (typeof loadAlertConfig === 'function') {
        console.log('[INIT] Loading alert configuration...');
        loadAlertConfig();
    }
}, 1000);

// Kill Switch Functions
let killSwitchActive = false;

async function checkKillSwitchStatus() {
    try {
        const response = await fetch('http://localhost:8000/api/kill-switch/status');
        const status = await response.json();
        updateKillSwitchUI(status);
        killSwitchActive = status.active;
    } catch (error) {
        console.error('Error checking kill switch status:', error);
    }
}

function updateKillSwitchUI(status) {
    const stateElement = document.getElementById('killSwitchState');
    const btnElement = document.getElementById('killSwitchBtn');
    const containerElement = document.getElementById('killSwitchContainer');
    
    if (status.active) {
        stateElement.textContent = 'ACTIVE';
        stateElement.style.color = 'var(--accent-red)';
        containerElement.style.borderColor = 'var(--accent-red)';
        btnElement.innerHTML = '<i class="fas fa-unlock"></i> RESET';
        btnElement.onclick = resetKillSwitch;
        btnElement.style.background = 'linear-gradient(135deg, #00ff88, #00d4aa)';
    } else {
        stateElement.textContent = 'READY';
        stateElement.style.color = 'var(--accent-green)';
        containerElement.style.borderColor = 'var(--glass-border)';
        btnElement.innerHTML = '<i class="fas fa-power-off"></i> TRIGGER';
        btnElement.onclick = triggerKillSwitch;
        btnElement.style.background = 'linear-gradient(135deg, #ff3366, #ff0044)';
    }
}

async function triggerKillSwitch() {
    const confirmed = confirm('âš ï¸ EMERGENCY KILL SWITCH âš ï¸\n\nThis will immediately:\nâ€¢ Block ALL new trades\nâ€¢ Disable auto trading\nâ€¢ Prevent webhook entries\n\nAre you absolutely sure?');
    
    if (!confirmed) return;
    
    try {
        const response = await fetch('http://localhost:8000/api/kill-switch/trigger', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                reason: 'Manual trigger from UI',
                source: 'tradingview_pro_dashboard'
            })
        });
        
        const result = await response.json();
        
        if (result.status === 'triggered') {
            showNotification('ðŸ”´ KILL SWITCH ACTIVATED', 'error');
            await checkKillSwitchStatus();
        } else {
            showNotification('Failed to trigger kill switch', 'error');
        }
    } catch (error) {
        console.error('Error triggering kill switch:', error);
        showNotification('Kill switch trigger failed!', 'error');
    }
}

async function resetKillSwitch() {
    const password = prompt('Enter authorization password to reset kill switch:');
    
    if (!password) return;
    
    try {
        const response = await fetch('http://localhost:8000/api/kill-switch/reset', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                authorized_by: password
            })
        });
        
        const result = await response.json();
        
        if (result.status === 'reset') {
            showNotification('âœ… Kill switch has been reset', 'success');
            await checkKillSwitchStatus();
        } else {
            showNotification('Failed to reset kill switch', 'error');
        }
    } catch (error) {
        console.error('Error resetting kill switch:', error);
        showNotification('Kill switch reset failed!', 'error');
    }
}

async function emergencyCloseAll() {
    const confirmed = confirm('âš ï¸ PANIC CLOSE ALL POSITIONS âš ï¸\n\nThis will close ALL open positions immediately at market price.\n\nAre you sure?');
    
    if (!confirmed) return;
    
    try {
        // First trigger kill switch to prevent new trades
        await fetch('http://localhost:8000/kill-switch/trigger', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                reason: 'Panic close initiated',
                source: 'emergency_close'
            })
        });
        
        // Then close all positions
        const response = await fetch('http://localhost:8000/positions/square-off-all', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });
        
        const result = await response.json();
        
        if (result.success) {
            showNotification(`ðŸ”´ PANIC CLOSE: ${result.closed_count} positions closed`, 'error');
            await loadActivePositions();
            await checkKillSwitchStatus();
        } else {
            showNotification('Panic close failed: ' + result.message, 'error');
        }
    } catch (error) {
        console.error('Error in panic close:', error);
        showNotification('Emergency close failed!', 'error');
    }
}

// Expiry Management Functions
async function loadAvailableExpiries() {
    try {
        const response = await fetch(getApiUrl('/api/expiry/available'));
        if (response.ok) {
            const data = await response.json();
            if (data.status === 'success') {
                populateExpiryOptions(data.data);
            }
        }
    } catch (error) {
        console.error('Error loading expiries:', error);
    }
}

function populateExpiryOptions(expiryData) {
    // Update each day's dropdown and show actual expiry dates
    const weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
    const currentDayName = expiryData.current_day;
    
    // Calculate actual expiry dates
    const expiries = calculateExpiryDates();
    
    weekdays.forEach(day => {
        const selectId = `expiry${day}`;
        const dateId = `${day.toLowerCase()}ExpiryDate`;
        const select = document.getElementById(selectId);
        const dateDiv = document.getElementById(dateId);
        
        if (select) {
            // Clear and populate options based on day
            select.innerHTML = '';
            
            if (day === 'Monday' || day === 'Tuesday') {
                // Current week expiry available
                const currentOption = document.createElement('option');
                currentOption.value = 'current';
                currentOption.textContent = 'Current Week';
                select.appendChild(currentOption);
            }
            
            // Add next week option
            const nextOption = document.createElement('option');
            nextOption.value = 'next';
            nextOption.textContent = 'Next Week';
            select.appendChild(nextOption);
            
            // Add month-end option
            const monthEndOption = document.createElement('option');
            monthEndOption.value = 'monthend';
            monthEndOption.textContent = 'Month End';
            select.appendChild(monthEndOption);
            
            // Restore saved value from localStorage or set defaults
            const savedConfig = localStorage.getItem('weekdayExpiryConfig');
            if (savedConfig) {
                try {
                    const config = JSON.parse(savedConfig);
                    if (config[day.toLowerCase()]) {
                        select.value = config[day.toLowerCase()];
                        console.log(`[EXPIRY LOAD] Restored ${day} to ${config[day.toLowerCase()]}`);
                    }
                } catch (e) {
                    console.error('Error restoring saved value:', e);
                }
            } else if (day === 'Wednesday' || day === 'Thursday' || day === 'Friday') {
                // Only set default if no saved config
                select.value = 'next'; // Default to next week for Wed-Fri
            }
            
            // Update the date display
            updateExpiryDateDisplay(day, select.value, expiries);
        }
        
        // Highlight current day
        const dayRow = select ? select.closest('.expiry-day-row') : null;
        if (dayRow && day === currentDayName) {
            dayRow.style.border = '2px solid var(--accent-blue)';
            dayRow.style.background = 'var(--bg-primary)';
        }
    });
    
    // Update today's configuration status
    updateTodayStatus(currentDayName, expiries);
}

function calculateExpiryDates() {
    const today = new Date();
    const currentDay = today.getDay();
    
    // Find this Tuesday
    const daysToTuesday = (2 - currentDay + 7) % 7;
    const thisTuesday = new Date(today);
    thisTuesday.setDate(today.getDate() + (daysToTuesday === 0 && today.getHours() >= 15 ? 7 : daysToTuesday));
    
    // Find next Tuesday
    const nextTuesday = new Date(thisTuesday);
    nextTuesday.setDate(thisTuesday.getDate() + 7);
    
    // Find month-end Tuesday
    const lastDayOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);
    const monthEndTuesday = new Date(lastDayOfMonth);
    while (monthEndTuesday.getDay() !== 2) {
        monthEndTuesday.setDate(monthEndTuesday.getDate() - 1);
    }
    
    return {
        current: thisTuesday.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
        next: nextTuesday.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
        monthend: monthEndTuesday.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
    };
}

function updateExpiryDateDisplay(day, selectedValue, expiries) {
    const dateId = `${day.toLowerCase()}ExpiryDate`;
    const dateDiv = document.getElementById(dateId);
    
    if (dateDiv) {
        let dateText = '';
        switch(selectedValue) {
            case 'current':
                dateText = 'â†’ Current Week';
                break;
            case 'next':
                dateText = 'â†’ Next Week';
                break;
            case 'monthend':
                dateText = 'â†’ Month End';
                break;
        }
        dateDiv.textContent = dateText;
        dateDiv.style.color = 'var(--accent-green)';
        dateDiv.style.fontWeight = 'bold';
    }
}

function updateTodayStatus(currentDay, expiries) {
    const statusDiv = document.getElementById('todayExpiryInfo');
    if (statusDiv) {
        const selectId = `expiry${currentDay}`;
        const select = document.getElementById(selectId);
        
        if (select) {
            const selectedOption = select.options[select.selectedIndex];
            const selectedDate = select.value === 'current' ? expiries.current : 
                               select.value === 'next' ? expiries.next : expiries.monthend;
            
            statusDiv.innerHTML = `
                <div>Today is <strong>${currentDay}</strong></div>
                <div>If signal comes today, will use: <strong>${selectedOption.textContent}</strong></div>
                <div>Expiry Date: <strong>${selectedDate}</strong></div>
            `;
        } else {
            // Weekend
            statusDiv.innerHTML = `
                <div>Today is <strong>${currentDay}</strong> (Weekend)</div>
                <div style="color: var(--accent-yellow);">No trading on weekends</div>
            `;
        }
    }
}

// Debounce timer for saveExpiryConfig
let saveExpiryConfigTimer = null;

async function saveExpiryConfig() {
    // Clear any existing timer
    if (saveExpiryConfigTimer) {
        clearTimeout(saveExpiryConfigTimer);
    }
    
    // Collect config immediately for localStorage
    const config = {};
    const weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
    
    weekdays.forEach(day => {
        const select = document.getElementById(`expiry${day}`);
        if (select) {
            config[day.toLowerCase()] = select.value;
        }
    });
    
    // Save to localStorage immediately
    localStorage.setItem('weekdayExpiryConfig', JSON.stringify(config));
    console.log('[EXPIRY] Saved to localStorage:', config);
    
    // Update date displays immediately
    const expiries = calculateExpiryDates();
    weekdays.forEach(day => {
        const select = document.getElementById(`expiry${day}`);
        if (select) {
            updateExpiryDateDisplay(day, select.value, expiries);
        }
    });
    
    // Debounce the backend save to avoid rapid consecutive saves
    saveExpiryConfigTimer = setTimeout(async () => {
        try {
            const response = await fetch(getApiUrl('/api/expiry/weekday-config'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(config)
            });
            
            if (response.ok) {
                console.log('[EXPIRY] Saved to backend');
                // Don't show notification for every change, too noisy
            }
        } catch (error) {
            console.error('Error saving expiry config to backend:', error);
        }
    }, 1000); // Wait 1 second before saving to backend
}

async function saveSelectedExpiry() {
    const selectedExpiry = document.getElementById('expiryDate').value;
    if (!selectedExpiry) {
        showNotification('Please select an expiry date', 'error');
        return;
    }
    
    try {
        const response = await fetch(getApiUrl('/api/expiry/select'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ expiry_date: selectedExpiry })
        });
        
        const data = await response.json();
        if (data.status === 'success') {
            showNotification(data.message, 'success');
        } else {
            showNotification(data.message || 'Failed to save expiry', 'error');
        }
    } catch (error) {
        console.error('Error saving expiry:', error);
        showNotification('Error saving expiry selection', 'error');
    }
}

// Exit Timing Functions
function updateExitPreview() {
    const exitDay = parseInt(document.getElementById('exitDayOffset').value);
    const exitTime = document.getElementById('exitTime').value;
    const exitPreview = document.getElementById('exitPreview');
    
    // Handle expiry day exit (T+0)
    if (exitDay === 0) {
        // Get next Tuesday (expiry day)
        const entryDate = new Date();
        let exitDate = new Date(entryDate);
        
        // Find next Tuesday
        const daysUntilTuesday = (2 - exitDate.getDay() + 7) % 7 || 7; // 2 = Tuesday
        exitDate.setDate(exitDate.getDate() + daysUntilTuesday);
        
        const dayName = exitDate.toLocaleDateString('en-US', { weekday: 'long' });
        const dateStr = exitDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        
        exitPreview.innerHTML = `
            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">
                ðŸ“… Exit Schedule: Expiry Day at ${exitTime}
            </div>
            <div style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                Position will exit on the actual expiry day (Tuesday):
            </div>
            <div style="margin-top: 5px; font-size: 14px; font-weight: 600; color: var(--accent-orange);">
                Next ${dayName}, ${dateStr} at ${exitTime}
            </div>
            <div style="margin-top: 8px; padding: 8px; background: rgba(255, 107, 0, 0.1); border-radius: 4px; font-size: 11px; color: var(--accent-orange);">
                âš ï¸ Important: Exit will be on the actual expiry Tuesday based on entry day and weekday config
            </div>
        `;
    } else {
        // Calculate T+N exit date
        const entryDate = new Date();
        let exitDate = new Date(entryDate);
        let tradingDaysAdded = 0;
        
        while (tradingDaysAdded < exitDay) {
            exitDate.setDate(exitDate.getDate() + 1);
            // Skip weekends
            if (exitDate.getDay() !== 0 && exitDate.getDay() !== 6) {
                tradingDaysAdded++;
            }
        }
        
        const dayName = exitDate.toLocaleDateString('en-US', { weekday: 'long' });
        const dateStr = exitDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        
        exitPreview.innerHTML = `
            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary);">
                ðŸ“… Exit Schedule: T+${exitDay} at ${exitTime}
            </div>
            <div style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                If trade entered today, exit will be on:
            </div>
            <div style="margin-top: 5px; font-size: 14px; font-weight: 600; color: var(--accent-blue);">
                ${dayName}, ${dateStr} at ${exitTime}
            </div>
            <div style="margin-top: 8px; padding: 8px; background: var(--bg-primary); border-radius: 4px; font-size: 11px;">
                âš ï¸ Note: Actual exit date will be calculated from trade entry time
            </div>
        `;
    }
}

function loadExitTimingConfig() {
    // Load from localStorage first
    const savedConfig = localStorage.getItem('exitTimingConfig');
    if (savedConfig) {
        try {
            const config = JSON.parse(savedConfig);
            if (document.getElementById('exitDayOffset')) {
                document.getElementById('exitDayOffset').value = config.exit_day_offset !== undefined ? config.exit_day_offset : 0;
            }
            if (document.getElementById('exitTime')) {
                document.getElementById('exitTime').value = config.exit_time || '15:15';
            }
            if (document.getElementById('autoSquareOffEnabled')) {
                document.getElementById('autoSquareOffEnabled').checked = config.auto_square_off_enabled !== false;
                // Show/hide config WITHOUT triggering save
                const exitTimingConfig = document.getElementById('exitTimingConfig');
                if (exitTimingConfig) {
                    exitTimingConfig.style.display = config.auto_square_off_enabled !== false ? 'flex' : 'none';
                }
            }
            updateExitPreview();
            console.log('[EXIT TIMING] Loaded from localStorage:', config);
        } catch (e) {
            console.error('Error loading exit timing config:', e);
        }
    }
    
    // Also try to load from file
    fetch('exit_timing_config.json')
        .then(r => r.json())
        .then(config => {
            if (config && !savedConfig) {
                // Apply if no localStorage config
                if (document.getElementById('exitDayOffset')) {
                    document.getElementById('exitDayOffset').value = config.exit_day_offset !== undefined ? config.exit_day_offset : 0;
                }
                if (document.getElementById('exitTime')) {
                    document.getElementById('exitTime').value = config.exit_time || '15:15';
                }
                if (document.getElementById('autoSquareOffEnabled')) {
                    document.getElementById('autoSquareOffEnabled').checked = config.auto_square_off_enabled !== false;
                    // Show/hide config WITHOUT triggering save
                    const exitTimingConfig = document.getElementById('exitTimingConfig');
                    if (exitTimingConfig) {
                        exitTimingConfig.style.display = config.auto_square_off_enabled !== false ? 'flex' : 'none';
                    }
                }
                updateExitPreview();
                console.log('[EXIT TIMING] Loaded from file:', config);
            }
        })
        .catch(() => {
            // File might not exist yet
        });
}

function saveWeekdayConfig() {
    const config = {};
    const weekdays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
    
    weekdays.forEach(day => {
        const dayElement = document.querySelector(`[data-day="${day}"]`);
        if (dayElement) {
            const select = dayElement.querySelector('select');
            if (select) {
                config[day] = select.value;
            }
        }
    });
    
    // Save to localStorage
    localStorage.setItem('weekdayExpiryConfig', JSON.stringify(config));
    console.log('[WEEKDAY CONFIG] Saved to localStorage:', config);
    
    // Also save to backend
    fetch(getApiUrl('/api/expiry/weekday-config'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config)
    }).catch(e => console.error('Error saving weekday config to backend:', e));
}

function loadWeekdayConfig() {
    // Load from localStorage first
    const savedConfig = localStorage.getItem('weekdayExpiryConfig');
    if (savedConfig) {
        try {
            const config = JSON.parse(savedConfig);
            Object.keys(config).forEach(day => {
                // Use the ID directly
                const dayCapitalized = day.charAt(0).toUpperCase() + day.slice(1);
                const select = document.getElementById(`expiry${dayCapitalized}`);
                if (select) {
                    select.value = config[day];
                    console.log(`[WEEKDAY CONFIG] Set ${day} to ${config[day]}`);
                }
            });
            console.log('[WEEKDAY CONFIG] Loaded from localStorage:', config);
        } catch (e) {
            console.error('Error loading weekday config:', e);
        }
    } else {
        // Try to load from file as fallback
        fetch('expiry_weekday_config.json')
            .then(r => r.json())
            .then(config => {
                if (config) {
                    Object.keys(config).forEach(day => {
                        // Use the ID directly
                        const dayCapitalized = day.charAt(0).toUpperCase() + day.slice(1);
                        const select = document.getElementById(`expiry${dayCapitalized}`);
                        if (select) {
                            select.value = config[day];
                        }
                    });
                    // Save to localStorage for next time
                    localStorage.setItem('weekdayExpiryConfig', JSON.stringify(config));
                    console.log('[WEEKDAY CONFIG] Loaded from file and saved to localStorage:', config);
                }
            })
            .catch(() => {
                console.log('[WEEKDAY CONFIG] No saved config found, using defaults');
            });
    }
}

async function saveExitTiming(showMessage = true) {
    const config = {
        exit_day_offset: parseInt(document.getElementById('exitDayOffset').value),
        exit_time: document.getElementById('exitTime').value,
        auto_square_off_enabled: document.getElementById('autoSquareOffEnabled').checked
    };
    
    // Save to localStorage as well
    localStorage.setItem('exitTimingConfig', JSON.stringify(config));
    
    try {
        const response = await fetch(getApiUrl('/api/exit-timing/configure'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(config)
        });
        
        const data = await response.json();
        if (data.status === 'success') {
            // Only show notification if explicitly requested
            if (showMessage) {
                showNotification('Exit timing configured', 'success');
            }
        } else {
            showNotification(data.message || 'Failed to save exit timing', 'error');
        }
    } catch (error) {
        console.error('Error saving exit timing:', error);
        if (showMessage) {
            showNotification('Error saving exit timing', 'error');
        }
    }
}

// Check kill switch status on page load and periodically
document.addEventListener('DOMContentLoaded', () => {
    checkKillSwitchStatus();
    setInterval(checkKillSwitchStatus, 5000); // Check every 5 seconds
    
    // Initialize expiry and exit timing
    loadAvailableExpiries();
    
    // Setup weekday config listeners immediately
    const weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
    weekdays.forEach(day => {
        const select = document.getElementById(`expiry${day}`);
        if (select) {
            select.addEventListener('change', () => {
                console.log(`[EVENT] ${day} dropdown changed to: ${select.value}`);
                saveExpiryConfig();
                // Update date display with available expiries
                const expiries = calculateExpiryDates();
                updateExpiryDateDisplay(day, select.value, expiries);
            });
        }
    });
    
    // Setup exit timing listeners immediately
    const exitDayOffset = document.getElementById('exitDayOffset');
    const exitTime = document.getElementById('exitTime');
    const autoSquareOff = document.getElementById('autoSquareOffEnabled');
    
    if (exitDayOffset) {
        exitDayOffset.addEventListener('change', () => {
            updateExitPreview();
            saveExitTiming();
        });
    }
    
    if (exitTime) {
        exitTime.addEventListener('change', () => {
            updateExitPreview();
            saveExitTiming();
        });
    }
    
    if (autoSquareOff) {
        autoSquareOff.addEventListener('change', () => {
            saveExitTiming();
            const exitConfig = document.getElementById('exitTimingConfig');
            if (exitConfig) {
                exitConfig.style.display = autoSquareOff.checked ? 'flex' : 'none';
            }
        });
    }
    
    document.getElementById('expiryDate')?.addEventListener('change', saveSelectedExpiry);
    
    // Load configurations after a short delay
    setTimeout(() => {
        // Load saved exit timing configuration
        loadExitTimingConfig();
        
        // Load saved weekday configuration  
        loadWeekdayConfig();
    }, 100); // Small delay to ensure DOM is ready
    
    // Removed duplicate event listener - already handled above
    
    // Initial preview
    updateExitPreview();
});

// Removed duplicate immediate load script - now located right after dropdown HTML

// Test Webhook Function
async function testWebhook() {
    try {
        // Get the payload text
        let payloadText = null;
        let payload = null;
        
        // First try to find by ID
        const textareaElement = document.getElementById('webhookPayload');
        if (textareaElement) {
            payloadText = textareaElement.value;
        } else {
            // Fallback: Try to find any textarea in webhook config section
            const webhookSection = document.querySelector('#webhookConfig');
            if (webhookSection) {
                const textarea = webhookSection.querySelector('textarea');
                if (textarea) {
                    payloadText = textarea.value;
                }
            }
            
            // Last resort: Find any textarea with JSON content
            if (!payloadText) {
                const allTextareas = document.querySelectorAll('textarea');
                for (let textarea of allTextareas) {
                    if (textarea.value && textarea.value.includes('"secret"')) {
                        payloadText = textarea.value;
                        break;
                    }
                }
            }
        }
        
        // Check if we found any payload text
        if (!payloadText) {
            showNotification('Could not find webhook payload textarea. Please refresh the page.', 'error');
            return;
        }
        
        // Parse the JSON
        try {
            payload = JSON.parse(payloadText);
        } catch (e) {
            showNotification('Invalid JSON format. Please check your payload.', 'error');
            return;
        }
        
        // Check if strike is a placeholder
        if (typeof payload.strike === 'string' && payload.strike.includes('{{')) {
            showNotification('Please replace {{plot_0}} with an actual strike price (e.g., 25000)', 'warning');
            return;
        }
        
        // Send the webhook
        console.log('Testing webhook with payload:', payload);
        const response = await fetch(getApiUrl('/webhook/entry'), {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });
        
        const result = await response.json();
        
        if (response.ok) {
            if (result.status === 'success') {
                showNotification('âœ… Webhook test successful! Check Active Orders.', 'success');
                // Refresh active orders
                if (typeof loadActiveOrders === 'function') {
                    loadActiveOrders();
                }
            } else if (result.status === 'blocked') {
                showNotification(`âš ï¸ Trade blocked: ${result.message}`, 'warning');
            } else if (result.status === 'ignored') {
                showNotification(`â„¹ï¸ ${result.message}`, 'info');
            } else {
                showNotification(`Response: ${JSON.stringify(result)}`, 'info');
            }
        } else {
            if (response.status === 401) {
                showNotification('âŒ Authentication failed. Check your secret key.', 'error');
            } else {
                showNotification(`âŒ Error: ${result.message || 'Unknown error'}`, 'error');
            }
        }
        
    } catch (error) {
        console.error('Webhook test error:', error);
        showNotification(`âŒ Connection error: ${error.message}`, 'error');
    }
}

</script>

<!-- JavaScript files removed - not implemented yet -->

</body>
</html>